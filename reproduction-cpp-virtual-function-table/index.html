<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon_128x128.ico">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon_32x32.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon_16x16.ico">
  <link rel="mask-icon" href="/images/favicon_128x128.ico" color="#222">
  <meta name="google-site-verification" content="RTgcuE8O8uGo_CfqJBTz1zjZZiqDrsw0FN3QntVp6iQ">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"zkkkillua.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"path":"search.xml"};
  </script>

  <meta name="description" content="本篇博客全文转载自https:&#x2F;&#x2F;blog.twofei.com&#x2F;496&#x2F; 前言大家都应该知道C++的精髓是虚函数吧? 虚函数带来的好处就是: 可以定义一个基类的指针, 其指向一个继承类, 当通过基类的指针去调用函数时, 可以在运行时决定该调用基类的函数还是继承类的函数. 虚函数是实现多态(动态绑定)&#x2F;接口函数的基础. 可以说: 没有虚函数, C++将变得一无是处! 既然是C++的精髓,">
<meta property="og:type" content="article">
<meta property="og:title" content="[转载]C++中的虚函数(表)实现机制以及用C语言对其进行的模拟实现">
<meta property="og:url" content="https://zkkkillua.github.io/reproduction-cpp-virtual-function-table/index.html">
<meta property="og:site_name" content="zkkKillua&#39;s Blog">
<meta property="og:description" content="本篇博客全文转载自https:&#x2F;&#x2F;blog.twofei.com&#x2F;496&#x2F; 前言大家都应该知道C++的精髓是虚函数吧? 虚函数带来的好处就是: 可以定义一个基类的指针, 其指向一个继承类, 当通过基类的指针去调用函数时, 可以在运行时决定该调用基类的函数还是继承类的函数. 虚函数是实现多态(动态绑定)&#x2F;接口函数的基础. 可以说: 没有虚函数, C++将变得一无是处! 既然是C++的精髓,">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://zkkkillua.github.io/reproduction-cpp-virtual-function-table/1-1.png">
<meta property="og:image" content="https://zkkkillua.github.io/reproduction-cpp-virtual-function-table/3-1.png">
<meta property="og:image" content="https://zkkkillua.github.io/reproduction-cpp-virtual-function-table/3-2.png">
<meta property="og:image" content="https://zkkkillua.github.io/reproduction-cpp-virtual-function-table/4-1.png">
<meta property="og:image" content="https://zkkkillua.github.io/reproduction-cpp-virtual-function-table/4-2.png">
<meta property="og:image" content="https://zkkkillua.github.io/reproduction-cpp-virtual-function-table/4-3.png">
<meta property="og:image" content="https://zkkkillua.github.io/reproduction-cpp-virtual-function-table/4-4.png">
<meta property="og:image" content="https://zkkkillua.github.io/reproduction-cpp-virtual-function-table/5-1.png">
<meta property="og:image" content="https://zkkkillua.github.io/reproduction-cpp-virtual-function-table/5-2.png">
<meta property="og:image" content="https://zkkkillua.github.io/reproduction-cpp-virtual-function-table/5-3.png">
<meta property="og:image" content="https://zkkkillua.github.io/reproduction-cpp-virtual-function-table/6-1.png">
<meta property="og:image" content="https://zkkkillua.github.io/reproduction-cpp-virtual-function-table/6-2.png">
<meta property="og:image" content="https://zkkkillua.github.io/reproduction-cpp-virtual-function-table/7-1.png">
<meta property="og:image" content="https://zkkkillua.github.io/reproduction-cpp-virtual-function-table/7-2.png">
<meta property="og:image" content="https://zkkkillua.github.io/reproduction-cpp-virtual-function-table/7-3.png">
<meta property="og:image" content="https://zkkkillua.github.io/reproduction-cpp-virtual-function-table/8-1.png">
<meta property="og:image" content="https://zkkkillua.github.io/reproduction-cpp-virtual-function-table/8-2.png">
<meta property="og:image" content="https://zkkkillua.github.io/reproduction-cpp-virtual-function-table/8-3.png">
<meta property="og:image" content="https://zkkkillua.github.io/reproduction-cpp-virtual-function-table/9-1.png">
<meta property="og:image" content="https://zkkkillua.github.io/reproduction-cpp-virtual-function-table/9-2.png">
<meta property="og:image" content="https://zkkkillua.github.io/reproduction-cpp-virtual-function-table/9-3.png">
<meta property="og:image" content="https://zkkkillua.github.io/reproduction-cpp-virtual-function-table/9-4.png">
<meta property="og:image" content="https://zkkkillua.github.io/reproduction-cpp-virtual-function-table/10-1.png">
<meta property="og:image" content="https://zkkkillua.github.io/reproduction-cpp-virtual-function-table/10-2.png">
<meta property="og:image" content="https://zkkkillua.github.io/reproduction-cpp-virtual-function-table/10-3.png">
<meta property="og:image" content="https://zkkkillua.github.io/reproduction-cpp-virtual-function-table/11-1.png">
<meta property="og:image" content="https://zkkkillua.github.io/reproduction-cpp-virtual-function-table/11-2.jpg">
<meta property="og:image" content="https://zkkkillua.github.io/reproduction-cpp-virtual-function-table/c-1.png">
<meta property="og:image" content="https://zkkkillua.github.io/reproduction-cpp-virtual-function-table/last.png">
<meta property="article:published_time" content="2020-10-14T13:18:11.000Z">
<meta property="article:modified_time" content="2024-03-02T12:44:59.547Z">
<meta property="article:author" content="zkkKillua">
<meta property="article:tag" content="c++">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://zkkkillua.github.io/reproduction-cpp-virtual-function-table/1-1.png">

<link rel="canonical" href="https://zkkkillua.github.io/reproduction-cpp-virtual-function-table/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>[转载]C++中的虚函数(表)实现机制以及用C语言对其进行的模拟实现 | zkkKillua's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">zkkKillua's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/zkkkillua" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zkkkillua.github.io/reproduction-cpp-virtual-function-table/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="zkkKillua">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zkkKillua's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          [转载]C++中的虚函数(表)实现机制以及用C语言对其进行的模拟实现
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-10-14 21:18:11" itemprop="dateCreated datePublished" datetime="2020-10-14T21:18:11+08:00">2020-10-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-03-02 20:44:59" itemprop="dateModified" datetime="2024-03-02T20:44:59+08:00">2024-03-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/c/" itemprop="url" rel="index"><span itemprop="name">c++</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="far fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>本篇博客全文转载自<a target="_blank" rel="noopener" href="https://blog.twofei.com/496/">https://blog.twofei.com/496/</a></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>大家都应该知道C++的精髓是虚函数吧? 虚函数带来的好处就是: 可以定义一个基类的指针, 其指向一个继承类, 当通过基类的指针去调用函数时, 可以在运行时决定该调用基类的函数还是继承类的函数. 虚函数是实现多态(动态绑定)&#x2F;接口函数的基础. 可以说: 没有虚函数, C++将变得一无是处!</p>
<p>既然是C++的精髓, 那么我们有必要了解一下她的实现方式吗? 有必要! 既然C++是从C语言的基础上发展而来的, 那么我们可以尝试用C语言来模拟实现吗? 有可能! 接下来, 就是我一步一步地来解析C++的虚函数的实现方式, 以及用C语言对其进行的模拟.</p>
<h2 id="C-对象的内存布局"><a href="#C-对象的内存布局" class="headerlink" title="C++对象的内存布局"></a>C++对象的内存布局</h2><p>要想知道C++对象的内存布局, 可以有多种方式, 比如:</p>
<ol>
<li><p>输出成员变量的偏移, 通过offsetof宏来得到</p>
</li>
<li><p>通过调试器查看, 比如常用的VS</p>
</li>
<li><h3 id="只有数据成员的对象"><a href="#只有数据成员的对象" class="headerlink" title="只有数据成员的对象"></a>只有数据成员的对象</h3><p>类实现如下:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base1</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> base1_1;</span><br><span class="line">    <span class="type">int</span> base1_2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>对象大小及偏移:</p>
<table>
<thead>
<tr>
<th>sizeof(Base1)</th>
<th>8</th>
</tr>
</thead>
<tbody><tr>
<td>offsetof(Base1, base1_1)</td>
<td>0</td>
</tr>
<tr>
<td>offsetof(Base1, base1_2)</td>
<td>4</td>
</tr>
</tbody></table>
<p>可知对象布局:</p>
<img src="/reproduction-cpp-virtual-function-table/1-1.png" class="" title="img">

<p>可以看到, 成员变量是按照定义的顺序来保存的, 最先声明的在最上边, 然后依次保存!<br>类对象的大小就是所有成员变量大小之和.</p>
</li>
<li><h3 id="没有虚函数的对象"><a href="#没有虚函数的对象" class="headerlink" title="没有虚函数的对象"></a>没有虚函数的对象</h3><p>类实现如下:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base1</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> base1_1;</span><br><span class="line">    <span class="type">int</span> base1_2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>结果如下:</p>
<table>
<thead>
<tr>
<th>sizeof(Base1)</th>
<th>8</th>
</tr>
</thead>
<tbody><tr>
<td>offsetof(Base1, base1_1)</td>
<td>0</td>
</tr>
<tr>
<td>offsetof(Base1, base1_2)</td>
<td>4</td>
</tr>
</tbody></table>
<p>和前面的结果是一样的? 不需要有什么疑问对吧?<br>因为如果一个函数不是虚函数,那么他就不可能会发生动态绑定,也就不会对对象的布局造成任何影响.<br>当调用一个非虚函数时, 那么调用的一定就是当前指针类型拥有的那个成员函数. 这种调用机制在编译时期就确定下来了.</p>
</li>
<li><h3 id="拥有仅一个虚函数的类对象"><a href="#拥有仅一个虚函数的类对象" class="headerlink" title="拥有仅一个虚函数的类对象"></a>拥有仅一个虚函数的类对象</h3><p>类实现如下:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base1</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> base1_1;</span><br><span class="line">    <span class="type">int</span> base1_2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">base1_fun1</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>结果如下:</p>
<table>
<thead>
<tr>
<th>sizeof(Base1)</th>
<th>12</th>
</tr>
</thead>
<tbody><tr>
<td>offsetof(Base1, base1_1)</td>
<td>4</td>
</tr>
<tr>
<td>offsetof(Base1, base1_2)</td>
<td>8</td>
</tr>
</tbody></table>
<p>咦? 多了4个字节? 且 base1_1 和 base1_2 的偏移都各自向后多了4个字节!<br>说明类对象的最前面被多加了4个字节的”东东”, what’s it?<br>现在, 我们通过VS2013来瞧瞧类Base1的变量b1的内存布局情况:<br>(由于我没有写构造函数, 所以变量的数据没有根据, 但虚函数是编译器为我们构造的, 数据正确!)<br>(Debug模式下, 未初始化的变量值为 <code>0xCCCCCCCC</code>, 即:<code>-858983460</code>)</p>
<img src="/reproduction-cpp-virtual-function-table/3-1.png" class="" title="img">

<p>看到没? base1_1前面多了一个变量 __vfptr(常说的虚函数表vtable指针), 其类型为void**, 这说明它是一个void*指针(**注意:**不是数组).</p>
<p>再看看[0]元素, 其类型为void*, 其值为 ConsoleApplication2.exe!Base1::base1_fun1(void), 这是什么意思呢? 如果对WinDbg比较熟悉, 那么应该知道这是一种惯用表示手法, 她就是指 Base1::base1_fun1() 函数的地址.</p>
<p>可得, __vfptr的定义伪代码大概如下:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span>*   __fun[<span class="number">1</span>] = &#123; &amp;Base1::base1_fun1 &#125;;</span><br><span class="line"><span class="type">const</span> <span class="type">void</span>**  __vfptr = &amp;__fun[<span class="number">0</span>];</span><br></pre></td></tr></table></figure>

<p>值得注意的是:</p>
<ol>
<li><p>上面只是一种伪代码方式, 语法不一定能通过</p>
</li>
<li><p>该类的对象大小为12个字节, 大小及偏移信息如下:</p>
<table>
<thead>
<tr>
<th>sizeof(Base1)</th>
<th>12</th>
</tr>
</thead>
<tbody><tr>
<td>offsetof(__vfptr)</td>
<td>0</td>
</tr>
<tr>
<td>offsetof(base1_1)</td>
<td>4</td>
</tr>
<tr>
<td>offsetof(base1_2)</td>
<td>8</td>
</tr>
</tbody></table>
</li>
<li><p>大家有没有留意这个__vfptr? 为什么它被定义成一个指向指针数组的指针, 而不是直接定义成一个指针数组呢?</p>
<p>我为什么要提这样一个问题? 因为如果仅是一个指针的情况, 您就无法轻易地修改那个数组里面的内容, 因为她并不属于类对象的一部分.<br>属于类对象的, 仅是一个指向<strong>虚函数表的一个指针__vfptr</strong>而已, 下一节我们将继续讨论这个问题.</p>
</li>
<li><p>注意到__vfptr前面的const修饰. 她修饰的是那个虚函数表, 而不是__vfptr.</p>
</li>
</ol>
<p>现在的对象布局如下:</p>
<img src="/reproduction-cpp-virtual-function-table/3-2.png" class="" title="img">

<p>虚函数指针__vfptr位于所有的成员变量之前定义.</p>
<p>注意到: 我并未在此说明__vfptr的具体指向, 只是说明了现在类对象的布局情况.<br>接下来看一个稍微复杂一点的情况, 我将清楚地描述虚函数表的构成.</p>
</li>
<li><h3 id="拥有多个虚函数的类对象"><a href="#拥有多个虚函数的类对象" class="headerlink" title="拥有多个虚函数的类对象"></a>拥有多个虚函数的类对象</h3><p>和前面一个例子差不多, 只是再加了一个虚函数. 定义如下:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base1</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> base1_1;</span><br><span class="line">    <span class="type">int</span> base1_2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">base1_fun1</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">base1_fun2</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>大小以及偏移信息如下:</p>
<img src="/reproduction-cpp-virtual-function-table/4-1.png" class="" title="img">

<p>有情况!? 多了一个虚函数, 类对象大小却依然是12个字节!</p>
<p>再来看看VS形象的表现:</p>
<img src="/reproduction-cpp-virtual-function-table/4-2.png" class="" title="img">

<p>呀, __vfptr所指向的函数指针数组中出现了第2个元素, 其值为Base1类的第2个虚函数base1_fun2()的函数地址.</p>
<p>现在, 虚函数指针以及虚函数表的伪定义大概如下:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span>* __fun[] = &#123; &amp;Base1::base1_fun1, &amp;Base1::base1_fun2 &#125;;</span><br><span class="line"><span class="type">const</span> <span class="type">void</span>** __vfptr = &amp;__fun[<span class="number">0</span>];</span><br></pre></td></tr></table></figure>

<p>通过上面两张图表, 我们可以得到如下结论:</p>
<ol>
<li>更加肯定前面我们所描述的: __vfptr只是一个指针, 她指向一个函数指针数组(即: 虚函数表)</li>
<li>增加一个虚函数, 只是简单地向该类对应的虚函数表中增加一项而已, 并不会影响到类对象的大小以及布局情况</li>
</ol>
<p>前面已经提到过: __vfptr只是一个指针, 她指向一个数组, 并且: 这个数组没有包含到类定义内部, 那么她们之间是怎样一个关系呢?<br>不妨, 我们再定义一个类的变量b2, 现在再来看看__vfptr的指向:</p>
<img src="/reproduction-cpp-virtual-function-table/4-3.png" class="" title="img">

<p>通过Watch 1窗口我们看到:</p>
<ol>
<li>b1和b2是类的两个变量, 理所当然, 她们的地址是不同的(见 &amp;b1 和 &amp;b2)</li>
<li>虽然b1和b2是类的两个变量, 但是: 她们的__vfptr的指向却是同一个虚函数表</li>
</ol>
<p>由此我们可以总结出:</p>
<p>同一个类的不同实例共用同一份虚函数表, 她们都通过一个所谓的虚函数表指针__vfptr(定义为void**类型)指向该虚函数表.</p>
<p>是时候该展示一下类对象的内存布局情况了:</p>
<img src="/reproduction-cpp-virtual-function-table/4-4.png" class="" title="img">

<p>不出意外, 很清晰明了地展示出来了吧? :-) hoho~~</p>
<p>那么问题就来了! 这个虚函数表保存在哪里呢? 其实, 我们无需过分追究她位于哪里, 重点是:</p>
<ol>
<li>她是编译器在<strong>编译时期</strong>为我们创建好的, 只存在一份</li>
<li>定义类对象时, 编译器自动将类对象的__vfptr指向这个虚函数表</li>
</ol>
</li>
<li><h3 id="单继承且本身不存在虚函数的继承类的内存布局"><a href="#单继承且本身不存在虚函数的继承类的内存布局" class="headerlink" title="单继承且本身不存在虚函数的继承类的内存布局"></a>单继承且本身不存在虚函数的继承类的内存布局</h3><p>前面研究了那么多啦, 终于该到研究继承类了! 先研究单继承!</p>
<p>依然, 简单地定义一个继承类, 如下:</p>
<figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base1</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> base1_1;</span><br><span class="line">    <span class="type">int</span> base1_2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">base1_fun1</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">base1_fun2</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derive1</span> : <span class="keyword">public</span> Base1</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> derive1_1;</span><br><span class="line">    <span class="type">int</span> derive1_2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我们再来看看现在的内存布局(定义为Derive1 d1):</p>
<img src="/reproduction-cpp-virtual-function-table/5-1.png" class="" title="img">

<p>没错! 基类在上边, 继承类的成员在下边依次定义! 展开来看看:</p>
<img src="/reproduction-cpp-virtual-function-table/5-2.png" class="" title="img">

<p>经展开后来看, 前面部分完全就是Base1的东西: 虚函数表指针+成员变量定义.<br>并且, Base1的虚函数表的[0][1]两项还是其本身就拥有的函数: base1_fun1() 和 base1_fun2().</p>
<p>现在类的布局情况应该是下面这样:</p>
<img src="/reproduction-cpp-virtual-function-table/5-3.png" class="" title="img"></li>
<li><h3 id="本身不存在虚函数-不严谨-但存在基类虚函数覆盖的单继承类的内存布局"><a href="#本身不存在虚函数-不严谨-但存在基类虚函数覆盖的单继承类的内存布局" class="headerlink" title="本身不存在虚函数(不严谨)但存在基类虚函数覆盖的单继承类的内存布局"></a>本身不存在虚函数(不严谨)但存在基类虚函数覆盖的单继承类的内存布局</h3><p>标题 <code>本身不存在虚函数</code>的说法有些不严谨, 我的意思是说: 除经过继承而得来的基类虚函数以外, 自身没有再定义其它的虚函数.</p>
<p>Ok, 既然存在基类虚函数覆盖, 那么来看看接下来的代码会产生何种影响:</p>
<figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base1</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> base1_1;</span><br><span class="line">    <span class="type">int</span> base1_2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">base1_fun1</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">base1_fun2</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derive1</span> : <span class="keyword">public</span> Base1</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> derive1_1;</span><br><span class="line">    <span class="type">int</span> derive1_2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 覆盖基类函数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">base1_fun1</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>可以看到, Derive1类 重写了Base1类的base1_fun1()函数, 也就是常说的虚函数覆盖. 现在是怎样布局的呢?</p>
<img src="/reproduction-cpp-virtual-function-table/6-1.png" class="" title="img">

<p>特别注意我高亮的那一行: 原本是Base1::base1_fun1(), 但由于<strong>继承类重写</strong>了基类Base1的此方法, 所以现在变成了Derive1::base1_fun1()!</p>
<p>那么, 无论是通过Derive1的指针还是Base1的指针来调用此方法, 调用的都将是被继承类重写后的那个方法(函数), 多态发生鸟!!!</p>
<p>那么新的布局图:</p>
<img src="/reproduction-cpp-virtual-function-table/6-2.png" class="" title="img"></li>
<li><h3 id="定义了基类没有的虚函数的单继承的类对象布局"><a href="#定义了基类没有的虚函数的单继承的类对象布局" class="headerlink" title="定义了基类没有的虚函数的单继承的类对象布局"></a>定义了基类没有的虚函数的单继承的类对象布局</h3><p>说明一下: 由于前面一种情况只会造成覆盖基类虚函数表的指针, 所以接下来我不再同时讨论虚函数覆盖的情况.</p>
<p>继续贴代码:</p>
<figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base1</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> base1_1;</span><br><span class="line">    <span class="type">int</span> base1_2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">base1_fun1</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">base1_fun2</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derive1</span> : <span class="keyword">public</span> Base1</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> derive1_1;</span><br><span class="line">    <span class="type">int</span> derive1_2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">derive1_fun1</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>和第5类不同的是多了一个自身定义的虚函数. 和第6类不同的是没有基类虚函数的覆盖.</p>
<img src="/reproduction-cpp-virtual-function-table/7-1.png" class="" title="img">

<p>咦, 有没有发现问题? 表面上看来几乎和第5种情况完全一样? 为嘛呢?<br>现在继承类明明定义了自身的虚函数, 但不见了??<br>那么, 来看看类对象的大小, 以及成员偏移情况吧:</p>
<img src="/reproduction-cpp-virtual-function-table/7-2.png" class="" title="img">

<p>居然没有变化!!! 前面12个字节是Base1的, 有没有觉得很奇怪?</p>
<p>好吧, 既然表面上没办法了, 我们就只能从汇编入手了, 来看看调用derive1_fun1()时的代码:</p>
<figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Derive1 d1;</span><br><span class="line">Derive1* pd1 = &amp;d1;</span><br><span class="line">pd1-&gt;<span class="built_in">derive1_fun1</span>();</span><br></pre></td></tr></table></figure>

<p>要注意: 我为什么使用指针的方式调用? 说明一下: 因为如果不使用指针调用, 虚函数调用是不会发生动态绑定的哦! 你若直接 <code>d1.derive1_fun1();</code> , 是不可能会发生动态绑定的, 但如果使用指针: <code>pd1-&gt;derive1_fun1();</code> , 那么 pd1就无从知道她所指向的对象到底是Derive1 还是继承于Derive1的对象, 虽然这里我们并没有对象继承于Derive1, 但是她不得不这样做, 毕竟继承类不管你如何继承, 都不会影响到基类, 对吧?</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">; pd1-&gt;derive1_fun1();</span></span><br><span class="line"><span class="number">00825466</span>  <span class="keyword">mov</span>         <span class="built_in">eax</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> [pd1]  </span><br><span class="line"><span class="number">00825469</span>  <span class="keyword">mov</span>         <span class="built_in">edx</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">eax</span>]  </span><br><span class="line">0082546B  <span class="keyword">mov</span>         <span class="built_in">esi</span>,<span class="built_in">esp</span>  </span><br><span class="line"><span class="number">0082546D</span>  <span class="keyword">mov</span>         <span class="built_in">ecx</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> [pd1]  </span><br><span class="line"><span class="number">00825470</span>  <span class="keyword">mov</span>         <span class="built_in">eax</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">edx</span>+<span class="number">8</span>]  </span><br><span class="line"><span class="number">00825473</span>  <span class="keyword">call</span>        <span class="built_in">eax</span></span><br></pre></td></tr></table></figure>

<p>汇编代码解释:</p>
<p>第2行: 由于pd1是指向d1的指针, 所以执行此句后 eax 就是<strong>d1的地址</strong><br>第3行: 又因为Base1::__vfptr是Base1的第1个成员, 同时也是Derive1的第1个成员, 那么: &amp;__vfptr &#x3D;&#x3D; &amp;d1, clear? 所以当执行完 <code>mov edx, dword ptr[eax]</code> 后, edx就得到了__vfptr的值, 也就是<strong>虚函数表的地址</strong>.<br>第5行: 由于是__thiscall调用, 所以把this保存到ecx中.<br>第6行: 一定要注意到那个 edx+8, 由于edx是虚函数表的地址, 那么 edx+8将是虚函数表的第3个元素, 也就是__vftable[2]!!!<br>第7行: 调用虚函数.</p>
<p>结果:</p>
<ol>
<li>现在我们应该知道内幕了! 继承类Derive1的虚函数表被加在基类的后面! 事实的确就是这样!</li>
<li>由于Base1只知道自己的两个虚函数索引[0][1], 所以就算在后面加上了[2], Base1根本不知情, 不会对她造成任何影响.</li>
<li>如果<strong>基类没有虚函数</strong>呢? 这个问题我们留到第9小节再来讨论!</li>
</ol>
<p>最新的类对象布局表示:</p>
<img src="/reproduction-cpp-virtual-function-table/7-3.png" class="" title="img"></li>
<li><h3 id="多继承且存在虚函数覆盖同时又存在自身定义的虚函数的类对象布局"><a href="#多继承且存在虚函数覆盖同时又存在自身定义的虚函数的类对象布局" class="headerlink" title="多继承且存在虚函数覆盖同时又存在自身定义的虚函数的类对象布局"></a>多继承且存在虚函数覆盖同时又存在自身定义的虚函数的类对象布局</h3><p>真快, 该看看多继承了, 多继承很常见, 特别是接口类中!</p>
<p>依然写点小类玩玩:</p>
<figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base1</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> base1_1;</span><br><span class="line">    <span class="type">int</span> base1_2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">base1_fun1</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">base1_fun2</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base2</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> base2_1;</span><br><span class="line">    <span class="type">int</span> base2_2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">base2_fun1</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">base2_fun2</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derive1</span> : <span class="keyword">public</span> Base1, <span class="keyword">public</span> Base2</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> derive1_1;</span><br><span class="line">    <span class="type">int</span> derive1_2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 基类虚函数覆盖</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">base1_fun1</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">base2_fun2</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自身定义的虚函数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">derive1_fun1</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">derive1_fun2</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>代码变得越来越长啦! 为了代码结构清晰, 我尽量简化定义.</p>
<p>初步了解一下对象大小及偏移信息:</p>
<img src="/reproduction-cpp-virtual-function-table/8-1.png" class="" title="img">

<p>貌似, 若有所思? 不管, 来看看VS再想:</p>
<img src="/reproduction-cpp-virtual-function-table/8-2.png" class="" title="img">

<p>哇, 不摆了! 一丝不挂啊! :-)</p>
<p>结论:</p>
<ol>
<li>按照基类的声明顺序, 基类的成员依次分布在继承中.</li>
<li>注意被我高亮的那两行, 已经发生了虚函数覆盖!</li>
<li>我们自己定义的虚函数呢? 怎么还是看不见?!</li>
</ol>
<p>好吧, 继承反汇编, 这次的调用代码如下:</p>
<figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Derive1 d1;</span><br><span class="line">Derive1* pd1 = &amp;d1;</span><br><span class="line">pd1-&gt;<span class="built_in">derive1_fun2</span>();</span><br></pre></td></tr></table></figure>

<p>反汇编代码如下:</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">; pd1-&gt;derive1_fun2();</span></span><br><span class="line"><span class="number">00995306</span>  <span class="keyword">mov</span>         <span class="built_in">eax</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> [pd1]  </span><br><span class="line"><span class="number">00995309</span>  <span class="keyword">mov</span>         <span class="built_in">edx</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">eax</span>]  </span><br><span class="line">0099530B  <span class="keyword">mov</span>         <span class="built_in">esi</span>,<span class="built_in">esp</span>  </span><br><span class="line"><span class="number">0099530D</span>  <span class="keyword">mov</span>         <span class="built_in">ecx</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> [pd1]  </span><br><span class="line"><span class="number">00995310</span>  <span class="keyword">mov</span>         <span class="built_in">eax</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">edx</span>+<span class="number">0Ch</span>]  </span><br><span class="line"><span class="number">00995313</span>  <span class="keyword">call</span>        <span class="built_in">eax</span></span><br></pre></td></tr></table></figure>

<p>解释下, 其实差不多:</p>
<p>第2行: 取d1的地址<br>第3行: 取Base1::__vfptr的值!!<br>第6行: 0x0C, 也就是第4个元素(下标为[3])</p>
<p>结论:</p>
<p>Derive1的虚函数表依然是保存到第1个拥有虚函数表的那个基类的后面的.</p>
<p>看看现在的类对象布局图:</p>
<p>（注：图中有点错误，右上角应该是 <code>void* __vftable[4]</code>，多谢 shadow3002 的提醒）</p>
<p>（注：图中有点错误，Derive1是存在虚函数覆盖的。源图丢失，请读者注意不要被误导。<a href="#comment-577">多谢 Oyster 的提醒</a>）</p>
<img src="/reproduction-cpp-virtual-function-table/8-3.png" class="" title="img">

<p>如果第1个基类没有虚函数表呢? 进入第9节!</p>
</li>
<li><h3 id="如果第1个直接基类没有虚函数-表"><a href="#如果第1个直接基类没有虚函数-表" class="headerlink" title="如果第1个直接基类没有虚函数(表)"></a>如果第1个直接基类没有虚函数(表)</h3><p>这次的代码应该比上一个要稍微简单一些, 因为把第1个类的虚函数给去掉鸟!</p>
<figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base1</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> base1_1;</span><br><span class="line">    <span class="type">int</span> base1_2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base2</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> base2_1;</span><br><span class="line">    <span class="type">int</span> base2_2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">base2_fun1</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">base2_fun2</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derive1</span> : <span class="keyword">public</span> Base1, <span class="keyword">public</span> Base2</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> derive1_1;</span><br><span class="line">    <span class="type">int</span> derive1_2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自身定义的虚函数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">derive1_fun1</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">derive1_fun2</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>来看看VS的布局:</p>
<img src="/reproduction-cpp-virtual-function-table/9-1.png" class="" title="img">

<p>这次相对前面一次的图来说还要简单啦! Base1已经没有虚函数表了! (真实情况并非完全这样, 请继续往下看!)</p>
<p>现在的大小及偏移情况: 注意: <code>sizeof(Base1) == 8;</code></p>
<img src="/reproduction-cpp-virtual-function-table/9-2.png" class="" title="img">

<p>重点是看虚函数的位置, 进入函数调用(和前一次是一样的):</p>
<figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Derive1 d1;</span><br><span class="line">Derive1* pd1 = &amp;d1;</span><br><span class="line">pd1-&gt;<span class="built_in">derive1_fun2</span>();</span><br></pre></td></tr></table></figure>

<p>反汇编调用代码:</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">; pd1-&gt;derive1_fun2();</span></span><br><span class="line">012E4BA6  <span class="keyword">mov</span>         <span class="built_in">eax</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> [pd1]  </span><br><span class="line">012E4BA9  <span class="keyword">mov</span>         <span class="built_in">edx</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">eax</span>]  </span><br><span class="line">012E4BAB  <span class="keyword">mov</span>         <span class="built_in">esi</span>,<span class="built_in">esp</span>  </span><br><span class="line">012E4BAD  <span class="keyword">mov</span>         <span class="built_in">ecx</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> [pd1]  </span><br><span class="line">012E4BB0  <span class="keyword">mov</span>         <span class="built_in">eax</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">edx</span>+<span class="number">0Ch</span>]  </span><br><span class="line">012E4BB3  <span class="keyword">call</span>        <span class="built_in">eax</span></span><br></pre></td></tr></table></figure>

<p>这段汇编代码和前面一个完全一样!, 那么问题就来了! Base1 已经没有虚函数表了, 为什么还是把b1的第1个元素当作__vfptr呢?<br>不难猜测: 当前的布局已经发生了变化, 有虚函数表的基类放在对象内存前面!? , 不过事实是否属实? 需要仔细斟酌.</p>
<p>我们可以通过对基类成员变量求偏移来观察:</p>
<img src="/reproduction-cpp-virtual-function-table/9-3.png" class="" title="img">

<p>可以看到:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&amp;d1==0x~d4</span><br><span class="line">&amp;d1.Base1::__vfptr==0x~d4</span><br><span class="line">&amp;d1.base2_1==0x~d8</span><br><span class="line">&amp;d1.base2_2==0x~dc</span><br><span class="line">&amp;d1.base1_1==0x~e0</span><br><span class="line">&amp;d1.base1_2==0x~e4</span><br></pre></td></tr></table></figure>

<p>所以不难验证: 我们前面的推断是正确的, 谁有虚函数表, 谁就放在前面!</p>
<p>现在类的布局情况:</p>
<img src="/reproduction-cpp-virtual-function-table/9-4.png" class="" title="img">

<p>那么, 如果两个基类都没有虚函数表呢?</p>
</li>
<li><h3 id="What-if-两个基类都没有虚函数表"><a href="#What-if-两个基类都没有虚函数表" class="headerlink" title="What if 两个基类都没有虚函数表"></a>What if 两个基类都没有虚函数表</h3><p>代码如下:</p>
<figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base1</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> base1_1;</span><br><span class="line">    <span class="type">int</span> base1_2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base2</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> base2_1;</span><br><span class="line">    <span class="type">int</span> base2_2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derive1</span> : <span class="keyword">public</span> Base1, <span class="keyword">public</span> Base2</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> derive1_1;</span><br><span class="line">    <span class="type">int</span> derive1_2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自身定义的虚函数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">derive1_fun1</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">derive1_fun2</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>前面吃了个亏, 现在先来看看VS的基本布局:</p>
<img src="/reproduction-cpp-virtual-function-table/10-1.png" class="" title="img">

<p>可以看到, 现在__vfptr已经独立出来了, 不再属于Base1和Base2!</p>
<p>看看求偏移情况:</p>
<img src="/reproduction-cpp-virtual-function-table/10-2.png" class="" title="img">

<p>Ok, 问题解决! 注意高亮的那两行, <code>&amp;d1==&amp;d1.__vfptr</code>, 说明虚函数始终在最前面!</p>
<p>不用再废话, 相信大家对这种情况已经有底了.</p>
<p>对象布局:</p>
<img src="/reproduction-cpp-virtual-function-table/10-3.png" class="" title="img"></li>
<li><h3 id="如果有三个基类-虚函数表分别是有-没有-有"><a href="#如果有三个基类-虚函数表分别是有-没有-有" class="headerlink" title="如果有三个基类: 虚函数表分别是有, 没有, 有!"></a>如果有三个基类: 虚函数表分别是有, 没有, 有!</h3><p>这种情况其实已经无需再讨论了, 作为一个完结篇….</p>
<p>上代码:</p>
<figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base1</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> base1_1;</span><br><span class="line">    <span class="type">int</span> base1_2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">base1_fun1</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">base1_fun2</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base2</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> base2_1;</span><br><span class="line">    <span class="type">int</span> base2_2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base3</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> base3_1;</span><br><span class="line">    <span class="type">int</span> base3_2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">base3_fun1</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">base3_fun2</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derive1</span> : <span class="keyword">public</span> Base1, <span class="keyword">public</span> Base2, <span class="keyword">public</span> Base3</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> derive1_1;</span><br><span class="line">    <span class="type">int</span> derive1_2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自身定义的虚函数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">derive1_fun1</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">derive1_fun2</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>以下是偏移图：</p>
<img src="/reproduction-cpp-virtual-function-table/11-1.png" class="" title="img">

<p>以下是对象布局图（多谢 <a target="_blank" rel="noopener" href="https://blog.twofei.com/496/#comment-577">@Oyster</a> 的手绘）：</p>
<img src="/reproduction-cpp-virtual-function-table/11-2.jpg" class="" title="img">

<p>只需知道: 谁有虚函数表, 谁就往前靠!</p>
</li>
</ol>
<h2 id="C-中父子对象指针间的转换与函数调用"><a href="#C-中父子对象指针间的转换与函数调用" class="headerlink" title="C++中父子对象指针间的转换与函数调用"></a>C++中父子对象指针间的转换与函数调用</h2><p>讲了那么多布局方面的东东, 终于到了尾声, 好累呀!!!</p>
<p>通过前面的讲解内容, 大家至少应该明白了各类情况下类对象的内存布局了. 如果还不会…..呃….. !@#$%^&amp;*</p>
<p>进入正题~</p>
<p>由于继承完全拥有父类的所有, 包括数据成员与虚函数表, 所以:<strong>把一个继承类强制转换为一个基类</strong>是完全可行的.</p>
<p>如果有一个Derive1的指针, 那么:</p>
<ul>
<li>得到Base1的指针: Base1* pb1 &#x3D; pd1;</li>
<li>得到Base2的指针: Base2* pb2 &#x3D; pd1;</li>
<li>得到Base3的指针: Base3* pb3 &#x3D; pd1;</li>
</ul>
<p>非常值得注意的是:</p>
<p>这是在基类与继承类之间的转换, 这种转换会自动计算偏移! 按照前面的布局方式!<br>也就是说: 在这里极有可能: pb1 !&#x3D; pb2 !&#x3D; pb3 ~~, 不要以为她们都等于 pd1!</p>
<p>至于函数调用, 我想, 不用说大家应该知道了:</p>
<ol>
<li>如果不是虚函数, 直接调用指针对应的基本类的那个函数</li>
<li>如果是虚函数, 则查找虚函数表, 并进行后续的调用. 虚函数表在定义一个时, 编译器就为我们创建好了的. 所有的, 同一个类, 共用同一份虚函数表.</li>
</ol>
<h2 id="用C语言完全模拟C-虚函数表的实现与运作方式"><a href="#用C语言完全模拟C-虚函数表的实现与运作方式" class="headerlink" title="用C语言完全模拟C++虚函数表的实现与运作方式"></a>用C语言完全模拟C++虚函数表的实现与运作方式</h2><p>如果对前面两大节的描述仔细了解了的话, 想用C语言来模拟C++的虚函数以及多态, 想必是轻而易举的事情鸟!</p>
<h3 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h3><p>但是, 话得说在前面, C++的编译器在生成类及对象的时候, 帮助我们完成了很多事件, 比如生成虚函数表!<br>但是, C语言编译器却没有, 因此, 很多事件我们必须手动来完成, 包括但不限于:</p>
<ol>
<li>手动构造父子关系</li>
<li>手动创建虚函数表</li>
<li>手动设置__vfptr并指向虚函数表</li>
<li>手动填充虚函数表</li>
<li>若有虚函数覆盖, 还需手动修改函数指针</li>
<li>若要取得基类指针, 还需手动强制转换</li>
<li>……</li>
</ol>
<p>总之, 要想用C语言来实现, 要写的代码绝对有点复杂.</p>
<h3 id="C-原版调用"><a href="#C-原版调用" class="headerlink" title="C++原版调用"></a>C++原版调用</h3><p>接下来, 我们都将以最后那个, 最繁杂的那个3个基类的实例来讲解, 但作了一些简化与改动:</p>
<ol>
<li>用构造函数初始化成员变量</li>
<li>减少成员变量的个数</li>
<li>减少虚函数的个数</li>
<li>调用函数时产生相关输出</li>
<li>Derive1增加一个基类虚函数覆盖</li>
</ol>
<p>以下是对类的改动, 很少:</p>
<figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base1</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base1</span>() : <span class="built_in">base1_1</span>(<span class="number">11</span>) &#123;&#125;</span><br><span class="line">    <span class="type">int</span> base1_1;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">base1_fun1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Base1::base1_fun1()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base2</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base2</span>() : <span class="built_in">base2_1</span>(<span class="number">21</span>) &#123;&#125;</span><br><span class="line">    <span class="type">int</span> base2_1;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base3</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base3</span>() : <span class="built_in">base3_1</span>(<span class="number">31</span>) &#123;&#125;</span><br><span class="line">    <span class="type">int</span> base3_1;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">base3_fun1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Base3::base3_fun1()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derive1</span> : <span class="keyword">public</span> Base1, <span class="keyword">public</span> Base2, <span class="keyword">public</span> Base3</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Derive1</span>() : <span class="built_in">derive1_1</span>(<span class="number">11</span>) &#123;&#125;</span><br><span class="line">    <span class="type">int</span> derive1_1;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">base3_fun1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Derive1::base3_fun1()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">derive1_fun1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Derive1::derive1_fun1()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>为了看到多态的效果, 我们还需要定义一个函数来看效果:</p>
<figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(Base1* pb1, Base2* pb2, Base3* pb3, Derive1* pd1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Base1::\n&quot;</span></span><br><span class="line">        &lt;&lt; <span class="string">&quot;    pb1-&gt;base1_1 = &quot;</span> &lt;&lt; pb1-&gt;base1_1 &lt;&lt; <span class="string">&quot;\n&quot;</span></span><br><span class="line">        &lt;&lt; <span class="string">&quot;    pb1-&gt;base1_fun1(): &quot;</span>;</span><br><span class="line">    pb1-&gt;<span class="built_in">base1_fun1</span>();</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Base2::\n&quot;</span></span><br><span class="line">        &lt;&lt; <span class="string">&quot;    pb2-&gt;base2_1 = &quot;</span> &lt;&lt; pb2-&gt;base2_1</span><br><span class="line">        &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Base3::\n&quot;</span></span><br><span class="line">        &lt;&lt; <span class="string">&quot;    pb3-&gt;base3_1 = &quot;</span> &lt;&lt; pb3-&gt;base3_1 &lt;&lt; <span class="string">&quot;\n&quot;</span></span><br><span class="line">        &lt;&lt;<span class="string">&quot;    pb3-&gt;base3_fun1(): &quot;</span>;</span><br><span class="line">    pb3-&gt;<span class="built_in">base3_fun1</span>();</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Derive1::\n&quot;</span></span><br><span class="line">        &lt;&lt; <span class="string">&quot;    pd1-&gt;derive1_1 = &quot;</span> &lt;&lt; pd1-&gt;derive1_1&lt;&lt; <span class="string">&quot;\n&quot;</span></span><br><span class="line">        &lt;&lt;<span class="string">&quot;    pd1-&gt;derive1_fun1(): &quot;</span>;</span><br><span class="line">    pd1-&gt;<span class="built_in">derive1_fun1</span>();</span><br><span class="line">    std::cout&lt;&lt; <span class="string">&quot;    pd1-&gt;base3_fun1(): &quot;</span>;</span><br><span class="line">    pd1-&gt;<span class="built_in">base3_fun1</span>();</span><br><span class="line">  </span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用方式如下:</p>
<figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Derive1 d1;</span><br><span class="line"><span class="built_in">foo</span>(&amp;d1, &amp;d1, &amp;d1, &amp;d1);</span><br></pre></td></tr></table></figure>

<p>输出结果:</p>
<img src="/reproduction-cpp-virtual-function-table/c-1.png" class="" title="img">

<p>可以看到输出结果全部正确(当然了! :-), 哈哈~<br>同时注意到 pb3-&gt;base3_fun1() 的多态效果哦!</p>
<h3 id="用C语言来模拟"><a href="#用C语言来模拟" class="headerlink" title="用C语言来模拟"></a>用C语言来模拟</h3><p>必须要把前面的理解了, 才能看懂下面的代码!</p>
<p>为了有别于已经完成的C++的类, 我们分别在类前面加一个大写的C以示区分(平常大家都是习惯在C++写的类前面加C, 今天恰好反过来, 哈哈).</p>
<h5 id="C语言无法实现的部分"><a href="#C语言无法实现的部分" class="headerlink" title="C语言无法实现的部分"></a>C语言无法实现的部分</h5><p>C&#x2F;C++是两个语言, 有些语言特性是C++专有的, 我们无法实现! 不过, 这里我是指调用约定, 我们应该把她排除在外.</p>
<p>对于类的成员函数, C++默认使用__thiscall, 也即this指针通过ecx传递, 这在C语言无法实现, 所以我们必须手动声明调用约定为:</p>
<ol>
<li><code>__stdcall</code>, 就像微软的组件对象模型那样</li>
<li><code>__cdecl</code>, 本身就C语言的调用约定, 当然能使用了.</li>
</ol>
<p>上面那种调用约定, 使用哪一种无关紧要, 反正不能使用 <code>__thiscall</code>就行了.</p>
<p>因为使用了非__thiscall调用约定, 我们就必须手动传入this指针, 通过成员函数的第1个参数!</p>
<h5 id="从最简单的开始-实现-Base2"><a href="#从最简单的开始-实现-Base2" class="headerlink" title="从最简单的开始: 实现 Base2"></a>从最简单的开始: 实现 Base2</h5><p>由于没有虚函数, 仅有成员变量, 这个当然是最好模拟的咯!</p>
<figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">CBase2</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> base2_1;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="有了虚函数表的Base1-但没被覆盖"><a href="#有了虚函数表的Base1-但没被覆盖" class="headerlink" title="有了虚函数表的Base1, 但没被覆盖"></a>有了虚函数表的Base1, 但没被覆盖</h5><p>下面是Base1的定义, 要复杂一点了, 多一个__vfptr:</p>
<figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">CBase1</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void</span>** __vfptr;</span><br><span class="line">    <span class="type">int</span> base1_1;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>因为有虚函数表, 所以还得单独为虚函数表创建一个结构体的哦!<br>但是, 为了更能清楚起见, 我并未定义前面所说的指针数组, 而是用一个包含一个或多个函数指针的结构体来表示!<br>因为数组能保存的是同一类的函数指针, 不太很友好!<br>但他们的效果是完全一样的, 希望读者能够理解明白!</p>
<figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">CBase1_VFTable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">void</span>(__stdcall* base1_fun1)(CBase1* that);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>注意:</strong> base1_fun1 在这里是一个指针变量!<br><strong>注意:</strong> base1_fun1 有一个CBase1的指针, 因为我们不再使用__thiscall, 我们必须手动传入! Got it?</p>
<p>Base1的成员函数base1_fun1()我们也需要自己定义, 而且是定义成全局的:</p>
<figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> __stdcall <span class="title">base1_fun1</span><span class="params">(CBase1* that)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;base1_fun1()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="有虚函数覆盖的Base3"><a href="#有虚函数覆盖的Base3" class="headerlink" title="有虚函数覆盖的Base3"></a>有虚函数覆盖的Base3</h5><p>虚函数覆盖在这里并不能体现出来, 要在构造对象初始化的时候才会体现, 所以: base3其实和Base1是一样的.</p>
<figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">CBase3</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void</span>** __vfptr;</span><br><span class="line">    <span class="type">int</span> base3_1;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">CBase3_VFTable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">void</span>(__stdcall* base3_fun1)(CBase3* that);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Base3的成员函数:</p>
<figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> __stdcall <span class="title">base3_fun1</span><span class="params">(CBase3* that)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;base3_fun1()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="定义继承类CDerive1"><a href="#定义继承类CDerive1" class="headerlink" title="定义继承类CDerive1"></a>定义继承类CDerive1</h5><p>相对前面几个类来说, 这个类要显得稍微复杂一些了, 因为包含了前面几个类的内容:</p>
<figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">CDerive1</span></span><br><span class="line">&#123;</span><br><span class="line">    CBase1 base1;</span><br><span class="line">    CBase3 base3;</span><br><span class="line">    CBase2 base2;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> derive1_1;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>特别注意: CBase123的顺序不能错!</p>
<p>另外: 由于Derive1本身还有虚函数表, 而且所以项是加到第一个虚函数表(CBase1)的后面的, 所以此时的CBase1::__vfptr不应该单单指向CBase1_VFTable, 而应该指向下面这个包含Derive1类虚函数表的结构体才行:</p>
<figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">CBase1_CDerive1_VFTable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">void</span> (__stdcall* base1_fun1)(CBase1* that);</span><br><span class="line">    <span class="built_in">void</span>(__stdcall* derive1_fun1)(CDerive1* that);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>因为CDerive1覆盖了CBase3的base3_fun1()函数, 所以不能直接用Base3的那个表:</p>
<figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">CBase3_CDerive1_VFTable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">void</span>(__stdcall* base3_fun1)(CDerive1* that);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Derive1覆盖Base3::base3_fun1()的函数以及自身定义的derive1_fun1()函数:</p>
<figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> __stdcall <span class="title">base3_derive1_fun1</span><span class="params">(CDerive1* that)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;base3_derive1_fun1()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> __stdcall <span class="title">derive1_fun1</span><span class="params">(CDerive1* that)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;derive1_fun1()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="构造各类的全局虚函数表"><a href="#构造各类的全局虚函数表" class="headerlink" title="构造各类的全局虚函数表"></a>构造各类的全局虚函数表</h5><p>由于没有了编译器的帮忙, 在定义一个类对象时, 所有的初始化工作都只能由我们自己来完成了!</p>
<p>首先构造全局的, 被同一个类共同使用的虚函数表!</p>
<figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CBase1 的虚函数表</span></span><br><span class="line">CBase1_VFTable __vftable_base1;</span><br><span class="line">__vftable_base1.base1_fun1 = base1_fun1;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CBase3 的虚函数表</span></span><br><span class="line">CBase3_VFTable __vftable_base3;</span><br><span class="line">__vftable_base3.base3_fun1 = base3_fun1;</span><br></pre></td></tr></table></figure>

<p>然后构造CDerive1和CBase1共同使用的虚函数表:</p>
<figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CDerive1 和 CBase1 共用的虚函数表</span></span><br><span class="line">CBase1_CDerive1_VFTable __vftable_base1_derive1;</span><br><span class="line">__vftable_base1_derive1.base1_fun1 = base1_fun1;</span><br><span class="line">__vftable_base1_derive1.derive1_fun1 = derive1_fun1;</span><br></pre></td></tr></table></figure>

<p>再构造CDerive1覆盖CBase3后的虚函数表: 注意: 数覆盖会替换原来的函数指针</p>
<figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CBase3_CDerive1_VFTable __vftable_base3_derive1;</span><br><span class="line">__vftable_base3_derive1.base3_fun1 = base3_derive1_fun1;</span><br></pre></td></tr></table></figure>

<h5 id="开始-从CDerive1构造一个完整的Derive1类"><a href="#开始-从CDerive1构造一个完整的Derive1类" class="headerlink" title="开始! 从CDerive1构造一个完整的Derive1类"></a>开始! 从CDerive1构造一个完整的Derive1类</h5><p>先初始化成员变量与__vfptr的指向: 注意不是指错了!</p>
<figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CDerive1 d1;</span><br><span class="line">d1.derive1 = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">d1.base1.base1_1 = <span class="number">11</span>;</span><br><span class="line">d1.base1.__vfptr = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">void</span>**&gt;(&amp;__vftable_base1_derive1);</span><br><span class="line">  </span><br><span class="line">d1.base2.base2_1 = <span class="number">21</span>;</span><br><span class="line"></span><br><span class="line">d1.base3.base3_1 = <span class="number">31</span>;</span><br><span class="line">d1.base3.__vfptr = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">void</span>**&gt;(&amp;__vftable_base3_derive1);</span><br></pre></td></tr></table></figure>

<p>由于目前的CDerive1是我们手动构造的, 不存在真正语法上的继承关系, 如要得到各基类指针, 我们就不能直接来取, 必须手动根据偏移计算:</p>
<figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* p = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span>*&gt;(&amp;d1);</span><br><span class="line">Base1* pb1 = <span class="built_in">reinterpret_cast</span>&lt;Base1*&gt;(p + <span class="number">0</span>);</span><br><span class="line">Base2* pb2 = <span class="built_in">reinterpret_cast</span>&lt;Base2*&gt;(p + <span class="built_in">sizeof</span>(CBase1) + <span class="built_in">sizeof</span>(CBase3));</span><br><span class="line">Base3* pb3 = <span class="built_in">reinterpret_cast</span>&lt;Base3*&gt;(p + <span class="built_in">sizeof</span>(CBase1));</span><br><span class="line">Derive1* pd1 = <span class="built_in">reinterpret_cast</span>&lt;Derive1*&gt;(p);</span><br></pre></td></tr></table></figure>

<p>真正调用:</p>
<figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">foo</span>(pb1, pb2, pb3, pd1);</span><br></pre></td></tr></table></figure>

<p>调用结果:</p>
<img src="/reproduction-cpp-virtual-function-table/last.png" class="" title="img">

<p><strong>结果相当正确!!!</strong></p>
<h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2><p>我以为我把源代码搞丢了，结果过了一年多发现其实并没有。— 2015-12-24（每个圣诞我都在写代码）</p>
<p>有两个，忘了区别了：<a target="_blank" rel="noopener" href="https://blog.twofei.com/496/Source1.cpp">Source1.cpp</a>, <a target="_blank" rel="noopener" href="https://blog.twofei.com/496/Source2.cpp">Source2.cpp</a>.</p>
<p>如果文章有帮助到你，请我喝杯冰可乐吧～</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/c/" rel="tag"># c++</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/func-without-return-type/" rel="prev" title="C++：未规定返回值类型的函数的返回值类型是什么？">
      <i class="fa fa-chevron-left"></i> C++：未规定返回值类型的函数的返回值类型是什么？
    </a></div>
      <div class="post-nav-item">
    <a href="/squares-of-a-sorted-array/" rel="next" title="977.有序数组的平方">
      977.有序数组的平方 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%89%8D%E8%A8%80"><span class="nav-text">前言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80"><span class="nav-text">C++对象的内存布局</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%AA%E6%9C%89%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98%E7%9A%84%E5%AF%B9%E8%B1%A1"><span class="nav-text">只有数据成员的对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B2%A1%E6%9C%89%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%E5%AF%B9%E8%B1%A1"><span class="nav-text">没有虚函数的对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8B%A5%E6%9C%89%E4%BB%85%E4%B8%80%E4%B8%AA%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%E7%B1%BB%E5%AF%B9%E8%B1%A1"><span class="nav-text">拥有仅一个虚函数的类对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8B%A5%E6%9C%89%E5%A4%9A%E4%B8%AA%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%E7%B1%BB%E5%AF%B9%E8%B1%A1"><span class="nav-text">拥有多个虚函数的类对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%95%E7%BB%A7%E6%89%BF%E4%B8%94%E6%9C%AC%E8%BA%AB%E4%B8%8D%E5%AD%98%E5%9C%A8%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%E7%BB%A7%E6%89%BF%E7%B1%BB%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80"><span class="nav-text">单继承且本身不存在虚函数的继承类的内存布局</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%AC%E8%BA%AB%E4%B8%8D%E5%AD%98%E5%9C%A8%E8%99%9A%E5%87%BD%E6%95%B0-%E4%B8%8D%E4%B8%A5%E8%B0%A8-%E4%BD%86%E5%AD%98%E5%9C%A8%E5%9F%BA%E7%B1%BB%E8%99%9A%E5%87%BD%E6%95%B0%E8%A6%86%E7%9B%96%E7%9A%84%E5%8D%95%E7%BB%A7%E6%89%BF%E7%B1%BB%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80"><span class="nav-text">本身不存在虚函数(不严谨)但存在基类虚函数覆盖的单继承类的内存布局</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89%E4%BA%86%E5%9F%BA%E7%B1%BB%E6%B2%A1%E6%9C%89%E7%9A%84%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%E5%8D%95%E7%BB%A7%E6%89%BF%E7%9A%84%E7%B1%BB%E5%AF%B9%E8%B1%A1%E5%B8%83%E5%B1%80"><span class="nav-text">定义了基类没有的虚函数的单继承的类对象布局</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E7%BB%A7%E6%89%BF%E4%B8%94%E5%AD%98%E5%9C%A8%E8%99%9A%E5%87%BD%E6%95%B0%E8%A6%86%E7%9B%96%E5%90%8C%E6%97%B6%E5%8F%88%E5%AD%98%E5%9C%A8%E8%87%AA%E8%BA%AB%E5%AE%9A%E4%B9%89%E7%9A%84%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%E7%B1%BB%E5%AF%B9%E8%B1%A1%E5%B8%83%E5%B1%80"><span class="nav-text">多继承且存在虚函数覆盖同时又存在自身定义的虚函数的类对象布局</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E6%9E%9C%E7%AC%AC1%E4%B8%AA%E7%9B%B4%E6%8E%A5%E5%9F%BA%E7%B1%BB%E6%B2%A1%E6%9C%89%E8%99%9A%E5%87%BD%E6%95%B0-%E8%A1%A8"><span class="nav-text">如果第1个直接基类没有虚函数(表)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#What-if-%E4%B8%A4%E4%B8%AA%E5%9F%BA%E7%B1%BB%E9%83%BD%E6%B2%A1%E6%9C%89%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8"><span class="nav-text">What if 两个基类都没有虚函数表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E6%9E%9C%E6%9C%89%E4%B8%89%E4%B8%AA%E5%9F%BA%E7%B1%BB-%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8%E5%88%86%E5%88%AB%E6%98%AF%E6%9C%89-%E6%B2%A1%E6%9C%89-%E6%9C%89"><span class="nav-text">如果有三个基类: 虚函数表分别是有, 没有, 有!</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C-%E4%B8%AD%E7%88%B6%E5%AD%90%E5%AF%B9%E8%B1%A1%E6%8C%87%E9%92%88%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2%E4%B8%8E%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8"><span class="nav-text">C++中父子对象指针间的转换与函数调用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%94%A8C%E8%AF%AD%E8%A8%80%E5%AE%8C%E5%85%A8%E6%A8%A1%E6%8B%9FC-%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8%E7%9A%84%E5%AE%9E%E7%8E%B0%E4%B8%8E%E8%BF%90%E4%BD%9C%E6%96%B9%E5%BC%8F"><span class="nav-text">用C语言完全模拟C++虚函数表的实现与运作方式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%89%8D%E6%8F%90"><span class="nav-text">前提</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#C-%E5%8E%9F%E7%89%88%E8%B0%83%E7%94%A8"><span class="nav-text">C++原版调用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%A8C%E8%AF%AD%E8%A8%80%E6%9D%A5%E6%A8%A1%E6%8B%9F"><span class="nav-text">用C语言来模拟</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#C%E8%AF%AD%E8%A8%80%E6%97%A0%E6%B3%95%E5%AE%9E%E7%8E%B0%E7%9A%84%E9%83%A8%E5%88%86"><span class="nav-text">C语言无法实现的部分</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BB%8E%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84%E5%BC%80%E5%A7%8B-%E5%AE%9E%E7%8E%B0-Base2"><span class="nav-text">从最简单的开始: 实现 Base2</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9C%89%E4%BA%86%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8%E7%9A%84Base1-%E4%BD%86%E6%B2%A1%E8%A2%AB%E8%A6%86%E7%9B%96"><span class="nav-text">有了虚函数表的Base1, 但没被覆盖</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9C%89%E8%99%9A%E5%87%BD%E6%95%B0%E8%A6%86%E7%9B%96%E7%9A%84Base3"><span class="nav-text">有虚函数覆盖的Base3</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89%E7%BB%A7%E6%89%BF%E7%B1%BBCDerive1"><span class="nav-text">定义继承类CDerive1</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E5%90%84%E7%B1%BB%E7%9A%84%E5%85%A8%E5%B1%80%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8"><span class="nav-text">构造各类的全局虚函数表</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BC%80%E5%A7%8B-%E4%BB%8ECDerive1%E6%9E%84%E9%80%A0%E4%B8%80%E4%B8%AA%E5%AE%8C%E6%95%B4%E7%9A%84Derive1%E7%B1%BB"><span class="nav-text">开始! 从CDerive1构造一个完整的Derive1类</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%BA%90%E4%BB%A3%E7%A0%81"><span class="nav-text">源代码</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="zkkKillua"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">zkkKillua</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">169</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">23</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">zkkKillua</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>

<script src="/js/utils.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
