<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>hexoer：批量修改已有的markdown为hexo格式</title>
    <url>/hexoer/</url>
    <content><![CDATA[<p><a href="https://github.com/zkkkillua/hexoer-markdown2hexo">项目地址</a>  </p>
<p>可以给已有的markdown文章批量添加hexo头部信息，且遵从hexo scaffolds的模板格式。  </p>
<h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><ol>
<li>在hexo博客的根目录下创建一个空的文件夹（推荐使用英文名称）。</li>
<li>将”hexoer.py”移动到新创建的文件夹中。</li>
<li>复制所有待修改的markdown文件到新创建的文件夹中。</li>
<li><code>python hexoer.py</code> 并等待完成。</li>
</ol>
]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>132. 分割回文串 II</title>
    <url>/palindrome-partitioning-ii/</url>
    <content><![CDATA[<h2 id="1-dp"><a href="#1-dp" class="headerlink" title="1. dp"></a>1. dp</h2><p>设<code>dp[i]</code>是以<code>s[i]</code>为结尾的子串的最少分割次数，则<br><code>dp[i] = min(dp[j-1]+1)</code>，<code>j</code>是<code>i</code>左侧的位置，<code>s[j~i]</code>是<code>s[0~i]</code>最后一个回文串。<br>从后遍历所有的回文串，找到分割最短的。<br>使用预处理之后，以<code>O(1)</code>的时间判断<code>s[i][j]</code>的回文性。<br>时间<code>O(n^2)</code>，空间<code>O(n^2)</code>。  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minCut</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; <span class="title">palindromic</span><span class="params">(n, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(n))</span></span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n, INT_MAX)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j - i &lt; <span class="number">2</span>)</span><br><span class="line">                    palindromic[i][j] = s[i] == s[j];</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    palindromic[i][j] = palindromic[i + <span class="number">1</span>][j - <span class="number">1</span>] &amp;&amp; s[i] == s[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (palindromic[<span class="number">0</span>][i]) &#123;</span><br><span class="line">                dp[i] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt; <span class="number">0</span>; j--) &#123;</span><br><span class="line">                <span class="keyword">if</span> (palindromic[j][i])</span><br><span class="line">                    dp[i] = min(dp[i], dp[j - <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>131. 分割回文串</title>
    <url>/palindrome-partitioning/</url>
    <content><![CDATA[<h2 id="1-回溯"><a href="#1-回溯" class="headerlink" title="1. 回溯"></a>1. 回溯</h2><p>类似“全排列”，对于每个子答案：  </p>
<ol>
<li>从规定的起点向后遍历所有的回文串  </li>
<li>对于遍历到的每个回文串，添加到子答案数组中，然后起点向后移动，继续调用dfs  </li>
<li>当返回时，弹出当前添加到子答案数组中的回文串，回到2，即添加下一个可能的答案  </li>
</ol>
<p>时间复杂度<code>O(n * 2^n)</code>；这里n为输入字符串的长度，每一个位置可拆分，也可不拆分，尝试所有拆分的时间复杂度为<code>O(2^n</code>，判断每一个子串是否是回文子串，时间复杂度为<code>O(n)</code><br>当然也可以用<code>O(n^2)</code>的时间预处理计算出每一段子串s[i][j]是否回文，则之后可以以<code>O(1)</code>的时间获取，不过空间要增加到<code>O(n^2)</code><br>空间复杂度：<code>O(n)</code>，递归调用栈的深度  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; <span class="title">partition</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; subAns;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; ans;</span><br><span class="line">        dfs(s, subAns, ans, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindromic</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">bool</span> res = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span> (end &gt; start) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[start] != s[end]) &#123;</span><br><span class="line">                res = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            start++;</span><br><span class="line">            end--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; subAns, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt;&amp; ans, <span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">if</span> (start == <span class="number">0</span>)</span><br><span class="line">            subAns.clear();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (start == n) &#123;</span><br><span class="line">            ans.push_back(subAns);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isPalindromic(s, start, i)) &#123;</span><br><span class="line">                subAns.push_back(s.substr(start, i - start + <span class="number">1</span>));</span><br><span class="line">                dfs(s, subAns, ans, i + <span class="number">1</span>);</span><br><span class="line">                subAns.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>191. 位1的个数</title>
    <url>/number-of-1-bits/</url>
    <content><![CDATA[<h2 id="1-位运算"><a href="#1-位运算" class="headerlink" title="1. 位运算"></a>1. 位运算</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">uint32_t</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">            sum += n &amp; <span class="number">1</span>;</span><br><span class="line">            n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2-不修改n"><a href="#2-不修改n" class="headerlink" title="2. 不修改n"></a>2. 不修改n</h2><p>方法1会修改n，且由于右移如果是负数，最高位补的是1，故不能写<code>while(n)</code><br>方法2使用一个辅助变量，不是右移n，而是左移辅助变量  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">uint32_t</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">uint32_t</span> f = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (f) &#123;</span><br><span class="line">            <span class="keyword">if</span> (n &amp; f)</span><br><span class="line">                sum++;</span><br><span class="line">            f &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="3-n-amp-n-1"><a href="#3-n-amp-n-1" class="headerlink" title="3. n &amp; (n - 1)"></a>3. <code>n &amp; (n - 1)</code></h2><p>上述两个方法的复杂度都是<code>O(32)</code>，需要遍历全部的32位。<br>考虑<code>n-1</code>，相比<code>n</code>，<code>n</code>中的最后一个1变成了0，右侧的0全部变成了1。<br>因此<code>n &amp; (n - 1)</code>相当于把<code>n</code>最右侧的1去掉了，不论n是正还是负。<br>利用这个性质，可以在<code>O(m)</code>的时间内算出二进制中1的个数，m为二进制中1的个数，优于<code>O(32)</code>。  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">uint32_t</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n) &#123;</span><br><span class="line">            n = n &amp; (n - <span class="number">1</span>);</span><br><span class="line">            sum++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>503. 下一个更大元素 II</title>
    <url>/next-greater-element-ii/</url>
    <content><![CDATA[<h2 id="1-单调栈"><a href="#1-单调栈" class="headerlink" title="1. 单调栈"></a>1. 单调栈</h2><ul>
<li>使用单调递减栈  </li>
<li>数组中的最大值的“下一个更大元素”不存在，是-1  </li>
<li>获得所有元素的“下一个最大元素”最多需要2次遍历  </li>
<li>数组最大值一共有x个，当数组的最后一个元素是最大值时结束；否则当单调栈中只有x+1个元素且栈顶元素是最大值时代表栈中全是最大值，结束  </li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">nextGreaterElements</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(n, <span class="number">-1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> maxValue = nums[<span class="number">0</span>], maxValueFreq = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; maxValue)</span><br><span class="line">                maxValue = nums[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == maxValue)</span><br><span class="line">                maxValueFreq++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!st.empty() &amp;&amp; nums[i] &gt; nums[st.top()]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (res[st.top()] == <span class="number">-1</span>)</span><br><span class="line">                    res[st.top()] = nums[i];</span><br><span class="line">                st.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            st.push(i);</span><br><span class="line">            <span class="keyword">if</span> (i == n - <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] == maxValue)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    i = <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (st.size() == maxValueFreq + <span class="number">1</span> &amp;&amp; nums[st.top()] == maxValue)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>单调栈</tag>
      </tags>
  </entry>
  <entry>
    <title>496. 下一个更大元素 I</title>
    <url>/next-greater-element-i/</url>
    <content><![CDATA[<h2 id="1-单调栈-hash表"><a href="#1-单调栈-hash表" class="headerlink" title="1. 单调栈+hash表"></a>1. 单调栈+hash表</h2><p>使用一个单调递减栈遍历<code>nums2</code>，当元素比栈顶小时入栈；当比栈顶大时代表该元素是栈顶及随后一部分比该元素小的元素的“下一个更大元素”，故弹出较小的元素，将该元素作为他们的“下一个更大元素”，将该元素入栈。<br>这样求得的是所有元素的“下一个更大元素”，需要hash表记录一下，最后只取<code>nums1</code>中对应的。<br>时间<code>O(m + n)</code>，空间<code>O(m + n)</code>。  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">nextGreaterElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n1 = nums1.size(), n2 = nums2.size();</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; nextGreater;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n2; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!st.empty() &amp;&amp; nums2[i] &gt; st.top()) &#123;</span><br><span class="line">                nextGreater[st.top()] = nums2[i];</span><br><span class="line">                st.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            st.push(nums2[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!st.empty()) &#123;</span><br><span class="line">            nextGreater[st.top()] = <span class="number">-1</span>;</span><br><span class="line">            st.pop();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n1; i++)</span><br><span class="line">            res.push_back(nextGreater[nums1[i]]);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>单调栈</tag>
      </tags>
  </entry>
  <entry>
    <title>232. 用栈实现队列</title>
    <url>/implement-queue-using-stacks/</url>
    <content><![CDATA[<h2 id="1-来回倒"><a href="#1-来回倒" class="headerlink" title="1. 来回倒"></a>1. 来回倒</h2><p>使用两个栈，一个作为输入栈，一个作为输出栈。<br><code>push</code>: 添加到输入栈中<br><code>pop</code>: 将输入栈的元素弹出并添加到输出栈，实现逆序，弹出首元素后，再将剩余元素弹回输入栈<br><code>peek</code>: 同pop<br>这种方法比较繁琐，pop和peek操作都是<code>O(n)</code>的。  </p>
<h2 id="2-不来回倒"><a href="#2-不来回倒" class="headerlink" title="2. 不来回倒"></a>2. 不来回倒</h2><p>使用两个栈，一个作为输入栈，一个作为输出栈。<br>几乎同方法1，但是当元素被弹到输出栈之后，不再弹回到输入栈。<br>因为输出栈本身就是“队列”的前部分，当输出栈为空时，再将输入栈弹到输出栈，得到的又是队列接下来的一部分。<br>这样可以将pop和peek的操作降低到均摊<code>O(1)</code>。  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    MyQueue() &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Push element x to the back of queue. */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        inStack.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Removes the element from in front of queue and returns that element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (outStack.empty())</span><br><span class="line">            move();</span><br><span class="line">        <span class="keyword">int</span> val = outStack.top();</span><br><span class="line">        outStack.pop();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get the front element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (outStack.empty())</span><br><span class="line">            move();</span><br><span class="line">        <span class="keyword">return</span> outStack.top();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns whether the queue is empty. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> inStack.empty() &amp;&amp; outStack.empty();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; inStack, outStack;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">move</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!inStack.empty()) &#123;</span><br><span class="line">            outStack.push(inStack.top());</span><br><span class="line">            inStack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyQueue* obj = new MyQueue();</span></span><br><span class="line"><span class="comment"> * obj-&gt;push(x);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj-&gt;pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj-&gt;peek();</span></span><br><span class="line"><span class="comment"> * bool param_4 = obj-&gt;empty();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h2 id="3-225-用队列实现栈"><a href="#3-225-用队列实现栈" class="headerlink" title="3. 225.用队列实现栈"></a>3. 225.用队列实现栈</h2><p>“用队列实现栈”和“用栈实现队列”是不同的。<br>因为两个栈可以通过先入后出倒倒队列的顺序，而两个队列都是先入先出，不管怎么倒都是同样的顺序。  </p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>354. 俄罗斯套娃信封问题</title>
    <url>/russian-doll-envelopes/</url>
    <content><![CDATA[<p><strong>参考<a href="https://zkkkillua.github.io/longest-increasing-subsequence/">最长递增子序列</a></strong>  </p>
<h2 id="1-dp"><a href="#1-dp" class="headerlink" title="1. dp"></a>1. dp</h2><p>首先将信封从小到大排列，之后设置动态规划数组，<code>dp[i]</code>代表以<code>envelopes[i]</code>为结尾的信封序列最长的长度。<br>则每次<code>dp[i]</code>都由左侧比它小的信封中最长的长度+1得到。<br>时间<code>O(n^2)</code>，空间<code>O(n)</code>。  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxEnvelopes</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; envelopes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = envelopes.size();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        sort(envelopes.begin(), envelopes.end());</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">lens</span><span class="params">(n, <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> maxLength = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> maxBefore = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">                <span class="keyword">if</span> (envelopes[j][<span class="number">0</span>] &lt; envelopes[i][<span class="number">0</span>] &amp;&amp; envelopes[j][<span class="number">1</span>] &lt; envelopes[i][<span class="number">1</span>] &amp;&amp; lens[j] &gt; maxBefore) &#123;</span><br><span class="line">                    maxBefore = lens[j];</span><br><span class="line">                    <span class="keyword">if</span> (lens[j] == maxLength)</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            lens[i] += maxBefore;</span><br><span class="line">            maxLength = max(maxLength, lens[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> maxLength;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2-dp-二分"><a href="#2-dp-二分" class="headerlink" title="2. dp+二分"></a>2. dp+二分</h2><p>将信封按照第一维递增，第一维相等时第二维递减排序，可以转换为只考虑第二维。<br>因为第一维必是递增的，第一维相等时由于第二维递减，故不会在递增过程中重复取第一维相同的元素。  </p>
<p>考虑修改方法1中<code>dp[i]</code>的定义为长度为<code>i</code>的递增子序列的最小的结尾元素。<br>假设当前长度为<code>len</code>，则当遇到比<code>dp[len]</code>更大的元素时，<code>dp[++len] = val</code>；当遇到更小的元素时，则到其左侧找到第一个比<code>val</code>大的<code>dp[i]</code>，修改为<code>val</code>，代表长度为<code>i</code>的递增子序列如今可以有更小的结尾元素了，从而可以使得之后更长的递增序列也可能跟在<code>val</code>之后，用更小的值实现相同的递增长度。<br>查找第一个比<code>val</code>大的<code>dp[i]</code>可以使用二分，因为根据定义，<code>dp</code>数组必是单调递增的，同时也代表了<code>dp[i-1]</code>的序列加上<code>val</code>之后可以得到<code>dp[i]</code>的序列。<br>时间<code>O(nlogn)</code>，空间<code>O(n)</code>。  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">bool</span> res = a[<span class="number">0</span>] &lt; b[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span> (a[<span class="number">0</span>] == b[<span class="number">0</span>])</span><br><span class="line">            res = a[<span class="number">1</span>] &gt; b[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxEnvelopes</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; envelopes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = envelopes.size();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        sort(envelopes.begin(), envelopes.end(), cmp);</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">tail</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> maxLength = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (maxLength == <span class="number">0</span> || envelopes[i][<span class="number">1</span>] &gt; tail[maxLength])</span><br><span class="line">                tail[++maxLength] = envelopes[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> left = <span class="number">1</span>, right = maxLength, mid = (right - left) / <span class="number">2</span> + left;</span><br><span class="line">                <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (tail[mid] &gt;= envelopes[i][<span class="number">1</span>])</span><br><span class="line">                        right = mid;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        left = mid + <span class="number">1</span>;</span><br><span class="line">                    mid = (right - left) / <span class="number">2</span> + left;</span><br><span class="line">                &#125;</span><br><span class="line">                tail[mid] = envelopes[i][<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> maxLength;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title>338. 比特位计数</title>
    <url>/counting-bits/</url>
    <content><![CDATA[<h2 id="1-分区间动态规划"><a href="#1-分区间动态规划" class="headerlink" title="1. 分区间动态规划"></a>1. 分区间动态规划</h2><p>通过观察一段连续数字的二进制可以发现，<code>[2^i, 2^(i+1))</code>部分实际是在之前的二进制数字前面加一位1.<br><img src="dp1.jpg" style="zoom:30%" />  </p>
<p>所以可以根据<code>2^i</code>分成多部分，根据已有的+1得到新的。<br>时间<code>O(n)</code>，空间<code>O(1)</code>。  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">countBits</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(<span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; ; k++) &#123;</span><br><span class="line">            <span class="keyword">int</span> sz = <span class="built_in">pow</span>(<span class="number">2</span>, k);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (sz + i &gt; num)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                res.push_back(<span class="number">1</span> + res[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (res.size() == num + <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2-奇偶动态规划"><a href="#2-奇偶动态规划" class="headerlink" title="2. 奇偶动态规划"></a>2. 奇偶动态规划</h2><p>已有的数据在+1之后，二进制中1的位数可能发生改变。<br>但仔细考虑奇偶性，如果是奇数，则其中1的个数是比他小的偶数中1的个数+1；如果是偶数，则其中1的个数与该偶数除以二得到的数据中1的个数相等，因为相当于右移了1位0.<br>时间<code>O(n)</code>，空间<code>O(1)</code>。  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">countBits</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(<span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= num; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">                res.push_back(res[i - <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                res.push_back(res[i &gt;&gt; <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>1438. 绝对差不超过限制的最长连续子数组</title>
    <url>/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/</url>
    <content><![CDATA[<h2 id="1-朴素"><a href="#1-朴素" class="headerlink" title="1. 朴素"></a>1. 朴素</h2><p>滑动窗口，记录窗口内部的最大值和最小值。<br>但是每次移动窗口之后，如果最大值或者最小值被移除了，则需要重新遍历窗口内部的元素获取。<br>时间<code>O(n^2)</code>，空间<code>O(1)</code>。  </p>
<h2 id="2-堆"><a href="#2-堆" class="headerlink" title="2. 堆"></a>2. 堆</h2><p>使用大根堆和小根堆保存当前窗口内部的数据，从而能够直接获得最大值和最小值。<br>不过问题在于，如果移动窗口移除的是非最大值或最小值，则堆是无法直接删除非堆顶的元素的，需要使用hash表记录，每次删除时对照hash表，延迟删除。<br>时间<code>O(nlogn)</code>，空间<code>O(n)</code>。  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestSubarray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> limit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">priority_queue</span>&lt;<span class="keyword">int</span>&gt; bigHeap;</span><br><span class="line">        <span class="built_in">priority_queue</span>&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt;&gt; smallHeap;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; bigDel, smallDel;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (right &lt; n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (bigHeap.empty() || (!bigHeap.empty() &amp;&amp; bigHeap.top() - nums[right] &lt;= limit &amp;&amp; nums[right] - smallHeap.top() &lt;= limit)) &#123;</span><br><span class="line">                bigHeap.push(nums[right]);</span><br><span class="line">                smallHeap.push(nums[right]);</span><br><span class="line">                right++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res = max(res, right - left);</span><br><span class="line">                bigDel[nums[left]]++;</span><br><span class="line">                smallDel[nums[left]]++;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (!bigHeap.empty() &amp;&amp; bigDel[bigHeap.top()] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                bigDel[bigHeap.top()]--;</span><br><span class="line">                bigHeap.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (!smallHeap.empty() &amp;&amp; smallDel[smallHeap.top()] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                smallDel[smallHeap.top()]--;</span><br><span class="line">                smallHeap.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res = max(res, right - left);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="3-单调队列"><a href="#3-单调队列" class="headerlink" title="3. 单调队列"></a>3. 单调队列</h2><p>对滑动窗口而言，堆，即优先队列，可以获取最大值和最小值，但是不便于维护。因为当窗口滑过，非堆顶的元素无法及时删除，还需要额外使用数组记录延迟删除。<br>动态维护滑动窗口内部的最值更方便的手段是使用单调队列/栈。  </p>
<p>维护窗口内的最小值，可以使用单调递增队列；维护窗口内的最大值，可以使用单调递减队列。<br>此处使用双端队列作为单调队列，因为右窗口右移添加和移除元素是在队尾，左窗口右移移除元素是在队首，所以需要双端队列。<br>时间<code>O(n)</code>，空间<code>O(n)</code>。  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestSubarray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> limit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>, res = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; greaterQ, smallerQ;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (right &lt; n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (greaterQ.empty() || (!greaterQ.empty() &amp;&amp; nums[right] - greaterQ.front() &lt;= limit &amp;&amp; smallerQ.front() - nums[right] &lt;= limit)) &#123;</span><br><span class="line">                <span class="keyword">while</span> (!greaterQ.empty() &amp;&amp; nums[right] &lt; greaterQ.back())</span><br><span class="line">                    greaterQ.pop_back();</span><br><span class="line">                greaterQ.push_back(nums[right]);</span><br><span class="line">                <span class="keyword">while</span> (!smallerQ.empty() &amp;&amp; nums[right] &gt; smallerQ.back())</span><br><span class="line">                    smallerQ.pop_back();</span><br><span class="line">                smallerQ.push_back(nums[right]);</span><br><span class="line">                right++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res = max(res, right - left);</span><br><span class="line">                <span class="keyword">if</span> (nums[left] == greaterQ.front())</span><br><span class="line">                    greaterQ.pop_front();</span><br><span class="line">                <span class="keyword">if</span> (nums[left] == smallerQ.front())</span><br><span class="line">                    smallerQ.pop_front();</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res = max(res, right - left);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>滑动窗口</tag>
        <tag>堆</tag>
        <tag>单调队列</tag>
      </tags>
  </entry>
  <entry>
    <title>697. 数组的度</title>
    <url>/degree-of-an-array/</url>
    <content><![CDATA[<h2 id="1-hash表"><a href="#1-hash表" class="headerlink" title="1. hash表"></a>1. hash表</h2><p>首先使用hash表记录每个数据出现的频数，就可以得知最大的频数及其对应的数据。<br>此时如果有该数据的第一次和最后一次出现的位置，则可以获得这段区间的长度，比较频数最大的数据的区间的最小值即可。<br>数据的记录可以用hash表，key是元素值，为保证数据的一致性，value是一个数组，储存频数、首位置和末位置。也可以用3个数组直接储存，因为已经给定了0~49999的范围。<br>时间<code>O(n)</code>，空间<code>O(n)</code>。  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findShortestSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; mp;     <span class="comment">// key, [freq, first, last]</span></span><br><span class="line">        <span class="keyword">int</span> maxFreq = <span class="number">0</span>, minLen = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mp.count(nums[i]) == <span class="number">0</span>)</span><br><span class="line">                <span class="comment">// mp[nums[i]].emplace_back(1, i, i);       // 此时数组还不存在</span></span><br><span class="line">                mp[nums[i]] = &#123;<span class="number">1</span>, i, i&#125;;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                mp[nums[i]][<span class="number">0</span>]++;</span><br><span class="line">                mp[nums[i]][<span class="number">2</span>] = i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (maxFreq == mp[nums[i]][<span class="number">0</span>])</span><br><span class="line">                minLen = min(minLen, mp[nums[i]][<span class="number">2</span>] - mp[nums[i]][<span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (maxFreq &lt; mp[nums[i]][<span class="number">0</span>]) &#123;</span><br><span class="line">                maxFreq = mp[nums[i]][<span class="number">0</span>];</span><br><span class="line">                minLen = mp[nums[i]][<span class="number">2</span>] - mp[nums[i]][<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> minLen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>hash表</tag>
      </tags>
  </entry>
  <entry>
    <title>995. K 连续位的最小翻转次数</title>
    <url>/minimum-number-of-k-consecutive-bit-flips/</url>
    <content><![CDATA[<h2 id="1-贪心"><a href="#1-贪心" class="headerlink" title="1. 贪心"></a>1. 贪心</h2><p>贪心第一个0作为开始，将其及之后的元素进行反转。<br>因为如果反转的起点不是第一个0，则左侧的部分1也会被反转成0，而要反转被反转成的这部分0，又要向左延伸，因此需要贪心第一个0作为反转的起点。<br>时间<code>O(nk)</code>，空间<code>O(1)</code>，超时。  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minKBitFlips</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = A.size();</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (A[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i &lt;= n - K) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; i + K; j++)</span><br><span class="line">                        A[j] ^= <span class="number">1</span>;</span><br><span class="line">                    res++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    res = <span class="number">-1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2-差分数组"><a href="#2-差分数组" class="headerlink" title="2. 差分数组"></a>2. 差分数组</h2><p>方法1中超时是因为及时反转了数组，有<code>O(k)</code>的复杂度，因此考虑延迟反转数组。<br>如果使用一个数组直接记录每个元素的反转次数，则时间复杂度跟方法1中是相同的，而且还额外使用<code>O(n)</code>的空间复杂度。<br>而我们又需要区间内每个元素的反转次数，因此考虑使用差分，其是利用对区间两侧的操作代替对区间内部的操作。<br><img src="diff1.png" alt="diff1"><br>差分数组<code>diff[i]</code>记录的是第i项的反转次数与第i-1项的反转次数之差，因此反转区间[i, i + K)只需要修改<code>diff[i]++</code>和<code>diff[i+K]--</code>即可，省去了修改中间的部分，从而降低了时间复杂度。（实际上也不需要修改<code>diff[i]++</code>，因为只需要修改<code>revCnt</code>即可，之后<code>diff[i]</code>就没用了。）  </p>
<p>那么如何利用差分数组<code>diff</code>获得元素<code>A[i]</code>的反转次数呢？<br>实际上根据差分数组的定义，有如下式子：<br><code>revA[i] = revA[0] + (revA[1] - revA[0]) + ... + (revA[i] - revA[i - 1]) = diff[0] + diff[1] + ... + diff[i]</code><br>也实际上就是<code>A[i]</code>的反转次数 = <code>A[i-1]</code>的反转次数 + <code>diff[i]</code>。<br>因此只需要使用一个变量<code>revCnt</code>记录总和，作为反转次数即可。<br>时间<code>O(n)</code>，空间<code>O(n)</code>。  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minKBitFlips</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = A.size();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">diff</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> revCnt = <span class="number">0</span>, res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            revCnt += diff[i];      <span class="comment">// 首先得到当前元素的反转次数</span></span><br><span class="line">            <span class="keyword">if</span> ((A[i] + revCnt) % <span class="number">2</span> == <span class="number">0</span>) &#123;     <span class="comment">// 0且反转偶数次 或 1且反转奇数次 则需要修改</span></span><br><span class="line">                <span class="keyword">if</span> (i + K &gt; n) &#123;       <span class="comment">// 进行越界检查</span></span><br><span class="line">                    res = <span class="number">-1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i + K &lt; n)</span><br><span class="line">                    diff[i + K]--;</span><br><span class="line">                revCnt++;</span><br><span class="line">                res++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="3-滑动窗口"><a href="#3-滑动窗口" class="headerlink" title="3. 滑动窗口"></a>3. 滑动窗口</h2><p>观察方法2中的<code>diff</code>数组可以发现，<code>diff[i]</code>最多只会被修改–1次，代表<code>A[i]</code>比<code>A[i-1]</code>少反转1次。<br>所以如果将<code>diff</code>数组的作用添加到原数组<code>A</code>上，在原数组的基础上做标记，则可以省掉<code>O(n)</code>的空间。<br>并且由于原数组中只有0和1，故将其修改为其他值，就代表该位置的<code>diff</code>数组被修改了，该位置的反转次数要比前一个位置的反转次数少1次。<br>当然，如果需要保留原数组的数据，则可以不直接修改为其他值，而是在原来值的基础上添加其他值，比如+2，则大小超过1就代表修改过了，并且之后还原时，将大于1的数-2即可。<br>时间<code>O(n)</code>，空间<code>O(1)</code>。  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minKBitFlips</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = A.size();</span><br><span class="line">        <span class="keyword">int</span> revCnt = <span class="number">0</span>, res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (A[i] &gt; <span class="number">1</span>)</span><br><span class="line">                revCnt--;</span><br><span class="line">            <span class="keyword">if</span> ((A[i] + revCnt) % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i + K &gt; n) &#123;</span><br><span class="line">                    res = <span class="number">-1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i + K &lt; n) </span><br><span class="line">                    A[i + K] += <span class="number">2</span>;</span><br><span class="line">                revCnt++;</span><br><span class="line">                res++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="keyword">if</span> (A[i] &gt; <span class="number">1</span>)</span><br><span class="line">                A[i] -= <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>滑动窗口</tag>
        <tag>贪心</tag>
        <tag>差分</tag>
      </tags>
  </entry>
  <entry>
    <title>765. 情侣牵手</title>
    <url>/couples-holding-hands/</url>
    <content><![CDATA[<h2 id="1-并查集"><a href="#1-并查集" class="headerlink" title="1. 并查集"></a>1. 并查集</h2><p>有1对情侣时，需要交换0次。<br>有2对情侣交叉坐时，需要交换1次。<br>有3对情侣交叉坐时，需要交换2次。<br>…<br>有k对情侣交叉坐时，需要交换k-1次。<br>因为有k对情侣交叉坐时，交换1次可以使且仅使1对情侣牵手，剩余k-1对情侣交叉坐，以此类推。<br>交换1次仅能使1对情侣牵手，因为如果可以使2对情侣牵手，剩余k-2对情侣交叉坐，则之前不是k对情侣交叉坐的。  </p>
<p>因此考虑使用并查集，每次遍历两个位置，并获取他们所属的组别。组别是值/2，如0和1属于0组，2和3属于1组…<br>判断二者组别如果一致，则跳过；否则使用并查集将二者的组别合并，合并成为1个连通分支。同一个连通分支中的各个数据一定是多组同队情侣交叉分散在不同的位置上。<br>最终答案为每个连通分支中<code>情侣对数 - 1的和</code>，实际上也等于<code>总情侣对数 - 连通分支数</code>，而后者更容易计算。<br>时间<code>O(n)</code>，空间<code>O(n)</code>。  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    UnionFind (<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="comment">// parent.reserve(n);       // reserve()只预留空间，不修改size，故修改后不能直接访问</span></span><br><span class="line">        parent.resize(n);</span><br><span class="line">        cnt = n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            parent[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span> <span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x != parent[x])</span><br><span class="line">            parent[x] = find(parent[x]);</span><br><span class="line">        <span class="keyword">return</span> parent[x];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unite</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pa = find(a), pb = find(b);</span><br><span class="line">        <span class="keyword">if</span> (pa != pb) &#123;</span><br><span class="line">            parent[pb] = pa;</span><br><span class="line">            cnt--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getCnt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; parent;</span><br><span class="line">    <span class="keyword">int</span> cnt;    <span class="comment">// 连通分支数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minSwapsCouples</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; row)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = row.size();</span><br><span class="line">        <span class="function">UnionFind <span class="title">uf</span><span class="params">(n)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i += <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> group1 = row[i] / <span class="number">2</span>, group2 = row[i + <span class="number">1</span>] / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (group1 != group2)</span><br><span class="line">                uf.unite(group1, group2);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> n / <span class="number">2</span> - uf.getCnt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title>703. 数据流中的第 K 大元素</title>
    <url>/kth-largest-element-in-a-stream/</url>
    <content><![CDATA[<h2 id="1-堆"><a href="#1-堆" class="headerlink" title="1. 堆"></a>1. 堆</h2><p>由于类只需要求第k大元素，因此只保留第k大和比它大的元素作为比较即可，其他元素可以丢弃。<br>因此可以使用一个大小为k的小根堆，储存前k大元素。<br>当要插入元素时，与小根堆堆顶元素比较，如果偏小则抛弃，如果偏大则弹出堆顶，插入该元素。<br>时间<code>O(nlogk)</code>，空间<code>O(k)</code>。  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KthLargest</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    KthLargest(<span class="keyword">int</span> k, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">this</span>-&gt;k = k;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            add(nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (smallHeap.size() == k &amp;&amp; val &gt; smallHeap.top()) &#123;</span><br><span class="line">            smallHeap.pop();</span><br><span class="line">            smallHeap.push(val);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (smallHeap.size() &lt; k)</span><br><span class="line">            smallHeap.push(val);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> smallHeap.top();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> k;</span><br><span class="line">    <span class="built_in">priority_queue</span>&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt;&gt; smallHeap;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your KthLargest object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * KthLargest* obj = new KthLargest(k, nums);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;add(val);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>堆</tag>
      </tags>
  </entry>
  <entry>
    <title>992. K个不同整数的子数组</title>
    <url>/subarrays-with-k-different-integers/</url>
    <content><![CDATA[<h2 id="1-滑动窗口"><a href="#1-滑动窗口" class="headerlink" title="1. 滑动窗口"></a>1. 滑动窗口</h2><p>固定窗口的左边界，右边界向右滑动，可以找到一个最大的不可再扩展的大小为k的好子数组。此时如果也找到一个最大的不可再扩展的大小为k-1的好子数组，则二者右边界的差值即为当前左边界对应的大小为k的好子数组的个数，因为二者右侧的差值中含有第k种数据。<br>这种做法需要使用两个<code>freq</code>数组记录k-1和k窗口（简称为大、小窗口）出现的各个元素的次数，因为当左边界向右移动之后，小窗口内部的元素数据可能变为k-2个，而大窗口仍为k个。所以需要分开保存，分别扩展。  </p>
<p>如果固定的是窗口的右边界，大小窗口只有左边界不同。实际操作中，相较于固定左边界，固定右边界更加简单，因为此时每次扩展移动的都是同一个右边界，而固定左边界时右边界扩展是要扩展两个右边界。<br>使用这种算法，同样地需要找到一个最大的不可再扩展的大小为k和k-1的好子数组的左边界，二者的差值即为当前固定右边界对应的好子数组的种数。<br>之后右边界继续向右移动1个位置，有三种情况：  </p>
<ol>
<li>大小窗口的元素种数都没有改变，仍为k和k-1</li>
<li>大窗口的元素种类没有改变，小窗口的元素种类变为k</li>
<li>大小窗口的元素种数都增加，变为k+1和k<br>对于第一种情况，二者的左边界不需要改变，并计算差值增加到答案，作为新的右边界对应的好子数组的个数；对于第二种情况，小窗口需要向右移动左边界，移动到最大的不可再扩展的大小为k-1的好子数组的左边界，而大窗口的左边界不变；对于第三种情况，小窗口的左边界向右移动到最大的不可再扩展的大小为k-1的好子数组的左边界，大窗口的左边界移动到小窗口的左边界的原位置即可。  </li>
</ol>
<p>通过这个题要学会固定一个边界，滑动另一个边界求解问题的方法。<br>时间<code>O(n)</code>，空间<code>O(n)</code>。  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">subarraysWithKDistinct</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = A.size();</span><br><span class="line">        vector&lt;int&gt; freqSmall(n + 1, 0), freqBig(n + 1, 0);</span><br><span class="line">        <span class="keyword">int</span> leftSmall = <span class="number">0</span>, leftBig = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> countSmall = <span class="number">0</span>, countBig = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (right &lt; n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (freqSmall[A[right]] == <span class="number">0</span>) </span><br><span class="line">                countSmall++;</span><br><span class="line">            freqSmall[A[right]]++;</span><br><span class="line">            <span class="keyword">if</span> (freqBig[A[right]] == <span class="number">0</span>)</span><br><span class="line">                countBig++;</span><br><span class="line">            freqBig[A[right]]++;</span><br><span class="line">            right++;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// if (countBig == K + 1) &#123;</span></span><br><span class="line">            <span class="comment">//     leftBig = leftSmall;</span></span><br><span class="line">            <span class="comment">//     freqBig = freqSmall;</span></span><br><span class="line">            <span class="comment">//     countBig = K;</span></span><br><span class="line">            <span class="comment">// &#125;</span></span><br><span class="line">            <span class="keyword">while</span> (countBig == K + <span class="number">1</span>) &#123;</span><br><span class="line">                freqBig[A[leftBig]]--;</span><br><span class="line">                <span class="keyword">if</span> (freqBig[A[leftBig]] == <span class="number">0</span>)</span><br><span class="line">                    countBig--;</span><br><span class="line">                leftBig++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (countSmall == K) &#123;</span><br><span class="line">                freqSmall[A[leftSmall]]--;</span><br><span class="line">                <span class="keyword">if</span> (freqSmall[A[leftSmall]] == <span class="number">0</span>)</span><br><span class="line">                    countSmall--;</span><br><span class="line">                leftSmall++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            res += leftSmall - leftBig;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>滑动窗口</tag>
      </tags>
  </entry>
  <entry>
    <title>567. 字符串的排列</title>
    <url>/permutation-in-string/</url>
    <content><![CDATA[<h2 id="1-滑动窗口"><a href="#1-滑动窗口" class="headerlink" title="1. 滑动窗口"></a>1. 滑动窗口</h2><p>要求是字符串的任一排列，因此不需要实际遍历各种排列，只需要统计该字符串各字符的个数即可。<br>窗口右边界向右滑动，直到不可再滑动。如果此时还不满足条件，则左边界向右滑动1个位置，然后继续判断右边界。当左右边界重叠时右边界还不能向右滑动，证明字符串中不存在该字符，左右边界同时向右滑动1个位置。<br>时间<code>O(n)</code>，空间<code>O(26)</code>。  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">checkInclusion</span><span class="params">(<span class="built_in">string</span> s1, <span class="built_in">string</span> s2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len1 = s1.length(), len2 = s2.length();</span><br><span class="line">        <span class="keyword">if</span> (len1 &gt; len2)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">bool</span> res = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> freq[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++)</span><br><span class="line">            freq[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len1; i++)</span><br><span class="line">            freq[s1[i] - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (right &lt; len2) &#123;</span><br><span class="line">            <span class="keyword">if</span> (freq[s2[right] - <span class="string">&#x27;a&#x27;</span>] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                freq[s2[right] - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">                right++;</span><br><span class="line">                len1--;</span><br><span class="line">                <span class="keyword">if</span> (len1 == <span class="number">0</span>) &#123;</span><br><span class="line">                    res = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (left == right) &#123;</span><br><span class="line">                    left++;</span><br><span class="line">                    right++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    freq[s2[left] - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">                    left++;</span><br><span class="line">                    len1++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>滑动窗口</tag>
      </tags>
  </entry>
  <entry>
    <title>978. 最长湍流子数组</title>
    <url>/longest-turbulent-subarray/</url>
    <content><![CDATA[<h2 id="1-滑动窗口"><a href="#1-滑动窗口" class="headerlink" title="1. 滑动窗口"></a>1. 滑动窗口</h2><p>题目中要求的是“子数组”，但实际上是要求连续的“子串”。<br>因此可以使用滑动窗口，固定左侧，右侧在满足“湍流”条件的情况下向右移动，直到不满足条件，记录此时子数组的长度。<br>取长度的最大值，然后重新开始窗口的滑动。<br>由于当前窗口内的子数组满足“湍流”条件，因此该子数组的任意子数组也满足“湍流”条件，故调整窗口左侧到右侧位置，以窗口最后一个元素作为下一个窗口新开始的元素。<br>时间<code>O(n)</code>，空间<code>O(1)</code>。  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxTurbulenceSize</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = arr.size();</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>, maxLen = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">bool</span> greater = arr[<span class="number">1</span>] &gt; arr[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (right &lt; n) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((greater &amp;&amp; arr[right] &gt; arr[right - <span class="number">1</span>]) || (!greater &amp;&amp; arr[right] &lt; arr[right - <span class="number">1</span>])) &#123;</span><br><span class="line">                right++;</span><br><span class="line">                greater = !greater;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                len = right - left;</span><br><span class="line">                maxLen = max(maxLen, len);</span><br><span class="line">                <span class="keyword">while</span> (right &lt; n &amp;&amp; arr[right] == arr[right - <span class="number">1</span>])</span><br><span class="line">                    right++;</span><br><span class="line">                left = right - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (right &lt; n)</span><br><span class="line">                    greater = arr[right] &gt; arr[left];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        maxLen = max(maxLen, right - left);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> maxLen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>滑动窗口</tag>
      </tags>
  </entry>
  <entry>
    <title>665. 非递减数列</title>
    <url>/non-decreasing-array/</url>
    <content><![CDATA[<h2 id="1-朴素"><a href="#1-朴素" class="headerlink" title="1. 朴素"></a>1. 朴素</h2><p>遍历直到出现不满足非递减的情况，此时需要进行调整，然后看调整之后是否可以继续满足非递减条件。<br>调整时使用贪心策略，优先修改能使调整后的当前位置的元素更小。<br>可能遇到的情况：<code>1 2 3 4 1 6 7 ...</code>, <code>1 2 3 8 4 5 6 ...</code><br>时间<code>O(n)</code>，空间<code>O(1)</code>。  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">checkPossibility</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">bool</span> changed = <span class="literal">false</span>, res = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">int</span> preLoc = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &lt; nums[preLoc] &amp;&amp; changed) &#123;</span><br><span class="line">                res = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] &lt; nums[preLoc] &amp;&amp; !changed) &#123;</span><br><span class="line">                <span class="keyword">if</span> (preLoc == <span class="number">0</span>) </span><br><span class="line">                    preLoc = i;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (nums[i] &gt;= nums[preLoc - <span class="number">1</span>]) </span><br><span class="line">                        preLoc = i;</span><br><span class="line">                &#125;</span><br><span class="line">                changed = <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> </span><br><span class="line">                preLoc = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>1423. 可获得的最大点数</title>
    <url>/maximum-points-you-can-obtain-from-cards/</url>
    <content><![CDATA[<h2 id="1-动态规划"><a href="#1-动态规划" class="headerlink" title="1. 动态规划"></a>1. 动态规划</h2><p>由于不能贪心抽两侧最大的牌，因此考虑dp，两侧都抽，然后对剩下的部分同样进行一次“可获得的最大点数”的求解。<br>为了避免重复计算，使用hash表记录求解过的每一段数组的最大点数。<br>另外，由于hash表的key是<code>pair</code>类型，因此还需要手动提供<code>pair</code>类型的hash函数。<br>时间<code>O(k^2)</code>，空间<code>O(k^2)</code>，因为要求解和记录k从0到k每种情况下，对应数组段的最大点数。超时。  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pairhash</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">U</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">std</span>:</span>:<span class="function"><span class="keyword">size_t</span> <span class="title">operator</span> <span class="params">()</span> <span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">pair</span>&lt;T, U&gt;&amp; p)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="comment">// sizt_t = typeof(sizeof(x))，是sizeof()函数返回值的类型，代表目标平台下最大可能的数组尺寸</span></span><br><span class="line">        <span class="comment">// size_t是unsigned，保证跨平台</span></span><br><span class="line">        <span class="built_in">std</span>::hash&lt;T&gt; Thasher;</span><br><span class="line">        <span class="built_in">std</span>::hash&lt;U&gt; Uhasher;</span><br><span class="line">        <span class="keyword">return</span> Thasher(p.first) ^ Uhasher(p.second);</span><br><span class="line">        <span class="comment">// 使用first和second的hash值的异或作为pair的hash值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxScore</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; cardPoints, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = cardPoints.size();</span><br><span class="line">        <span class="comment">// unordered_map&lt;pair&lt;int, int&gt;, int&gt; scores;</span></span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;, <span class="keyword">int</span>, pairhash&gt; scores;</span><br><span class="line">        subMaxScore(cardPoints, <span class="number">0</span>, n, scores, k);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> scores[<span class="built_in">make_pair</span>(<span class="number">0</span>, n)];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">subMaxScore</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; cardPoints, <span class="keyword">int</span> beg, <span class="keyword">int</span> end, <span class="built_in">unordered_map</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;, <span class="keyword">int</span>, pairhash&gt;&amp; scores, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; cur = <span class="built_in">make_pair</span>(beg, end);</span><br><span class="line">        <span class="keyword">if</span> (scores.count(cur))</span><br><span class="line">            <span class="keyword">return</span> scores[cur];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> leftScore = cardPoints[beg], rightScore = cardPoints[end - <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; left = <span class="built_in">make_pair</span>(beg + <span class="number">1</span>, end), right = <span class="built_in">make_pair</span>(beg, end - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (scores.count(left))     <span class="comment">// 选最左元素</span></span><br><span class="line">            leftScore += scores[left];</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            leftScore += subMaxScore(cardPoints, beg + <span class="number">1</span>, end, scores, k - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (scores.count(right))    <span class="comment">// 选最右元素</span></span><br><span class="line">            rightScore += scores[right];</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            rightScore += subMaxScore(cardPoints, beg, end - <span class="number">1</span>, scores, k - <span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        scores[cur] = max(leftScore, rightScore);</span><br><span class="line">        <span class="keyword">return</span> scores[cur];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2-滑动窗口"><a href="#2-滑动窗口" class="headerlink" title="2. 滑动窗口"></a>2. 滑动窗口</h2><p>并不一定是窗口两侧初始化为数组两侧，窗口向内收缩；也可以是固定窗口大小，移动窗口位置。<br>因为要从n个数中选k个，因此可以固定窗口大小为n-k个，代表剩余的数据。窗口从左向右滑动，在此过程中统计结果。<br>时间<code>O(k)</code>，空间<code>O(1)</code>。  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxScore</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; cardPoints, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = cardPoints.size();</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = n - k;    <span class="comment">// [left, right)</span></span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>, maxSum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = right; i &lt; n; i++)</span><br><span class="line">            sum += cardPoints[i];</span><br><span class="line">        maxSum = sum;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (right &lt; n) &#123;</span><br><span class="line">            sum += cardPoints[left++];</span><br><span class="line">            sum -= cardPoints[right++];</span><br><span class="line">            maxSum = max(maxSum, sum);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> maxSum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>滑动窗口</tag>
      </tags>
  </entry>
  <entry>
    <title>1208. 尽可能使字符串相等</title>
    <url>/get-equal-substrings-within-budget/</url>
    <content><![CDATA[<h2 id="1-滑动窗口"><a href="#1-滑动窗口" class="headerlink" title="1. 滑动窗口"></a>1. 滑动窗口</h2><p>滑动窗口从左侧开始在满足cost的情况下向右滑动，记录最大窗口大小。<br>当cost不足以支持窗口继续向右扩展时，左侧窗口向右收缩1次，然后右侧窗口继续向右扩展。<br>时间<code>O(n)</code>，空间<code>O(1)</code>。  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">equalSubstring</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t, <span class="keyword">int</span> maxCost)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>, maxDist = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (right &lt; n) &#123;</span><br><span class="line">            <span class="keyword">int</span> cost = <span class="built_in">abs</span>(s[right] - t[right]);</span><br><span class="line">            <span class="keyword">if</span> (cost &lt;= maxCost) &#123;</span><br><span class="line">                maxCost -= cost;</span><br><span class="line">                right++;</span><br><span class="line">                maxDist = max(maxDist, right - left);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">                maxCost += <span class="built_in">abs</span>(s[left] - t[left]);</span><br><span class="line">                left++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (left == right) &#123;</span><br><span class="line">                left++;</span><br><span class="line">                right++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> maxDist;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>双指针</tag>
        <tag>滑动窗口</tag>
      </tags>
  </entry>
  <entry>
    <title>480. 滑动窗口中位数</title>
    <url>/sliding-window-median/</url>
    <content><![CDATA[<h2 id="1-暴力"><a href="#1-暴力" class="headerlink" title="1. 暴力"></a>1. 暴力</h2><p>每移动一下窗口，就对新窗口的内容排序，得到中位数。<br>时间<code>O(nklogk)</code>，超时。  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; <span class="title">medianSlidingWindow</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">saveNums</span><span class="params">(nums)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; res;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left + k &lt;= n) &#123;</span><br><span class="line">            nums = saveNums;</span><br><span class="line">            sort(nums.begin() + left, nums.begin() + left + k);</span><br><span class="line">            <span class="keyword">int</span> a = nums[(<span class="number">2</span> * left + k - <span class="number">1</span>) / <span class="number">2</span>], b = nums[(<span class="number">2</span> * left + k) / <span class="number">2</span>];</span><br><span class="line">            res.push_back((a - b) / <span class="number">2.0</span> + b);   <span class="comment">// 2.0保证转换为小数，(a-b)/2.0+b避免溢出</span></span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2-堆-延迟删除"><a href="#2-堆-延迟删除" class="headerlink" title="2. 堆+延迟删除"></a>2. 堆+延迟删除</h2><p>由于移动窗口之后，绝大多数的数据是不变的，因此对窗口内的所有数据重新排序是很费时的。<br>考虑用一个大根堆和一个小根堆储存有序数组左右两侧的部分，大根堆存较小的数据，小根堆存较大的数据，使得大小根堆的堆顶都是有序数据中间的部分。<br>这样如果窗口是奇数大小，则令大根堆比小根堆多1个数，大根堆的堆顶就是中位数；如果窗口大小是偶数，则取二者的平均值。<br>当窗口向右移动时，右侧新增的元素如果&gt;=大根堆堆顶元素，则加入大根堆，否则加入小根堆。<br>窗口向右移动之后，左侧减少了一个元素。假设已经从堆中删除了这个元素，则可能会导致两个堆各自的元素个数不再满足要求，因此需要弹出数据偏多的堆的堆顶元素，加入数据偏少的堆中。<br>考虑删除左侧元素。因为窗口左侧的元素可能在堆的内部，而堆只能对堆顶进行操作，所以不能直接删除可能在内部的窗口左侧元素。又因为如果不考虑数据个数的话，在堆内部的这个元素对于求中位数是没有影响的，因此可以考虑延迟删除。<br>使用一个hash表记录每个元素要删除的次数，当要删除的元素在堆的内部时，暂时不删除，因为对于求解问题没有影响。直到在堆将要删除的元素移动到堆顶时，才可能会对中位数的求解产生影响，此时检查hash表，将其删除即可。<br>时间<code>O(nlogk)</code>。  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; <span class="title">medianSlidingWindow</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; res;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++)</span><br><span class="line">            small.push(nums[i]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k / <span class="number">2</span>; i++) &#123;</span><br><span class="line">            big.push(small.top());</span><br><span class="line">            small.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> smallOverBig = <span class="number">0</span>;       <span class="comment">// small数据的堆的元素个数比big数据的堆的元素个数多多少，初始为0，假设多1个的奇数状态也算平衡</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = k;    <span class="comment">// [left, right)</span></span><br><span class="line">        <span class="keyword">while</span> (right &lt;= n) &#123;</span><br><span class="line">            <span class="comment">// 在计算中位数之前，首先把可能影响中位数计算的可延迟删除的数据删除掉</span></span><br><span class="line">            <span class="keyword">while</span> (!small.empty() &amp;&amp; delayed[small.top()] != <span class="number">0</span>) &#123;</span><br><span class="line">                delayed[small.top()]--;</span><br><span class="line">                small.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (!big.empty() &amp;&amp; delayed[big.top()] != <span class="number">0</span>) &#123;</span><br><span class="line">                delayed[big.top()]--;</span><br><span class="line">                big.pop();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            res.push_back(getMedian(k));</span><br><span class="line">            <span class="keyword">if</span> (right == n)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 加入窗口右侧数据</span></span><br><span class="line">            <span class="keyword">if</span> (nums[right] &lt;= small.top()) &#123;</span><br><span class="line">                small.push(nums[right]);</span><br><span class="line">                smallOverBig++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                big.push(nums[right]);</span><br><span class="line">                smallOverBig--;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 移除窗口左侧数据</span></span><br><span class="line">            <span class="keyword">if</span> (nums[left] &lt;= small.top())</span><br><span class="line">                smallOverBig--;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                smallOverBig++;</span><br><span class="line">            delayed[nums[left]]++;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 调整small和big堆的平衡</span></span><br><span class="line">            <span class="keyword">if</span> (smallOverBig == <span class="number">2</span>) &#123;</span><br><span class="line">                big.push(small.top());</span><br><span class="line">                small.pop();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (smallOverBig == <span class="number">-2</span>) &#123;</span><br><span class="line">                small.push(big.top());</span><br><span class="line">                big.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            smallOverBig = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            left++;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getMedian</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (k % <span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> small.top();</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            <span class="comment">// return (small.top() - big.top()) / 2.0 + big.top();  // 还是溢出了..</span></span><br><span class="line">            <span class="keyword">return</span> ((<span class="keyword">double</span>)small.top() + big.top()) / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">priority_queue</span>&lt;<span class="keyword">int</span>&gt; small;          <span class="comment">// 大根堆，存small的元素</span></span><br><span class="line">    <span class="built_in">priority_queue</span>&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt;&gt; big;     <span class="comment">// 小根堆，存big的元素</span></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; delayed;    <span class="comment">// 延迟删除表</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>滑动窗口</tag>
        <tag>堆</tag>
      </tags>
  </entry>
  <entry>
    <title>763.划分字母区间</title>
    <url>/partition-labels/</url>
    <content><![CDATA[<h2 id="1-朴素"><a href="#1-朴素" class="headerlink" title="1. 朴素"></a>1. 朴素</h2><p>首先找到第一个字符最后一次出现的位置，得到一个子串。<br>然后遍历这个子串，找其中每一个字符的最后一次出现的位置，得到这个子串最终的结尾。<br>对右侧剩余部分做同样的处理。<br>时间<code>O(n^2)</code>，空间<code>O(1)</code>。  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">partitionLabels</span><span class="params">(<span class="built_in">string</span> S)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">int</span> n = S.length();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n;) &#123;</span><br><span class="line">            <span class="keyword">int</span> lastIdx = lastLocation(S, i);       <span class="comment">// 获取开始字符的最后出现位置</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; lastIdx; j++)</span><br><span class="line">                <span class="comment">// 这里可以适当剪枝，已经访问过的字符之后不需要再重复访问了，因为其最后出现的位置还是不变的。</span></span><br><span class="line">                lastIdx = max(lastIdx, lastLocation(S, j));</span><br><span class="line">            ans.push_back(lastIdx - i + <span class="number">1</span>);</span><br><span class="line">            i = lastIdx + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lastLocation</span><span class="params">(<span class="built_in">string</span> S, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = S.length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = k + <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">            <span class="keyword">if</span> (S[k] == S[i])</span><br><span class="line">                k = i;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2-记忆化"><a href="#2-记忆化" class="headerlink" title="2. 记忆化"></a>2. 记忆化</h2><p>上述方法的问题是在查找每个元素出现的最后一个位置上花费了太多的时间，导致时间复杂度是<code>O(n^2)</code>的。<br>可以使用一个<code>bool</code>数组记录已经访问过最后一个位置的元素，之后再遇到就不需要再次访问了，不过这样最差是<code>O(26n)</code>的。<br>更好的方法是首先遍历一次字符串，使用一个大小为26的数组记录每个字符最后出现的位置，在需要最后一个位置时直接查表。<br>时间<code>O(n)</code>，空间<code>O(26) = O(1)</code>。  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">partitionLabels</span><span class="params">(<span class="built_in">string</span> S)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans, loc(<span class="number">26</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> n = S.length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            loc[S[i] - <span class="string">&#x27;a&#x27;</span>] = i;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n;) &#123;</span><br><span class="line">            <span class="keyword">int</span> lastIdx = loc[S[i] - <span class="string">&#x27;a&#x27;</span>];       <span class="comment">// 获取开始字符的最后出现位置</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; lastIdx; j++)</span><br><span class="line">                <span class="comment">// 这里可以适当剪枝，已经访问过的字符之后不需要再重复访问了，因为其最后出现的位置还是不变的。</span></span><br><span class="line">                lastIdx = max(lastIdx, loc[S[j] - <span class="string">&#x27;a&#x27;</span>]);</span><br><span class="line">            ans.push_back(lastIdx - i + <span class="number">1</span>);</span><br><span class="line">            i = lastIdx + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>常见的排序算法详解及C++代码</title>
    <url>/sort-an-array/</url>
    <content><![CDATA[<h2 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h2><p>以 leetcode <a href="https://leetcode-cn.com/problems/sort-an-array/">912. 排序数组</a>为例。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">sortArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>练习排序的题，要求复杂度<code>O(nlogn)</code>。  </p>
<h2 id="1-憨批解法之直接STL-sort"><a href="#1-憨批解法之直接STL-sort" class="headerlink" title="1. 憨批解法之直接STL sort()"></a>1. 憨批解法之直接STL sort()</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">sortArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2-计数排序counting-sort"><a href="#2-计数排序counting-sort" class="headerlink" title="2. 计数排序counting sort"></a>2. 计数排序counting sort</h2><p>计数排序的时间复杂度是<code>O(n+range)</code>的，空间复杂度是<code>O(range)</code>。<br>由于计数排序不是比较排序，所以不受最优时间复杂度是<code>O(nlogn)</code>的限制。<br>计数排序是稳定的排序方法，但是下面的代码不是稳定的。  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">sortArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> *counter = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100010</span>]&#123;&#125;;   <span class="comment">//需要加&#123;&#125;进行初始化</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++)</span><br><span class="line">            counter[nums[i] + <span class="number">50000</span>]++;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">100000</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (counter[i] != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = counter[i]; j &gt; <span class="number">0</span>; j--)</span><br><span class="line">                    nums[k++] = i - <span class="number">50000</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">delete</span> []counter;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>稳定的计数排序如下所示，A是待排数组，B是排序之后的数组，k是范围：<br><img src="stable_counting_sort.png" alt="stable_counting_sort"><br>大致流程是：  </p>
<ol>
<li><code>C[i]</code>首先记录<code>i</code>的出现次数，遍历数组<code>A</code>。  </li>
<li><code>C[i]</code>之后作为记录小于等于<code>i</code>的元素的出现次数，即<code>C[i] = C[i] + C[i - 1]</code>。  </li>
<li>从数组<code>A</code>的最后一个元素开始，倒着向前遍历<code>A[i]</code>。  <ul>
<li>检查<code>C[A[i]]</code>获得元素<code>A[i]</code>的出现次数。  </li>
<li>由于<code>A[i]</code>元素必存在，且通过<code>C[A[i]]</code>获得了小于等于<code>A[i]</code>的元素的个数，因此<code>A[i]</code>在有序数组<code>B</code>中的位置最大为<code>C[A[i]] - 1</code>。  </li>
<li><code>B[C[A[i]] - 1] = A[i]</code>，然后<code>C[A[i]]--; i--;</code>.  </li>
<li>逆序遍历完<code>A</code>数组之后，<code>C[i]</code>就变成了小于i的元素的个数，<code>B</code>为有序的新数组。  </li>
</ul>
</li>
<li>以上方法就相当于倒着每次把数组<code>A</code>中最后的元素放到它可能在的最后的位置，从而保证了是稳定的。  </li>
</ol>
<p><img src="counting_1.png" alt="counting_process1"><br><img src="counting_2.png" alt="counting_process2"><br><img src="counting_3.png" alt="counting_process3">  </p>
<p>同样，计数排序的空间复杂度也不一定必须是<code>O(range)</code>的。<br>当<code>range</code>很大而数据很少时，申请一个大空间是非常浪费的，因此可以申请一个大小为<code>n</code>的空间作为<code>counter</code>。<br><code>counter[i]</code>不再是数据<code>i</code>出现的次数，而是小于和在数据左侧等于<code>nums[i]</code>这个数据的数据个数。<br>这样就直接获得了<code>nums[i]</code>这个数据在有序数组中的位置，并且还保证了排序的稳定性。<br>获取<code>counter</code>数组的时间复杂度为<code>O(n^2)</code>。排序的空间复杂度为<code>O(n)</code>。<br><img src="counting_stable_O(n).png" alt="stable_counting_sort_capable_with_with_range">  </p>
<h2 id="3-堆排序heap-sort"><a href="#3-堆排序heap-sort" class="headerlink" title="3. 堆排序heap sort"></a>3. 堆排序heap sort</h2><p>时间复杂度<code>O(nlogn)</code>，空间上可以原地排。不稳定的排序。  </p>
<h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p>由于堆是满二叉树，所以不需要定义节点的左右孩子，而直接通过索引运算就可以得到。<br>以下以最大堆为例。  </p>
<h4 id="初始化heapify"><a href="#初始化heapify" class="headerlink" title="初始化heapify"></a>初始化<code>heapify</code></h4><p>从最后一个有子节点的节点开始，判断以它为根的部分是否为满足要求的堆，若不满足，则下沉。<br>节点从最后一个开始，直到修改到根节点。由于修改之后以当前节点为根的堆就满足条件了，所以再修改之上的节点就下沉即可满足要求。<br>修改一个节点是<code>O(logn)</code>，修改n个节点即为<code>O(nlogn)</code>。但heapify的复杂度是并不是<code>O(nlogn)</code>，而是<code>O(n)</code>，这个可以通过数学推导得出。<br>当然，也可以最开始是一个空堆，然后插入n次，但这样的复杂度就是<code>O(nlogn)</code>，比heapify要复杂。  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapify</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = (n - <span class="number">2</span>) / <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">int</span> loc = i;</span><br><span class="line">        <span class="keyword">while</span> (loc &lt;= (n - <span class="number">2</span>) / <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> child = <span class="number">2</span> * loc + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (child + <span class="number">1</span> &lt; n &amp;&amp; nums[child] &lt; nums[child + <span class="number">1</span>])</span><br><span class="line">                child++;</span><br><span class="line">            <span class="keyword">if</span> (nums[loc] &lt; nums[child]) &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = nums[loc];</span><br><span class="line">                nums[loc] = nums[child];</span><br><span class="line">                nums[child] = temp;</span><br><span class="line">                loc = child;</span><br><span class="line">            &#125; <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="插入push"><a href="#插入push" class="headerlink" title="插入push"></a>插入<code>push</code></h4><p>将节点添加到最后一个位置，然后判断是否需要对其进行上升操作。  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    nums.push_back(value);</span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    <span class="keyword">int</span> child = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> parent = (n - <span class="number">2</span>) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span> (parent &gt;= <span class="number">0</span> &amp;&amp; nums[child] &gt; nums[parent]) &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = nums[parent];</span><br><span class="line">        nums[parent] = nums[child];</span><br><span class="line">        nums[child] = temp;</span><br><span class="line">        child = parent;</span><br><span class="line">        parent = (parent - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="删除pop"><a href="#删除pop" class="headerlink" title="删除pop"></a>删除<code>pop</code></h4><p>删除堆的根节点，然后将最后一个节点移动到根节点，对新的根节点判断是否需要下降。<br>由于为了与题目对应，这里用vector作为存储工具，因为没有定义自己的size，所以用vector的resize()修改大小。  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    <span class="keyword">int</span> value = nums[<span class="number">0</span>];</span><br><span class="line">    nums[<span class="number">0</span>] = nums[n - <span class="number">1</span>];</span><br><span class="line">    nums.resize(--n);</span><br><span class="line">    <span class="keyword">int</span> loc = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (loc &lt;= (n - <span class="number">2</span>) / <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> child = <span class="number">2</span> * loc + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (child + <span class="number">1</span> &lt; n &amp;&amp; nums[child] &lt; nums[child + <span class="number">1</span>])</span><br><span class="line">            child++;</span><br><span class="line">        <span class="keyword">if</span> (nums[loc] &lt; nums[child]) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = nums[loc];</span><br><span class="line">            nums[loc] = nums[child];</span><br><span class="line">            nums[child] = temp;</span><br><span class="line">            loc = child;</span><br><span class="line">        &#125; <span class="keyword">else</span> </span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果想删除堆中任意位置的元素，则删除方法是用最后一个元素覆盖当前位置，size–，然后对当前位置元素进行上浮或下沉。  </p>
<h4 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h4><p>直接想到的方法是首先heapify建堆，然后每次弹出一个元素弹出到新的数组中。<br>不过堆排序是可以in-place修改的。<br>只需要把堆的根节点放到与数组最末尾的元素交换位置，然后size–不再考虑这个节点，就得到了一个最大值。这也是为什么从小到大排序需要大根堆的原因。<br>这样做就相当于是弹出了：离开了堆，且将最后一个元素换到了根节点位置上。  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">heapify</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = (n - <span class="number">2</span>) / <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">int</span> loc = i;</span><br><span class="line">            <span class="keyword">while</span> (loc &lt;= (n - <span class="number">2</span>) / <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> child = <span class="number">2</span> * loc + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (child + <span class="number">1</span> &lt; n &amp;&amp; nums[child] &lt; nums[child + <span class="number">1</span>])</span><br><span class="line">                    child++;</span><br><span class="line">                <span class="keyword">if</span> (nums[loc] &lt; nums[child]) &#123;</span><br><span class="line">                    <span class="keyword">int</span> temp = nums[loc];</span><br><span class="line">                    nums[loc] = nums[child];</span><br><span class="line">                    nums[child] = temp;</span><br><span class="line">                    loc = child;</span><br><span class="line">                &#125; <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">sortArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        heapify(nums);</span><br><span class="line">        <span class="keyword">int</span> last = n - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(last &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = nums[<span class="number">0</span>];</span><br><span class="line">            nums[<span class="number">0</span>] = nums[last];</span><br><span class="line">            nums[last--] = temp;</span><br><span class="line">            <span class="keyword">int</span> loc = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (last &gt; <span class="number">0</span> &amp;&amp; loc &lt;= (last - <span class="number">1</span>) / <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> child = loc * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (child + <span class="number">1</span> &lt;= last &amp;&amp; nums[child] &lt; nums[child + <span class="number">1</span>])</span><br><span class="line">                    child++;</span><br><span class="line">                <span class="keyword">if</span> (nums[loc] &lt; nums[child]) &#123;</span><br><span class="line">                    <span class="keyword">int</span> ttemp = nums[loc];</span><br><span class="line">                    nums[loc] = nums[child];</span><br><span class="line">                    nums[child] = ttemp;</span><br><span class="line">                    loc = child;</span><br><span class="line">                &#125; <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="4-选择排序selection-sort"><a href="#4-选择排序selection-sort" class="headerlink" title="4. 选择排序selection sort"></a>4. 选择排序selection sort</h2><p>每次选最大的，交换到最后面。<del>稳定排序</del>，时间<code>O(n^2)</code>，空间可原地排<code>O(n)</code>。<br>选择排序是不稳定的，之前只考虑到了<code>5,5,2,2</code>选择后面的<code>5</code>与<code>2</code>交换，却没想到后面的<code>2</code>被换到了前面。  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">sortArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> left = n; left &gt; <span class="number">1</span>; left--) &#123;</span><br><span class="line">            <span class="keyword">int</span> maxIndex = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// bool sorted = true;</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; left; i++) &#123;</span><br><span class="line">                maxIndex = nums[i] &gt;= nums[maxIndex] ? i : maxIndex;</span><br><span class="line">                <span class="comment">// if (maxIndex != i)</span></span><br><span class="line">                <span class="comment">//     sorted = false;</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// if (sorted)</span></span><br><span class="line">            <span class="comment">//     return nums;</span></span><br><span class="line">            swap(nums[maxIndex], nums[left - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>及时终止的选择排序：当数据已有序时，上述代码仍需要每次遍历比较，浪费时间。<br>判断有序的条件就是，当在一次找最大值索引的过程中，该索引一直在变化，说明已有序。<br>代码以注释的形式添加进上述代码中。  </p>
<h2 id="5-冒泡排序bubble-sort"><a href="#5-冒泡排序bubble-sort" class="headerlink" title="5. 冒泡排序bubble sort"></a>5. 冒泡排序bubble sort</h2><p>通过交换把最大值冒泡到最右侧。时间<code>O(n^2)</code>，空间原地重排<code>O(n)</code>，稳定排序。<br>缺点是需要大量的交换操作，最差需要<code>O(n^2)</code>次（当序列为从大到小时）<br>及时终止的冒泡排序：当一次循环中一直没有交换，说明已有序。同样以注释方式展示。  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">sortArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> left = n; left &gt; <span class="number">1</span>; left--) &#123;</span><br><span class="line">            <span class="comment">// int sorted = true;</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; left - <span class="number">1</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] &gt; nums[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                    swap(nums[i], nums[i + <span class="number">1</span>]);</span><br><span class="line">                    <span class="comment">// sorted = false;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// if (sorted)</span></span><br><span class="line">            <span class="comment">//     return nums;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="6-插入排序insertion-sort"><a href="#6-插入排序insertion-sort" class="headerlink" title="6. 插入排序insertion sort"></a>6. 插入排序insertion sort</h2><p>将右侧无序部分的最左侧的数据插入到左侧有序部分的对应位置，时间<code>O(n^2)</code>，空间原地重排<code>O(n)</code>，稳定排序。<br>插入方法是左侧有序部分的右侧数据不断向右移动，直到找到数据应该在的位置，并且已为其空出位置。  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">sortArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> value = nums[i];</span><br><span class="line">            <span class="keyword">int</span> loc = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[j] &gt; value) &#123;</span><br><span class="line">                    nums[j + <span class="number">1</span>] = nums[j];</span><br><span class="line">                    loc = j;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    loc = j + <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            nums[loc] = value;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="7-归并排序merge-sort"><a href="#7-归并排序merge-sort" class="headerlink" title="7. 归并排序merge sort"></a>7. 归并排序merge sort</h2><p>分治的思想，先拆分后合并。<br><img src="merge_sort.png" alt="merge_sort"><br>时间<a href="https://www.jianshu.com/p/dfcfe667687b"><code>O(nlogn)</code></a>，空间<code>O(n)</code>（借助辅助数组），稳定排序。<br>以下是递归实现，递归过程相当于排左半部分，排右半部分，然后将两部分合并。  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">sortArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">temp</span><span class="params">(nums.size())</span></span>;</span><br><span class="line">        mergeSort(nums, temp, <span class="number">0</span>, nums.size() - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; temp, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left &gt;= right)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        mergeSort(nums, temp, left, mid);        <span class="comment">// 排左半部分</span></span><br><span class="line">        mergeSort(nums, temp, mid + <span class="number">1</span>, right);   <span class="comment">// 排右半部分</span></span><br><span class="line">        merge(nums, temp, left, mid, right);     <span class="comment">// 合并有序的左右两部分</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; temp, <span class="keyword">int</span> left, <span class="keyword">int</span> mid, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &lt;= nums[mid + <span class="number">1</span>])     <span class="comment">// 已有序</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 为了避免频繁的临时数组的构造和析构，使用一个大的临时数组记录排序过程得到的结果，最后赋给nums即可</span></span><br><span class="line">        <span class="comment">// 修改之后，时间和空间的提升还是很大的。</span></span><br><span class="line">        <span class="comment">// vector&lt;int&gt; leftSubArray(nums.begin() + left, nums.begin() + mid + 1);</span></span><br><span class="line">        <span class="comment">// vector&lt;int&gt; rightSubArray(nums.begin() + mid + 1, nums.begin() + right + 1);</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i = left, j = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = left; k &lt;= right; k++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; mid)</span><br><span class="line">                temp[k] = nums[j++];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (j &gt; right)</span><br><span class="line">                temp[k] = nums[i++];</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] &lt;= nums[j])</span><br><span class="line">                    temp[k] = nums[i++];</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    temp[k] = nums[j++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = left; k &lt;= right; k++)</span><br><span class="line">            nums[k] = temp[k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>以下是迭代实现，迭代实现可以循环步长，1, 2, 4, 8, …代表每次合并的子数组的大小。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">sortArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        mergeSort(nums);</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">temp</span><span class="params">(n)</span></span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i *= <span class="number">2</span>) &#123;			<span class="comment">// 每次合并的两个子数组各自的大小</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j += <span class="number">2</span> * i) &#123;	<span class="comment">// 每一组要两两合并的子数组的索引</span></span><br><span class="line">                <span class="keyword">int</span> left = j, right = min(j + <span class="number">2</span> * i - <span class="number">1</span>, n - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">int</span> mid = min(left + i, n - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">int</span> leftHead = left, rightHead = mid;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">int</span> k = left;</span><br><span class="line">                <span class="keyword">while</span> (leftHead &lt; mid || rightHead &lt;= right) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (leftHead &gt;= mid)</span><br><span class="line">                        temp[k++] = nums[rightHead++];</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (rightHead &gt; right)</span><br><span class="line">                        temp[k++] = nums[leftHead++];</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (nums[leftHead] &lt;= nums[rightHead])</span><br><span class="line">                            temp[k++] = nums[leftHead++];</span><br><span class="line">                        <span class="keyword">else</span> </span><br><span class="line">                            temp[k++] = nums[rightHead++];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">                nums[j] = temp[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="8-快速排序quick-sort"><a href="#8-快速排序quick-sort" class="headerlink" title="8. 快速排序quick sort"></a>8. 快速排序quick sort</h2><p>快速排序是不稳定的排序算法，时间平均是<code>O(nlongn)</code>，空间复杂度是<code>O(n)</code>。</p>
<p>快速排序是交换排序，跟冒泡排序是一样的。而冒泡排序之所以时间是<code>O(n^2)</code>，是因为冒泡排序的每一轮都只会set一个最大值；而快速排序的第i轮可以set<code>2^i</code>个<code>pivot</code>，平均只需要logn轮即可完成。</p>
<p>快速排序使用分治的思想：</p>
<ol>
<li>在数组中选择一个基准值</li>
<li>将小于基准值的元素放在基准值的左侧，大于基准值的元素放在基准值的右侧。（相等的可以放在任意一侧）</li>
<li>对基准值左侧和右侧的部分分别进行上述操作。</li>
</ol>
<p>因此快速排序的每一轮实际上就是将<code>pivot</code>放在它该在的位置上的过程，因为左侧的值都小于等于它，右侧的值都大于等于它。</p>
<p>所以问题主要就是，如何选择基准值以及如何将小于和大于基准值的元素放在左右两侧。</p>
<ul>
<li><p><strong>基准值的选择</strong></p>
<p>基准值可以随意选择，也可以指定是数组的第一个或者最后一个元素。</p>
<p>如果选择的不是最后一个元素，可以将<code>pivot</code>与最后一个元素交换，这样问题就全都是最后一个元素是<code>pivot</code>的状态了。</p>
</li>
<li><p><strong>如何将小于和大于基准值的数据分别放在基准值的左右两侧？</strong></p>
<p>使用双指针，假设<code>pivot</code>取的最后一个元素或者是被交换到了最后一个元素的位置。</p>
<p>双指针<code>i</code>和<code>j</code>分别指向数组的开头<code>0</code>和结尾<code>n-1</code>，首先向右移动<code>i</code>找到大于<code>pivot</code>的第一个元素，然后右侧指针<code>j</code>向左移动找到小于<code>pivot</code>的第一个元素，交换二者的值，则实现了小值到右侧，大值到左侧的目的。</p>
<p>然后<code>i</code>和<code>j</code>继续移动，寻找下一个大于和小于<code>pivot</code>的元素，直到二者相遇。</p>
<p>当二者相遇时，交换相遇点和<code>pivot</code>的值，就成功将小于基准值的数据放在了左侧，大于的数据放在了右侧。原因是每次都是首先向右移动<code>i</code>，所以相遇点一定是大于<code>pivot</code>的元素，最后一次交换正好将大于基准值的元素移动到了最右侧，<code>pivot</code>移动到了中间位置。</p>
<p>这也是要求每次首先移动<code>i</code>的原因，否则如果首先移动的是<code>j</code>，则相遇点是小于<code>pivot</code>的元素，在与<code>pivot</code>交换位置之后得到的就是<code>小小小pivot大大大小</code>的序列了。</p>
</li>
</ul>
<p>递归实现：快排将<code>pivot</code>set到该在的位置，然后快排由<code>pivot</code>分开的左侧和右侧部分。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">sortArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        quickSort(nums, <span class="number">0</span>, nums.size() - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> begin, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (begin &gt;= end)		<span class="comment">// 边界条件</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> pivot = end;		<span class="comment">// 取最后一个元素作为pivot</span></span><br><span class="line">        <span class="keyword">int</span> i = begin, j = end;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (i &lt;= j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == j) &#123;		<span class="comment">// i和j指针相遇</span></span><br><span class="line">                swap(nums[i], nums[pivot]);</span><br><span class="line">                pivot = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &lt;= nums[pivot])			<span class="comment">// 首先从左侧找一个大于pivot的值</span></span><br><span class="line">                i++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[j] &gt;= nums[pivot])	<span class="comment">// 然后从右侧找一个小于pivot的值</span></span><br><span class="line">                j--;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                swap(nums[i], nums[j]);			<span class="comment">// 二者都找到时交换位置</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        quickSort(nums, begin, pivot - <span class="number">1</span>);		<span class="comment">// 这个时候pivot已经被set到它该在的位置了</span></span><br><span class="line">        quickSort(nums, pivot + <span class="number">1</span>, end);		<span class="comment">// 递归实现对左右两部分的快速排序</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>非递归实现：使用栈记录待排数据的左右范围，每次从栈中获得范围后进行排序。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">sortArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        quickSort(nums);</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; st;</span><br><span class="line">        st.emplace(<span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">while</span> (!st.empty()) &#123;</span><br><span class="line">            <span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; part = st.top();</span><br><span class="line">            st.pop();</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">int</span> pivot = part.second;</span><br><span class="line">            <span class="keyword">int</span> i = part.first, j = pivot;</span><br><span class="line">            <span class="keyword">while</span> (i &lt;= j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == j) &#123;</span><br><span class="line">                    swap(nums[i], nums[pivot]);</span><br><span class="line">                    pivot = i;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] &lt;= nums[pivot])</span><br><span class="line">                    i++;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (nums[j] &gt;= nums[pivot])</span><br><span class="line">                    j--;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    swap(nums[i], nums[j]);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (part.second &gt; pivot + <span class="number">1</span>)</span><br><span class="line">                st.emplace(pivot + <span class="number">1</span>, part.second);</span><br><span class="line">            <span class="keyword">if</span> (part.first &lt; pivot - <span class="number">1</span>)</span><br><span class="line">                st.emplace(part.first, pivot - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="9-希尔排序shell-sort"><a href="#9-希尔排序shell-sort" class="headerlink" title="9. 希尔排序shell sort"></a>9. 希尔排序shell sort</h2><p>希尔排序是对直接插入排序的改进，相比于直接插入排序，希尔排序首先将元素分为若干组，对每组做插入排序，然后减少组的个数（增大组的容量），形成新的组，再在新的组中进行插入排序，直到整个待排数组成为一个组。</p>
<p>希尔排序是基于插入排序的以下两点性质而提出改进方法的：</p>
<ul>
<li>插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率</li>
<li>但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位</li>
</ul>
<p>希尔排序需要选择步长，代表当前分组个数，当步长为1时，即整个待排数组作为一个分组。排序的时间复杂度取决于步长的选择。</p>
<p>步长默认可以选择<code>n/2</code>，然后每次步长修改为原来的<code>1/2</code>。</p>
<p>希尔排序是不稳定的排序，因为在分组进行插入排序时，可能将后面的值插入到前面。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">sortArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        shellSort(nums);</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> step = n / <span class="number">2</span>; step &gt; <span class="number">0</span>; step /= <span class="number">2</span>) &#123;		<span class="comment">// 步长</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; step; i++) &#123;				<span class="comment">// 组号</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = i + step; j &lt; n; j += step) &#123;	<span class="comment">// 同组的各元素</span></span><br><span class="line">                    <span class="keyword">int</span> num = nums[j], loc = j;</span><br><span class="line">                    <span class="keyword">while</span> (loc - step &gt;= <span class="number">0</span> &amp;&amp; num &lt; nums[loc - step]) &#123;</span><br><span class="line">                        nums[loc] = nums[loc - step];</span><br><span class="line">                        loc -= step;</span><br><span class="line">                    &#125;</span><br><span class="line">                    nums[loc] = num;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>925.长按键入</title>
    <url>/long-pressed-name/</url>
    <content><![CDATA[<h2 id="1-模拟"><a href="#1-模拟" class="headerlink" title="1. 模拟"></a>1. 模拟</h2><p>两个指针分别指向<code>name</code>和<code>typed</code>即可。<br>时间<code>O(m + n)</code>，空间<code>O(1)</code>。  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isLongPressedName</span><span class="params">(<span class="built_in">string</span> name, <span class="built_in">string</span> typed)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> nameLen = name.length(), typedLen = typed.length();</span><br><span class="line">        <span class="keyword">int</span> nameIdx = <span class="number">0</span>, typedIdx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">bool</span> res = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (res &amp;&amp; (nameIdx &lt; nameLen || typedIdx &lt; typedLen)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nameIdx == nameLen) &#123;</span><br><span class="line">                <span class="keyword">if</span> (typedIdx == <span class="number">0</span>) </span><br><span class="line">                    res = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">while</span> (typedIdx &lt; typedLen) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (typed[typedIdx] == typed[typedIdx - <span class="number">1</span>])</span><br><span class="line">                            typedIdx++;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            res = <span class="literal">false</span>;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (typedIdx == typedLen)</span><br><span class="line">                res = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (name[nameIdx] == typed[typedIdx]) &#123;</span><br><span class="line">                    nameIdx++;</span><br><span class="line">                    typedIdx++;</span><br><span class="line">                    <span class="keyword">if</span> (nameIdx &lt; nameLen &amp;&amp; name[nameIdx] != name[nameIdx - <span class="number">1</span>]) &#123;</span><br><span class="line">                        <span class="keyword">while</span> (typedIdx &lt; typedLen &amp;&amp; typed[typedIdx] == typed[typedIdx - <span class="number">1</span>])</span><br><span class="line">                            typedIdx++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span></span><br><span class="line">                    res = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>844.比较含退格的字符串</title>
    <url>/backspace-string-compare/</url>
    <content><![CDATA[<h2 id="1-模拟"><a href="#1-模拟" class="headerlink" title="1. 模拟"></a>1. 模拟</h2><p>直接在原有字符串上进行修改，当遇到<code>#</code>时，把其左侧的第一个非<code>#</code>修改为<code>#</code>，表示已删除。<br>为了更快的找到左侧第一个非<code>#</code>字符，而不是每次都要–遍历，可以直接逆序修改。<br>时间<code>O(n)</code>，空间<code>O(1)</code>。  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">backspaceCompare</span><span class="params">(<span class="built_in">string</span> S, <span class="built_in">string</span> T)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sLen = S.length(), tLen = T.length();</span><br><span class="line">        <span class="keyword">int</span> sCount = <span class="number">0</span>, tCount = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">bool</span> ans = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = sLen - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sCount &gt; <span class="number">0</span> &amp;&amp; S[i] != <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line">                S[i] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">                sCount--;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (S[i] == <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">                sCount++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = tLen - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tCount &gt; <span class="number">0</span> &amp;&amp; T[i] != <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line">                T[i] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">                tCount--;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (T[i] == <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">                tCount++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> sidx = <span class="number">0</span>, tidx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (sidx &lt; sLen || tidx &lt; tLen) &#123;</span><br><span class="line">            <span class="keyword">while</span> (sidx &lt; sLen &amp;&amp; S[sidx] == <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">                sidx++;</span><br><span class="line">            <span class="keyword">while</span> (tidx &lt; tLen &amp;&amp; T[tidx] == <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">                tidx++;</span><br><span class="line">            <span class="keyword">if</span> ((sidx == sLen &amp;&amp; tidx &lt; tLen) || (sidx &lt; sLen &amp;&amp; tidx == tLen)) &#123;</span><br><span class="line">                ans = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sidx &lt; sLen &amp;&amp; tidx &lt; tLen) &#123;</span><br><span class="line">                <span class="keyword">if</span> (S[sidx++] != T[tidx++]) &#123;</span><br><span class="line">                    ans = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>977.有序数组的平方</title>
    <url>/squares-of-a-sorted-array/</url>
    <content><![CDATA[<h2 id="1-双指针"><a href="#1-双指针" class="headerlink" title="1. 双指针"></a>1. 双指针</h2><p>首先找到正数和负数的分界点，然后二者根据各自指向的值的平方大小向左向右移动。<br>时间<code>O(n)</code>，空间<code>O(1)</code>。  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">sortedSquares</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = A.size();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> neg, pos, sep, count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (sep = <span class="number">0</span>; sep &lt; n; ++sep)</span><br><span class="line">            <span class="keyword">if</span> (A[sep] &gt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        neg = sep - <span class="number">1</span>;</span><br><span class="line">        pos = sep;</span><br><span class="line">        <span class="keyword">while</span> (count &lt; n) &#123;</span><br><span class="line">            <span class="keyword">int</span> val;</span><br><span class="line">            <span class="keyword">if</span> (neg &gt;= <span class="number">0</span> &amp;&amp; pos &lt; n) &#123;</span><br><span class="line">                <span class="keyword">if</span> (-A[neg] &lt;= A[pos]) </span><br><span class="line">                    val = A[neg--];</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    val = A[pos++];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (neg &gt;= <span class="number">0</span>)</span><br><span class="line">                val = A[neg--];</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                val = A[pos++];</span><br><span class="line">            res[count++] = val * val;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>[转载]C++中的虚函数(表)实现机制以及用C语言对其进行的模拟实现</title>
    <url>/reproduction-cpp-virtual-function-table/</url>
    <content><![CDATA[<p>本篇博客全文转载自<a href="https://blog.twofei.com/496/">https://blog.twofei.com/496/</a></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>大家都应该知道C++的精髓是虚函数吧? 虚函数带来的好处就是: 可以定义一个基类的指针, 其指向一个继承类, 当通过基类的指针去调用函数时, 可以在运行时决定该调用基类的函数还是继承类的函数. 虚函数是实现多态(动态绑定)/接口函数的基础. 可以说: 没有虚函数, C++将变得一无是处!</p>
<p>既然是C++的精髓, 那么我们有必要了解一下她的实现方式吗? 有必要! 既然C++是从C语言的基础上发展而来的, 那么我们可以尝试用C语言来模拟实现吗? 有可能! 接下来, 就是我一步一步地来解析C++的虚函数的实现方式, 以及用C语言对其进行的模拟.</p>
<h2 id="C-对象的内存布局"><a href="#C-对象的内存布局" class="headerlink" title="C++对象的内存布局"></a>C++对象的内存布局</h2><p>要想知道C++对象的内存布局, 可以有多种方式, 比如:</p>
<ol>
<li>输出成员变量的偏移, 通过offsetof宏来得到</li>
<li>通过调试器查看, 比如常用的VS</li>
</ol>
<ol>
<li><h3 id="只有数据成员的对象"><a href="#只有数据成员的对象" class="headerlink" title="只有数据成员的对象"></a>只有数据成员的对象</h3><p>类实现如下:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> base1_1;</span><br><span class="line">    <span class="keyword">int</span> base1_2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>对象大小及偏移:</p>
<table>
<thead>
<tr>
<th>sizeof(Base1)</th>
<th>8</th>
</tr>
</thead>
<tbody><tr>
<td>offsetof(Base1, base1_1)</td>
<td>0</td>
</tr>
<tr>
<td>offsetof(Base1, base1_2)</td>
<td>4</td>
</tr>
</tbody></table>
<p>可知对象布局:</p>
<p><img src="1-1.png" alt="img"></p>
<p>可以看到, 成员变量是按照定义的顺序来保存的, 最先声明的在最上边, 然后依次保存!<br>类对象的大小就是所有成员变量大小之和.</p>
</li>
<li><h3 id="没有虚函数的对象"><a href="#没有虚函数的对象" class="headerlink" title="没有虚函数的对象"></a>没有虚函数的对象</h3><p>类实现如下:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> base1_1;</span><br><span class="line">    <span class="keyword">int</span> base1_2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>结果如下:</p>
<table>
<thead>
<tr>
<th>sizeof(Base1)</th>
<th>8</th>
</tr>
</thead>
<tbody><tr>
<td>offsetof(Base1, base1_1)</td>
<td>0</td>
</tr>
<tr>
<td>offsetof(Base1, base1_2)</td>
<td>4</td>
</tr>
</tbody></table>
<p>和前面的结果是一样的? 不需要有什么疑问对吧?<br>因为如果一个函数不是虚函数,那么他就不可能会发生动态绑定,也就不会对对象的布局造成任何影响.<br>当调用一个非虚函数时, 那么调用的一定就是当前指针类型拥有的那个成员函数. 这种调用机制在编译时期就确定下来了.</p>
</li>
<li><h3 id="拥有仅一个虚函数的类对象"><a href="#拥有仅一个虚函数的类对象" class="headerlink" title="拥有仅一个虚函数的类对象"></a>拥有仅一个虚函数的类对象</h3><p>类实现如下:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> base1_1;</span><br><span class="line">    <span class="keyword">int</span> base1_2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">base1_fun1</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>结果如下:</p>
<table>
<thead>
<tr>
<th>sizeof(Base1)</th>
<th>12</th>
</tr>
</thead>
<tbody><tr>
<td>offsetof(Base1, base1_1)</td>
<td>4</td>
</tr>
<tr>
<td>offsetof(Base1, base1_2)</td>
<td>8</td>
</tr>
</tbody></table>
<p>咦? 多了4个字节? 且 base1_1 和 base1_2 的偏移都各自向后多了4个字节!<br>说明类对象的最前面被多加了4个字节的”东东”, what’s it?<br>现在, 我们通过VS2013来瞧瞧类Base1的变量b1的内存布局情况:<br>(由于我没有写构造函数, 所以变量的数据没有根据, 但虚函数是编译器为我们构造的, 数据正确!)<br>(Debug模式下, 未初始化的变量值为<code>0xCCCCCCCC</code>, 即:<code>-858983460</code>)</p>
<p><img src="3-1.png" alt="img"></p>
<p>看到没? base1_1前面多了一个变量 __vfptr(常说的虚函数表vtable指针), 其类型为void*<em>, 这说明它是一个void</em>指针(**注意:**不是数组).</p>
<p>再看看[0]元素, 其类型为void*, 其值为 ConsoleApplication2.exe!Base1::base1_fun1(void), 这是什么意思呢? 如果对WinDbg比较熟悉, 那么应该知道这是一种惯用表示手法, 她就是指 Base1::base1_fun1() 函数的地址.</p>
<p>可得, __vfptr的定义伪代码大概如下:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span>*   __fun[<span class="number">1</span>] = &#123; &amp;Base1::base1_fun1 &#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">void</span>**  __vfptr = &amp;__fun[<span class="number">0</span>];</span><br></pre></td></tr></table></figure>

<p>值得注意的是:</p>
<ol>
<li><p>上面只是一种伪代码方式, 语法不一定能通过</p>
</li>
<li><p>该类的对象大小为12个字节, 大小及偏移信息如下:</p>
<table>
<thead>
<tr>
<th>sizeof(Base1)</th>
<th>12</th>
</tr>
</thead>
<tbody><tr>
<td>offsetof(__vfptr)</td>
<td>0</td>
</tr>
<tr>
<td>offsetof(base1_1)</td>
<td>4</td>
</tr>
<tr>
<td>offsetof(base1_2)</td>
<td>8</td>
</tr>
</tbody></table>
</li>
<li><p>大家有没有留意这个__vfptr? 为什么它被定义成一个指向指针数组的指针, 而不是直接定义成一个指针数组呢?</p>
<p>我为什么要提这样一个问题? 因为如果仅是一个指针的情况, 您就无法轻易地修改那个数组里面的内容, 因为她并不属于类对象的一部分.<br>属于类对象的, 仅是一个指向<strong>虚函数表的一个指针__vfptr</strong>而已, 下一节我们将继续讨论这个问题.</p>
</li>
<li><p>注意到__vfptr前面的const修饰. 她修饰的是那个虚函数表, 而不是__vfptr.</p>
</li>
</ol>
<p>现在的对象布局如下:</p>
<p><img src="3-2.png" alt="img"></p>
<p>虚函数指针__vfptr位于所有的成员变量之前定义.</p>
<p>注意到: 我并未在此说明__vfptr的具体指向, 只是说明了现在类对象的布局情况.<br>接下来看一个稍微复杂一点的情况, 我将清楚地描述虚函数表的构成.</p>
</li>
<li><h3 id="拥有多个虚函数的类对象"><a href="#拥有多个虚函数的类对象" class="headerlink" title="拥有多个虚函数的类对象"></a>拥有多个虚函数的类对象</h3><p>和前面一个例子差不多, 只是再加了一个虚函数. 定义如下:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> base1_1;</span><br><span class="line">    <span class="keyword">int</span> base1_2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">base1_fun1</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">base1_fun2</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>大小以及偏移信息如下:</p>
<p><img src="4-1.png" alt="img"></p>
<p>有情况!? 多了一个虚函数, 类对象大小却依然是12个字节!</p>
<p>再来看看VS形象的表现:</p>
<p><img src="4-2.png" alt="img"></p>
<p>呀, __vfptr所指向的函数指针数组中出现了第2个元素, 其值为Base1类的第2个虚函数base1_fun2()的函数地址.</p>
<p>现在, 虚函数指针以及虚函数表的伪定义大概如下:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span>* __fun[] = &#123; &amp;Base1::base1_fun1, &amp;Base1::base1_fun2 &#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">void</span>** __vfptr = &amp;__fun[<span class="number">0</span>];</span><br></pre></td></tr></table></figure>

<p>通过上面两张图表, 我们可以得到如下结论:</p>
<ol>
<li>更加肯定前面我们所描述的: __vfptr只是一个指针, 她指向一个函数指针数组(即: 虚函数表)</li>
<li>增加一个虚函数, 只是简单地向该类对应的虚函数表中增加一项而已, 并不会影响到类对象的大小以及布局情况</li>
</ol>
<p>前面已经提到过: __vfptr只是一个指针, 她指向一个数组, 并且: 这个数组没有包含到类定义内部, 那么她们之间是怎样一个关系呢?<br>不妨, 我们再定义一个类的变量b2, 现在再来看看__vfptr的指向:</p>
<p><img src="4-3.png" alt="img"></p>
<p>通过Watch 1窗口我们看到:</p>
<ol>
<li>b1和b2是类的两个变量, 理所当然, 她们的地址是不同的(见 &amp;b1 和 &amp;b2)</li>
<li>虽然b1和b2是类的两个变量, 但是: 她们的__vfptr的指向却是同一个虚函数表</li>
</ol>
<p>由此我们可以总结出:</p>
<p>同一个类的不同实例共用同一份虚函数表, 她们都通过一个所谓的虚函数表指针__vfptr(定义为void**类型)指向该虚函数表.</p>
<p>是时候该展示一下类对象的内存布局情况了:</p>
<p><img src="4-4.png" alt="img"></p>
<p>不出意外, 很清晰明了地展示出来了吧? :-) hoho~~</p>
<p>那么问题就来了! 这个虚函数表保存在哪里呢? 其实, 我们无需过分追究她位于哪里, 重点是:</p>
<ol>
<li>她是编译器在<strong>编译时期</strong>为我们创建好的, 只存在一份</li>
<li>定义类对象时, 编译器自动将类对象的__vfptr指向这个虚函数表</li>
</ol>
</li>
<li><h3 id="单继承且本身不存在虚函数的继承类的内存布局"><a href="#单继承且本身不存在虚函数的继承类的内存布局" class="headerlink" title="单继承且本身不存在虚函数的继承类的内存布局"></a>单继承且本身不存在虚函数的继承类的内存布局</h3><p>前面研究了那么多啦, 终于该到研究继承类了! 先研究单继承!</p>
<p>依然, 简单地定义一个继承类, 如下:</p>
<figure class="highlight cc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> base1_1;</span><br><span class="line">    <span class="keyword">int</span> base1_2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">base1_fun1</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">base1_fun2</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derive1</span> :</span> <span class="keyword">public</span> Base1</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> derive1_1;</span><br><span class="line">    <span class="keyword">int</span> derive1_2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我们再来看看现在的内存布局(定义为Derive1 d1):</p>
<p><img src="5-1.png" alt="img"></p>
<p>没错! 基类在上边, 继承类的成员在下边依次定义! 展开来看看:</p>
<p><img src="5-2.png" alt="img"></p>
<p>经展开后来看, 前面部分完全就是Base1的东西: 虚函数表指针+成员变量定义.<br>并且, Base1的虚函数表的[0][1]两项还是其本身就拥有的函数: base1_fun1() 和 base1_fun2().</p>
<p>现在类的布局情况应该是下面这样:</p>
<p><img src="5-3.png" alt="img"></p>
</li>
<li><h3 id="本身不存在虚函数-不严谨-但存在基类虚函数覆盖的单继承类的内存布局"><a href="#本身不存在虚函数-不严谨-但存在基类虚函数覆盖的单继承类的内存布局" class="headerlink" title="本身不存在虚函数(不严谨)但存在基类虚函数覆盖的单继承类的内存布局"></a>本身不存在虚函数(不严谨)但存在基类虚函数覆盖的单继承类的内存布局</h3><p>标题<code>本身不存在虚函数</code>的说法有些不严谨, 我的意思是说: 除经过继承而得来的基类虚函数以外, 自身没有再定义其它的虚函数.</p>
<p>Ok, 既然存在基类虚函数覆盖, 那么来看看接下来的代码会产生何种影响:</p>
<figure class="highlight cc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> base1_1;</span><br><span class="line">    <span class="keyword">int</span> base1_2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">base1_fun1</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">base1_fun2</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derive1</span> :</span> <span class="keyword">public</span> Base1</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> derive1_1;</span><br><span class="line">    <span class="keyword">int</span> derive1_2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 覆盖基类函数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">base1_fun1</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>可以看到, Derive1类 重写了Base1类的base1_fun1()函数, 也就是常说的虚函数覆盖. 现在是怎样布局的呢?</p>
<p><img src="6-1.png" alt="img"></p>
<p>特别注意我高亮的那一行: 原本是Base1::base1_fun1(), 但由于<strong>继承类重写</strong>了基类Base1的此方法, 所以现在变成了Derive1::base1_fun1()!</p>
<p>那么, 无论是通过Derive1的指针还是Base1的指针来调用此方法, 调用的都将是被继承类重写后的那个方法(函数), 多态发生鸟!!!</p>
<p>那么新的布局图:</p>
<p><img src="6-2.png" alt="img"></p>
</li>
<li><h3 id="定义了基类没有的虚函数的单继承的类对象布局"><a href="#定义了基类没有的虚函数的单继承的类对象布局" class="headerlink" title="定义了基类没有的虚函数的单继承的类对象布局"></a>定义了基类没有的虚函数的单继承的类对象布局</h3><p>说明一下: 由于前面一种情况只会造成覆盖基类虚函数表的指针, 所以接下来我不再同时讨论虚函数覆盖的情况.</p>
<p>继续贴代码:</p>
<figure class="highlight cc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> base1_1;</span><br><span class="line">    <span class="keyword">int</span> base1_2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">base1_fun1</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">base1_fun2</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derive1</span> :</span> <span class="keyword">public</span> Base1</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> derive1_1;</span><br><span class="line">    <span class="keyword">int</span> derive1_2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">derive1_fun1</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>和第5类不同的是多了一个自身定义的虚函数. 和第6类不同的是没有基类虚函数的覆盖.</p>
<p><img src="7-1.png" alt="img"></p>
<p>咦, 有没有发现问题? 表面上看来几乎和第5种情况完全一样? 为嘛呢?<br>现在继承类明明定义了自身的虚函数, 但不见了??<br>那么, 来看看类对象的大小, 以及成员偏移情况吧:</p>
<p><img src="7-2.png" alt="img"></p>
<p>居然没有变化!!! 前面12个字节是Base1的, 有没有觉得很奇怪?</p>
<p>好吧, 既然表面上没办法了, 我们就只能从汇编入手了, 来看看调用derive1_fun1()时的代码:</p>
<figure class="highlight cc"><table><tr><td class="code"><pre><span class="line">Derive1 d1;</span><br><span class="line">Derive1* pd1 = &amp;d1;</span><br><span class="line">pd1-&gt;derive1_fun1();</span><br></pre></td></tr></table></figure>

<p>要注意: 我为什么使用指针的方式调用? 说明一下: 因为如果不使用指针调用, 虚函数调用是不会发生动态绑定的哦! 你若直接 <code>d1.derive1_fun1();</code> , 是不可能会发生动态绑定的, 但如果使用指针: <code>pd1-&gt;derive1_fun1();</code> , 那么 pd1就无从知道她所指向的对象到底是Derive1 还是继承于Derive1的对象, 虽然这里我们并没有对象继承于Derive1, 但是她不得不这样做, 毕竟继承类不管你如何继承, 都不会影响到基类, 对吧?</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="comment">; pd1-&gt;derive1_fun1();</span></span><br><span class="line"><span class="number">00825466</span>  <span class="keyword">mov</span>         <span class="built_in">eax</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> [pd1]  </span><br><span class="line"><span class="number">00825469</span>  <span class="keyword">mov</span>         <span class="built_in">edx</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">eax</span>]  </span><br><span class="line">0082546B  <span class="keyword">mov</span>         <span class="built_in">esi</span>,<span class="built_in">esp</span>  </span><br><span class="line"><span class="number">0082546D</span>  <span class="keyword">mov</span>         <span class="built_in">ecx</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> [pd1]  </span><br><span class="line"><span class="number">00825470</span>  <span class="keyword">mov</span>         <span class="built_in">eax</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">edx</span>+<span class="number">8</span>]  </span><br><span class="line"><span class="number">00825473</span>  <span class="keyword">call</span>        <span class="built_in">eax</span></span><br></pre></td></tr></table></figure>

<p>汇编代码解释:</p>
<p>第2行: 由于pd1是指向d1的指针, 所以执行此句后 eax 就是<strong>d1的地址</strong><br>第3行: 又因为Base1::__vfptr是Base1的第1个成员, 同时也是Derive1的第1个成员, 那么: &amp;__vfptr == &amp;d1, clear? 所以当执行完 <code>mov edx, dword ptr[eax]</code> 后, edx就得到了__vfptr的值, 也就是<strong>虚函数表的地址</strong>.<br>第5行: 由于是__thiscall调用, 所以把this保存到ecx中.<br>第6行: 一定要注意到那个 edx+8, 由于edx是虚函数表的地址, 那么 edx+8将是虚函数表的第3个元素, 也就是__vftable[2]!!!<br>第7行: 调用虚函数.</p>
<p>结果:</p>
<ol>
<li>现在我们应该知道内幕了! 继承类Derive1的虚函数表被加在基类的后面! 事实的确就是这样!</li>
<li>由于Base1只知道自己的两个虚函数索引[0][1], 所以就算在后面加上了[2], Base1根本不知情, 不会对她造成任何影响.</li>
<li>如果<strong>基类没有虚函数</strong>呢? 这个问题我们留到第9小节再来讨论!</li>
</ol>
<p>最新的类对象布局表示:</p>
<p><img src="7-3.png" alt="img"></p>
</li>
<li><h3 id="多继承且存在虚函数覆盖同时又存在自身定义的虚函数的类对象布局"><a href="#多继承且存在虚函数覆盖同时又存在自身定义的虚函数的类对象布局" class="headerlink" title="多继承且存在虚函数覆盖同时又存在自身定义的虚函数的类对象布局"></a>多继承且存在虚函数覆盖同时又存在自身定义的虚函数的类对象布局</h3><p>真快, 该看看多继承了, 多继承很常见, 特别是接口类中!</p>
<p>依然写点小类玩玩:</p>
<figure class="highlight cc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> base1_1;</span><br><span class="line">    <span class="keyword">int</span> base1_2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">base1_fun1</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">base1_fun2</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base2</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> base2_1;</span><br><span class="line">    <span class="keyword">int</span> base2_2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">base2_fun1</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">base2_fun2</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多继承</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derive1</span> :</span> <span class="keyword">public</span> Base1, <span class="keyword">public</span> Base2</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> derive1_1;</span><br><span class="line">    <span class="keyword">int</span> derive1_2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 基类虚函数覆盖</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">base1_fun1</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">base2_fun2</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自身定义的虚函数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">derive1_fun1</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">derive1_fun2</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>代码变得越来越长啦! 为了代码结构清晰, 我尽量简化定义.</p>
<p>初步了解一下对象大小及偏移信息:</p>
<p><img src="8-1.png" alt="img"></p>
<p>貌似, 若有所思? 不管, 来看看VS再想:</p>
<p><img src="8-2.png" alt="img"></p>
<p>哇, 不摆了! 一丝不挂啊! :-)</p>
<p>结论:</p>
<ol>
<li>按照基类的声明顺序, 基类的成员依次分布在继承中.</li>
<li>注意被我高亮的那两行, 已经发生了虚函数覆盖!</li>
<li>我们自己定义的虚函数呢? 怎么还是看不见?!</li>
</ol>
<p>好吧, 继承反汇编, 这次的调用代码如下:</p>
<figure class="highlight cc"><table><tr><td class="code"><pre><span class="line">Derive1 d1;</span><br><span class="line">Derive1* pd1 = &amp;d1;</span><br><span class="line">pd1-&gt;derive1_fun2();</span><br></pre></td></tr></table></figure>

<p>反汇编代码如下:</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="comment">; pd1-&gt;derive1_fun2();</span></span><br><span class="line"><span class="number">00995306</span>  <span class="keyword">mov</span>         <span class="built_in">eax</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> [pd1]  </span><br><span class="line"><span class="number">00995309</span>  <span class="keyword">mov</span>         <span class="built_in">edx</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">eax</span>]  </span><br><span class="line">0099530B  <span class="keyword">mov</span>         <span class="built_in">esi</span>,<span class="built_in">esp</span>  </span><br><span class="line"><span class="number">0099530D</span>  <span class="keyword">mov</span>         <span class="built_in">ecx</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> [pd1]  </span><br><span class="line"><span class="number">00995310</span>  <span class="keyword">mov</span>         <span class="built_in">eax</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">edx</span>+<span class="number">0Ch</span>]  </span><br><span class="line"><span class="number">00995313</span>  <span class="keyword">call</span>        <span class="built_in">eax</span></span><br></pre></td></tr></table></figure>

<p>解释下, 其实差不多:</p>
<p>第2行: 取d1的地址<br>第3行: 取Base1::__vfptr的值!!<br>第6行: 0x0C, 也就是第4个元素(下标为[3])</p>
<p>结论:</p>
<p>Derive1的虚函数表依然是保存到第1个拥有虚函数表的那个基类的后面的.</p>
<p>看看现在的类对象布局图:</p>
<p>（注：图中有点错误，右上角应该是 <code>void* __vftable[4]</code>，多谢 shadow3002 的提醒）</p>
<p>（注：图中有点错误，Derive1是存在虚函数覆盖的。源图丢失，请读者注意不要被误导。<a href="#comment-577">多谢 Oyster 的提醒</a>）</p>
<p><img src="8-3.png" alt="img"></p>
<p>如果第1个基类没有虚函数表呢? 进入第9节!</p>
</li>
<li><h3 id="如果第1个直接基类没有虚函数-表"><a href="#如果第1个直接基类没有虚函数-表" class="headerlink" title="如果第1个直接基类没有虚函数(表)"></a>如果第1个直接基类没有虚函数(表)</h3><p>这次的代码应该比上一个要稍微简单一些, 因为把第1个类的虚函数给去掉鸟!</p>
<figure class="highlight cc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> base1_1;</span><br><span class="line">    <span class="keyword">int</span> base1_2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base2</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> base2_1;</span><br><span class="line">    <span class="keyword">int</span> base2_2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">base2_fun1</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">base2_fun2</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多继承</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derive1</span> :</span> <span class="keyword">public</span> Base1, <span class="keyword">public</span> Base2</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> derive1_1;</span><br><span class="line">    <span class="keyword">int</span> derive1_2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自身定义的虚函数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">derive1_fun1</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">derive1_fun2</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>来看看VS的布局:</p>
<p><img src="9-1.png" alt="img"></p>
<p>这次相对前面一次的图来说还要简单啦! Base1已经没有虚函数表了! (真实情况并非完全这样, 请继续往下看!)</p>
<p>现在的大小及偏移情况: 注意: <code>sizeof(Base1) == 8;</code></p>
<p><img src="9-2.png" alt="img"></p>
<p>重点是看虚函数的位置, 进入函数调用(和前一次是一样的):</p>
<figure class="highlight cc"><table><tr><td class="code"><pre><span class="line">Derive1 d1;</span><br><span class="line">Derive1* pd1 = &amp;d1;</span><br><span class="line">pd1-&gt;derive1_fun2();</span><br></pre></td></tr></table></figure>

<p>反汇编调用代码:</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="comment">; pd1-&gt;derive1_fun2();</span></span><br><span class="line">012E4BA6  <span class="keyword">mov</span>         <span class="built_in">eax</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> [pd1]  </span><br><span class="line">012E4BA9  <span class="keyword">mov</span>         <span class="built_in">edx</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">eax</span>]  </span><br><span class="line">012E4BAB  <span class="keyword">mov</span>         <span class="built_in">esi</span>,<span class="built_in">esp</span>  </span><br><span class="line">012E4BAD  <span class="keyword">mov</span>         <span class="built_in">ecx</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> [pd1]  </span><br><span class="line">012E4BB0  <span class="keyword">mov</span>         <span class="built_in">eax</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">edx</span>+<span class="number">0Ch</span>]  </span><br><span class="line">012E4BB3  <span class="keyword">call</span>        <span class="built_in">eax</span></span><br></pre></td></tr></table></figure>

<p>这段汇编代码和前面一个完全一样!, 那么问题就来了! Base1 已经没有虚函数表了, 为什么还是把b1的第1个元素当作__vfptr呢?<br>不难猜测: 当前的布局已经发生了变化, 有虚函数表的基类放在对象内存前面!? , 不过事实是否属实? 需要仔细斟酌.</p>
<p>我们可以通过对基类成员变量求偏移来观察:</p>
<p><img src="9-3.png" alt="img"></p>
<p>可以看到:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&amp;d1&#x3D;&#x3D;0x~d4</span><br><span class="line">&amp;d1.Base1::__vfptr&#x3D;&#x3D;0x~d4</span><br><span class="line">&amp;d1.base2_1&#x3D;&#x3D;0x~d8</span><br><span class="line">&amp;d1.base2_2&#x3D;&#x3D;0x~dc</span><br><span class="line">&amp;d1.base1_1&#x3D;&#x3D;0x~e0</span><br><span class="line">&amp;d1.base1_2&#x3D;&#x3D;0x~e4</span><br></pre></td></tr></table></figure>

<p>所以不难验证: 我们前面的推断是正确的, 谁有虚函数表, 谁就放在前面!</p>
<p>现在类的布局情况:</p>
<p><img src="9-4.png" alt="img"></p>
<p>那么, 如果两个基类都没有虚函数表呢?</p>
</li>
<li><h3 id="What-if-两个基类都没有虚函数表"><a href="#What-if-两个基类都没有虚函数表" class="headerlink" title="What if 两个基类都没有虚函数表"></a>What if 两个基类都没有虚函数表</h3><p>代码如下:</p>
<figure class="highlight cc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> base1_1;</span><br><span class="line">    <span class="keyword">int</span> base1_2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base2</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> base2_1;</span><br><span class="line">    <span class="keyword">int</span> base2_2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多继承</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derive1</span> :</span> <span class="keyword">public</span> Base1, <span class="keyword">public</span> Base2</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> derive1_1;</span><br><span class="line">    <span class="keyword">int</span> derive1_2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自身定义的虚函数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">derive1_fun1</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">derive1_fun2</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>前面吃了个亏, 现在先来看看VS的基本布局:</p>
<p><img src="10-1.png" alt="img"></p>
<p>可以看到, 现在__vfptr已经独立出来了, 不再属于Base1和Base2!</p>
<p>看看求偏移情况:</p>
<p><img src="10-2.png" alt="img"></p>
<p>Ok, 问题解决! 注意高亮的那两行, <code>&amp;d1==&amp;d1.__vfptr</code>, 说明虚函数始终在最前面!</p>
<p>不用再废话, 相信大家对这种情况已经有底了.</p>
<p>对象布局:</p>
<p><img src="10-3.png" alt="img"></p>
</li>
<li><h3 id="如果有三个基类-虚函数表分别是有-没有-有"><a href="#如果有三个基类-虚函数表分别是有-没有-有" class="headerlink" title="如果有三个基类: 虚函数表分别是有, 没有, 有!"></a>如果有三个基类: 虚函数表分别是有, 没有, 有!</h3><p>这种情况其实已经无需再讨论了, 作为一个完结篇….</p>
<p>上代码:</p>
<figure class="highlight cc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> base1_1;</span><br><span class="line">    <span class="keyword">int</span> base1_2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">base1_fun1</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">base1_fun2</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base2</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> base2_1;</span><br><span class="line">    <span class="keyword">int</span> base2_2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base3</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> base3_1;</span><br><span class="line">    <span class="keyword">int</span> base3_2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">base3_fun1</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">base3_fun2</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多继承</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derive1</span> :</span> <span class="keyword">public</span> Base1, <span class="keyword">public</span> Base2, <span class="keyword">public</span> Base3</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> derive1_1;</span><br><span class="line">    <span class="keyword">int</span> derive1_2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自身定义的虚函数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">derive1_fun1</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">derive1_fun2</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>以下是偏移图：</p>
<p><img src="11-1.png" alt="img"></p>
<p>以下是对象布局图（多谢 <a href="https://blog.twofei.com/496/#comment-577">@Oyster</a> 的手绘）：</p>
<p><img src="11-2.jpg" alt="img"></p>
<p>只需知道: 谁有虚函数表, 谁就往前靠!</p>
</li>
</ol>
<h2 id="C-中父子对象指针间的转换与函数调用"><a href="#C-中父子对象指针间的转换与函数调用" class="headerlink" title="C++中父子对象指针间的转换与函数调用"></a>C++中父子对象指针间的转换与函数调用</h2><p>讲了那么多布局方面的东东, 终于到了尾声, 好累呀!!!</p>
<p>通过前面的讲解内容, 大家至少应该明白了各类情况下类对象的内存布局了. 如果还不会…..呃….. !@#$%^&amp;*</p>
<p>进入正题~</p>
<p>由于继承完全拥有父类的所有, 包括数据成员与虚函数表, 所以:<strong>把一个继承类强制转换为一个基类</strong>是完全可行的.</p>
<p>如果有一个Derive1的指针, 那么:</p>
<ul>
<li>得到Base1的指针: Base1* pb1 = pd1;</li>
<li>得到Base2的指针: Base2* pb2 = pd1;</li>
<li>得到Base3的指针: Base3* pb3 = pd1;</li>
</ul>
<p>非常值得注意的是:</p>
<p>这是在基类与继承类之间的转换, 这种转换会自动计算偏移! 按照前面的布局方式!<br>也就是说: 在这里极有可能: pb1 != pb2 != pb3 ~~, 不要以为她们都等于 pd1!</p>
<p>至于函数调用, 我想, 不用说大家应该知道了:</p>
<ol>
<li>如果不是虚函数, 直接调用指针对应的基本类的那个函数</li>
<li>如果是虚函数, 则查找虚函数表, 并进行后续的调用. 虚函数表在定义一个时, 编译器就为我们创建好了的. 所有的, 同一个类, 共用同一份虚函数表.</li>
</ol>
<h2 id="用C语言完全模拟C-虚函数表的实现与运作方式"><a href="#用C语言完全模拟C-虚函数表的实现与运作方式" class="headerlink" title="用C语言完全模拟C++虚函数表的实现与运作方式"></a>用C语言完全模拟C++虚函数表的实现与运作方式</h2><p>如果对前面两大节的描述仔细了解了的话, 想用C语言来模拟C++的虚函数以及多态, 想必是轻而易举的事情鸟!</p>
<h3 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h3><p>但是, 话得说在前面, C++的编译器在生成类及对象的时候, 帮助我们完成了很多事件, 比如生成虚函数表!<br>但是, C语言编译器却没有, 因此, 很多事件我们必须手动来完成, 包括但不限于:</p>
<ol>
<li>手动构造父子关系</li>
<li>手动创建虚函数表</li>
<li>手动设置__vfptr并指向虚函数表</li>
<li>手动填充虚函数表</li>
<li>若有虚函数覆盖, 还需手动修改函数指针</li>
<li>若要取得基类指针, 还需手动强制转换</li>
<li>……</li>
</ol>
<p>总之, 要想用C语言来实现, 要写的代码绝对有点复杂.</p>
<h3 id="C-原版调用"><a href="#C-原版调用" class="headerlink" title="C++原版调用"></a>C++原版调用</h3><p>接下来, 我们都将以最后那个, 最繁杂的那个3个基类的实例来讲解, 但作了一些简化与改动:</p>
<ol>
<li>用构造函数初始化成员变量</li>
<li>减少成员变量的个数</li>
<li>减少虚函数的个数</li>
<li>调用函数时产生相关输出</li>
<li>Derive1增加一个基类虚函数覆盖</li>
</ol>
<p>以下是对类的改动, 很少:</p>
<figure class="highlight cc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Base1() : base1_1(<span class="number">11</span>) &#123;&#125;</span><br><span class="line">    <span class="keyword">int</span> base1_1;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">base1_fun1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Base1::base1_fun1()&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base2</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Base2() : base2_1(<span class="number">21</span>) &#123;&#125;</span><br><span class="line">    <span class="keyword">int</span> base2_1;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base3</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Base3() : base3_1(<span class="number">31</span>) &#123;&#125;</span><br><span class="line">    <span class="keyword">int</span> base3_1;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">base3_fun1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Base3::base3_fun1()&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derive1</span> :</span> <span class="keyword">public</span> Base1, <span class="keyword">public</span> Base2, <span class="keyword">public</span> Base3</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Derive1() : derive1_1(<span class="number">11</span>) &#123;&#125;</span><br><span class="line">    <span class="keyword">int</span> derive1_1;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">base3_fun1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Derive1::base3_fun1()&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">derive1_fun1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Derive1::derive1_fun1()&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>为了看到多态的效果, 我们还需要定义一个函数来看效果:</p>
<figure class="highlight cc"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(Base1* pb1, Base2* pb2, Base3* pb3, Derive1* pd1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Base1::\n&quot;</span></span><br><span class="line">        &lt;&lt; <span class="string">&quot;    pb1-&gt;base1_1 = &quot;</span> &lt;&lt; pb1-&gt;base1_1 &lt;&lt; <span class="string">&quot;\n&quot;</span></span><br><span class="line">        &lt;&lt; <span class="string">&quot;    pb1-&gt;base1_fun1(): &quot;</span>;</span><br><span class="line">    pb1-&gt;base1_fun1();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Base2::\n&quot;</span></span><br><span class="line">        &lt;&lt; <span class="string">&quot;    pb2-&gt;base2_1 = &quot;</span> &lt;&lt; pb2-&gt;base2_1</span><br><span class="line">        &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Base3::\n&quot;</span></span><br><span class="line">        &lt;&lt; <span class="string">&quot;    pb3-&gt;base3_1 = &quot;</span> &lt;&lt; pb3-&gt;base3_1 &lt;&lt; <span class="string">&quot;\n&quot;</span></span><br><span class="line">        &lt;&lt;<span class="string">&quot;    pb3-&gt;base3_fun1(): &quot;</span>;</span><br><span class="line">    pb3-&gt;base3_fun1();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Derive1::\n&quot;</span></span><br><span class="line">        &lt;&lt; <span class="string">&quot;    pd1-&gt;derive1_1 = &quot;</span> &lt;&lt; pd1-&gt;derive1_1&lt;&lt; <span class="string">&quot;\n&quot;</span></span><br><span class="line">        &lt;&lt;<span class="string">&quot;    pd1-&gt;derive1_fun1(): &quot;</span>;</span><br><span class="line">    pd1-&gt;derive1_fun1();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt; <span class="string">&quot;    pd1-&gt;base3_fun1(): &quot;</span>;</span><br><span class="line">    pd1-&gt;base3_fun1();</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用方式如下:</p>
<figure class="highlight cc"><table><tr><td class="code"><pre><span class="line">Derive1 d1;</span><br><span class="line">foo(&amp;d1, &amp;d1, &amp;d1, &amp;d1);</span><br></pre></td></tr></table></figure>

<p>输出结果:</p>
<p><img src="c-1.png" alt="img"></p>
<p>可以看到输出结果全部正确(当然了! :-), 哈哈~<br>同时注意到 pb3-&gt;base3_fun1() 的多态效果哦!</p>
<h3 id="用C语言来模拟"><a href="#用C语言来模拟" class="headerlink" title="用C语言来模拟"></a>用C语言来模拟</h3><p>必须要把前面的理解了, 才能看懂下面的代码!</p>
<p>为了有别于已经完成的C++的类, 我们分别在类前面加一个大写的C以示区分(平常大家都是习惯在C++写的类前面加C, 今天恰好反过来, 哈哈).</p>
<h5 id="C语言无法实现的部分"><a href="#C语言无法实现的部分" class="headerlink" title="C语言无法实现的部分"></a>C语言无法实现的部分</h5><p>C/C++是两个语言, 有些语言特性是C++专有的, 我们无法实现! 不过, 这里我是指调用约定, 我们应该把她排除在外.</p>
<p>对于类的成员函数, C++默认使用__thiscall, 也即this指针通过ecx传递, 这在C语言无法实现, 所以我们必须手动声明调用约定为:</p>
<ol>
<li><code>__stdcall</code>, 就像微软的组件对象模型那样</li>
<li><code>__cdecl</code>, 本身就C语言的调用约定, 当然能使用了.</li>
</ol>
<p>上面那种调用约定, 使用哪一种无关紧要, 反正不能使用<code>__thiscall</code>就行了.</p>
<p>因为使用了非__thiscall调用约定, 我们就必须手动传入this指针, 通过成员函数的第1个参数!</p>
<h5 id="从最简单的开始-实现-Base2"><a href="#从最简单的开始-实现-Base2" class="headerlink" title="从最简单的开始: 实现 Base2"></a>从最简单的开始: 实现 Base2</h5><p>由于没有虚函数, 仅有成员变量, 这个当然是最好模拟的咯!</p>
<figure class="highlight cc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CBase2</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> base2_1;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="有了虚函数表的Base1-但没被覆盖"><a href="#有了虚函数表的Base1-但没被覆盖" class="headerlink" title="有了虚函数表的Base1, 但没被覆盖"></a>有了虚函数表的Base1, 但没被覆盖</h5><p>下面是Base1的定义, 要复杂一点了, 多一个__vfptr:</p>
<figure class="highlight cc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CBase1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">void</span>** __vfptr;</span><br><span class="line">    <span class="keyword">int</span> base1_1;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>因为有虚函数表, 所以还得单独为虚函数表创建一个结构体的哦!<br>但是, 为了更能清楚起见, 我并未定义前面所说的指针数组, 而是用一个包含一个或多个函数指针的结构体来表示!<br>因为数组能保存的是同一类的函数指针, 不太很友好!<br>但他们的效果是完全一样的, 希望读者能够理解明白!</p>
<figure class="highlight cc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CBase1_VFTable</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">void</span>(__stdcall* base1_fun1)(CBase1* that);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>注意:</strong> base1_fun1 在这里是一个指针变量!<br><strong>注意:</strong> base1_fun1 有一个CBase1的指针, 因为我们不再使用__thiscall, 我们必须手动传入! Got it?</p>
<p>Base1的成员函数base1_fun1()我们也需要自己定义, 而且是定义成全局的:</p>
<figure class="highlight cc"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> __stdcall <span class="title">base1_fun1</span><span class="params">(CBase1* that)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;base1_fun1()&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="有虚函数覆盖的Base3"><a href="#有虚函数覆盖的Base3" class="headerlink" title="有虚函数覆盖的Base3"></a>有虚函数覆盖的Base3</h5><p>虚函数覆盖在这里并不能体现出来, 要在构造对象初始化的时候才会体现, 所以: base3其实和Base1是一样的.</p>
<figure class="highlight cc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CBase3</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">void</span>** __vfptr;</span><br><span class="line">    <span class="keyword">int</span> base3_1;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CBase3_VFTable</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">void</span>(__stdcall* base3_fun1)(CBase3* that);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Base3的成员函数:</p>
<figure class="highlight cc"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> __stdcall <span class="title">base3_fun1</span><span class="params">(CBase3* that)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;base3_fun1()&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="定义继承类CDerive1"><a href="#定义继承类CDerive1" class="headerlink" title="定义继承类CDerive1"></a>定义继承类CDerive1</h5><p>相对前面几个类来说, 这个类要显得稍微复杂一些了, 因为包含了前面几个类的内容:</p>
<figure class="highlight cc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CDerive1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    CBase1 base1;</span><br><span class="line">    CBase3 base3;</span><br><span class="line">    CBase2 base2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> derive1_1;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>特别注意: CBase123的顺序不能错!</p>
<p>另外: 由于Derive1本身还有虚函数表, 而且所以项是加到第一个虚函数表(CBase1)的后面的, 所以此时的CBase1::__vfptr不应该单单指向CBase1_VFTable, 而应该指向下面这个包含Derive1类虚函数表的结构体才行:</p>
<figure class="highlight cc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CBase1_CDerive1_VFTable</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">void</span> (__stdcall* base1_fun1)(CBase1* that);</span><br><span class="line">    <span class="keyword">void</span>(__stdcall* derive1_fun1)(CDerive1* that);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>因为CDerive1覆盖了CBase3的base3_fun1()函数, 所以不能直接用Base3的那个表:</p>
<figure class="highlight cc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CBase3_CDerive1_VFTable</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">void</span>(__stdcall* base3_fun1)(CDerive1* that);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Derive1覆盖Base3::base3_fun1()的函数以及自身定义的derive1_fun1()函数:</p>
<figure class="highlight cc"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> __stdcall <span class="title">base3_derive1_fun1</span><span class="params">(CDerive1* that)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;base3_derive1_fun1()&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> __stdcall <span class="title">derive1_fun1</span><span class="params">(CDerive1* that)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;derive1_fun1()&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="构造各类的全局虚函数表"><a href="#构造各类的全局虚函数表" class="headerlink" title="构造各类的全局虚函数表"></a>构造各类的全局虚函数表</h5><p>由于没有了编译器的帮忙, 在定义一个类对象时, 所有的初始化工作都只能由我们自己来完成了!</p>
<p>首先构造全局的, 被同一个类共同使用的虚函数表!</p>
<figure class="highlight cc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// CBase1 的虚函数表</span></span><br><span class="line">CBase1_VFTable __vftable_base1;</span><br><span class="line">__vftable_base1.base1_fun1 = base1_fun1;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CBase3 的虚函数表</span></span><br><span class="line">CBase3_VFTable __vftable_base3;</span><br><span class="line">__vftable_base3.base3_fun1 = base3_fun1;</span><br></pre></td></tr></table></figure>

<p>然后构造CDerive1和CBase1共同使用的虚函数表:</p>
<figure class="highlight cc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// CDerive1 和 CBase1 共用的虚函数表</span></span><br><span class="line">CBase1_CDerive1_VFTable __vftable_base1_derive1;</span><br><span class="line">__vftable_base1_derive1.base1_fun1 = base1_fun1;</span><br><span class="line">__vftable_base1_derive1.derive1_fun1 = derive1_fun1;</span><br></pre></td></tr></table></figure>

<p>再构造CDerive1覆盖CBase3后的虚函数表: 注意: 数覆盖会替换原来的函数指针</p>
<figure class="highlight cc"><table><tr><td class="code"><pre><span class="line">CBase3_CDerive1_VFTable __vftable_base3_derive1;</span><br><span class="line">__vftable_base3_derive1.base3_fun1 = base3_derive1_fun1;</span><br></pre></td></tr></table></figure>

<h5 id="开始-从CDerive1构造一个完整的Derive1类"><a href="#开始-从CDerive1构造一个完整的Derive1类" class="headerlink" title="开始! 从CDerive1构造一个完整的Derive1类"></a>开始! 从CDerive1构造一个完整的Derive1类</h5><p>先初始化成员变量与__vfptr的指向: 注意不是指错了!</p>
<figure class="highlight cc"><table><tr><td class="code"><pre><span class="line">CDerive1 d1;</span><br><span class="line">d1.derive1 = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">d1.base1.base1_1 = <span class="number">11</span>;</span><br><span class="line">d1.base1.__vfptr = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">void</span>**&gt;(&amp;__vftable_base1_derive1);</span><br><span class="line">    </span><br><span class="line">d1.base2.base2_1 = <span class="number">21</span>;</span><br><span class="line"></span><br><span class="line">d1.base3.base3_1 = <span class="number">31</span>;</span><br><span class="line">d1.base3.__vfptr = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">void</span>**&gt;(&amp;__vftable_base3_derive1);</span><br></pre></td></tr></table></figure>

<p>由于目前的CDerive1是我们手动构造的, 不存在真正语法上的继承关系, 如要得到各基类指针, 我们就不能直接来取, 必须手动根据偏移计算:</p>
<figure class="highlight cc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span>* p = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">char</span>*&gt;(&amp;d1);</span><br><span class="line">Base1* pb1 = <span class="keyword">reinterpret_cast</span>&lt;Base1*&gt;(p + <span class="number">0</span>);</span><br><span class="line">Base2* pb2 = <span class="keyword">reinterpret_cast</span>&lt;Base2*&gt;(p + <span class="keyword">sizeof</span>(CBase1) + <span class="keyword">sizeof</span>(CBase3));</span><br><span class="line">Base3* pb3 = <span class="keyword">reinterpret_cast</span>&lt;Base3*&gt;(p + <span class="keyword">sizeof</span>(CBase1));</span><br><span class="line">Derive1* pd1 = <span class="keyword">reinterpret_cast</span>&lt;Derive1*&gt;(p);</span><br></pre></td></tr></table></figure>

<p>真正调用:</p>
<figure class="highlight cc"><table><tr><td class="code"><pre><span class="line">foo(pb1, pb2, pb3, pd1);</span><br></pre></td></tr></table></figure>

<p>调用结果:</p>
<p><img src="last.png" alt="img"></p>
<p><strong>结果相当正确!!!</strong></p>
<h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2><p>我以为我把源代码搞丢了，结果过了一年多发现其实并没有。— 2015-12-24（每个圣诞我都在写代码）</p>
<p>有两个，忘了区别了：<a href="https://blog.twofei.com/496/Source1.cpp">Source1.cpp</a>, <a href="https://blog.twofei.com/496/Source2.cpp">Source2.cpp</a>.</p>
<p>如果文章有帮助到你，请我喝杯冰可乐吧～</p>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++：未规定返回值类型的函数的返回值类型是什么？</title>
    <url>/func-without-return-type/</url>
    <content><![CDATA[<p>先说结论：</p>
<p><strong>当函数的返回值类型未规定时，默认为int类型，并且此时的函数可以通过return返回值，返回值的类型需要能够转换到int。这个规则适用于普通函数和成员函数。</strong></p>
<p>写代码的时候发现了一个很有意思的事情，当我没有规定函数返回值类型的时候，编译和运行都是不会出错的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">func () &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;This is a func()&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="keyword">typeid</span>(func()).name();		<span class="comment">// #include &lt;typeinfo&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同时可以获得<code>func()</code>的返回值是一个<code>i</code>，即<code>int</code>类型。</p>
<p>尝试在<code>func()</code>函数中使用<code>return</code>语句规定返回值：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">func() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>得到的返回值是<code>a</code>的ASCII编码97。</p>
<p>因此可以确定返回值类型默认为<code>int</code>，并且会自动将非<code>int</code>类型转化为<code>int</code>。</p>
<p>返回不可以转为<code>int</code>类型的数据会报错，比如<code>string</code>。</p>
<p>同时经过测试，类的成员函数的返回值类型也满足上述情况。</p>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>530. 二叉搜索树的最小绝对差</title>
    <url>/minimum-absolute-difference-in-bst/</url>
    <content><![CDATA[<h2 id="1-中序遍历"><a href="#1-中序遍历" class="headerlink" title="1. 中序遍历"></a>1. 中序遍历</h2><p>看到二叉搜索树优先考虑<strong>“二叉搜索树的中序序列是递增的”</strong>。<br>获取中序序列后两两比较差值。<br>时间<code>O(n)</code>，空间<code>O(n)</code>。  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMinimumDifference</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; st;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (root != <span class="literal">nullptr</span> || !st.empty()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                TreeNode* temp = st.top();</span><br><span class="line">                st.pop();</span><br><span class="line">                nums.push_back(temp-&gt;val);</span><br><span class="line">                root = temp-&gt;right;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                st.push(root);</span><br><span class="line">                root = root-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ans = INT_MAX, n = nums.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">            ans = min(ans, nums[i] - nums[i - <span class="number">1</span>]);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>416.分割等和子集</title>
    <url>/partition-equal-subset-sum/</url>
    <content><![CDATA[<h2 id="1-递归-回溯"><a href="#1-递归-回溯" class="headerlink" title="1. 递归+回溯"></a>1. 递归+回溯</h2><p>第一反应是“40. 组合总和 II”，有重复数字，不能重复选择。<br>首先求出数组总和，然后就变成了找是否存在目标为<code>sum/2</code>的组合问题。<br>时间复杂度<code>O(2^n)</code>（每个元素选或不选），空间复杂度<code>O(1)</code>。<br><em>超时</em>  </p>
<p>“40. 组合总和 II”用dfs是因为它需要记录所有的方案，而这道题目只需要方案数，所以不需要在dfs过程中隐式包含的路径。  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canPartition</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size(), sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">bool</span> ans = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) </span><br><span class="line">            sum += nums[i];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (sum % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            sort(nums.begin(), nums.end());</span><br><span class="line">            ans = dfs(nums, <span class="number">0</span>, sum / <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> beg, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (target &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">bool</span> ans = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = beg; i &lt; nums.size(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; target)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            ans = dfs(nums, i + <span class="number">1</span>, target - nums[i]);</span><br><span class="line">            <span class="keyword">if</span> (ans)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2-背包"><a href="#2-背包" class="headerlink" title="2. 背包"></a>2. 背包</h2><p>01背包问题，需要恰好装满（到达sum/2)。<br>时间<code>O(n*sum)</code>，空间<code>O(sum)</code>。  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canPartition</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size(), sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">bool</span> ans = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            sum += nums[i];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (sum % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = sum / <span class="number">2</span>;</span><br><span class="line">            <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">dp</span><span class="params">(mid + <span class="number">1</span>, <span class="literal">false</span>)</span></span>;</span><br><span class="line">            dp[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = mid; j &gt;= nums[i]; --j)</span><br><span class="line">                    dp[j] = dp[j] || dp[j - nums[i]];</span><br><span class="line">                <span class="keyword">if</span> (dp[mid]) &#123;</span><br><span class="line">                    ans = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>背包</tag>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>142.环形链表 II</title>
    <url>/linked-list-cycle-ii/</url>
    <content><![CDATA[<h2 id="1-hash表"><a href="#1-hash表" class="headerlink" title="1. hash表"></a>1. hash表</h2><p>遍历链表，使用hash表记录途中的节点，直到到达链表尾或者出现hash表中储存的节点，该节点即为环的入口。<br>时间<code>O(n)</code>，空间<code>O(n)</code>。  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;ListNode*&gt; table;</span><br><span class="line">        ListNode* ans = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (head != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (table.count(head)) &#123;</span><br><span class="line">                ans = head;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            table.insert(head);</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2-双指针"><a href="#2-双指针" class="headerlink" title="2. 双指针"></a>2. 双指针</h2><p>参考“<a href="https://zkkkillua.github.io/circular-linked-list/">关于环形链表的一切</a>”。<br>设置快指针速度为2，慢指针速度为1，首先获得二者的相遇点（如果有环的话），然后另设一个速度为1的指针从起点出发，与慢指针同步前进，二者的相遇位置即为环的入口。<br>时间<code>O(n)</code>，空间<code>O(1)</code>。  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        ListNode* meet = meetPoint(head);</span><br><span class="line">        ListNode* slow = head;</span><br><span class="line">        <span class="keyword">while</span> (meet != <span class="literal">nullptr</span> &amp;&amp; slow != meet) &#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            meet = meet-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> meet;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">meetPoint</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* fast = head;</span><br><span class="line">        ListNode* slow = head;</span><br><span class="line">        <span class="keyword">bool</span> meet = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="literal">nullptr</span> &amp;&amp; fast-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (slow == fast) &#123;</span><br><span class="line">                meet = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> meet ? slow : <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>关于环形链表的一切</title>
    <url>/circular-linked-list/</url>
    <content><![CDATA[<p>首先可以得到的结论是：</p>
<p><strong>只要快慢指针从同一起点出发，则一定能相遇（从起点出发，在环长度的倍数倍位置上一定能相遇，不论快慢指针步长如何。但首次相遇位置不一定在此处），并且当快指针速度是慢指针的整数倍时，相遇时慢指针在圆环中移动的距离不足一周。</strong> </p>
<p>原因是，设圆环外链表长度为k，圆环长度为n，快指针速度是慢指针的r倍。</p>
<p>先考虑r为整数的情况：</p>
<p>令慢指针前进S（S为n的倍数，并且满足k&lt;=S&lt;k+n）距离，保证慢指针能够位移进入圆环，此时，快指针移动的距离为rS，可以看作先前进了S到达慢指针前进S到达的地点，又前进了(r-1)S，这部分为n的倍数，相当于转圈。因此便证明了上述结论。</p>
<p>考虑r为小数的情况：<br> 此时上述提到的快指针移动的距离rS不一定为整数，为保证rS为整数，需要增大S，而增大S便会导致S&gt;=k+n，所以慢指针在圆环中移动的距离会超过一周。</p>
<p>S处考虑的只是一定能相遇的情况，而在慢指针前进不足S时，也有可能相遇，比如slow = 1, fast = 5, k = 1, n = 4，快慢指针位移一次即可相遇。</p>
<p><strong>除了判断环形链表，快慢指针还能干什么？</strong></p>
<ol>
<li>找链表的中点。</li>
<li>求环形链表的长度</li>
<li>找环形链表的开头</li>
</ol>
<p>因为已经得到了必定相遇的结论，因此以下使用慢指针=1，快指针=2的步长。</p>
<p><img src="draft.png" alt="draft"></p>
<p>由上图可以得知，k+m是环长n的整数倍，因此从相遇点继续前进k长的距离就会到达圆环入口。 </p>
<p>所以可以另设一个新的指针从链表头出发，以1的速度与慢指针同步前进，二者相遇的位置即为入口。</p>
<p>至于环的长度，保持快指针不动，慢指针走至重新重合即可获得长度。</p>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>C++的各类操作符重载</title>
    <url>/operator-overloading/</url>
    <content><![CDATA[<h3 id="一-输入和输出运算符"><a href="#一-输入和输出运算符" class="headerlink" title="一. 输入和输出运算符"></a>一. 输入和输出运算符</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    <span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span> &lt;&lt; (ostream&amp; os, <span class="keyword">const</span> A&amp; item) &#123;</span><br><span class="line">        os &lt;&lt; <span class="string">&quot;something&quot;</span>;		<span class="comment">// without `endl`</span></span><br><span class="line">        <span class="keyword">return</span> os;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">friend</span> istream&amp; <span class="keyword">operator</span> &gt;&gt; (istream&amp; is, A&amp; item) &#123;</span><br><span class="line">        in &gt;&gt; item.something;</span><br><span class="line">        <span class="keyword">return</span> is;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="1-输出运算符"><a href="#1-输出运算符" class="headerlink" title="1. 输出运算符"></a>1. 输出运算符</h4><p>第一个形参使用非常量的<code>ostream</code>对象的引用，第二个形参使用常量的引用。</p>
<p><code>ostream</code>非常量是因为向流写入内容会改变其状态；第二个形参使用常量是为了避免修改对象内容，引用是为了避免调用复制构造函数。</p>
<blockquote>
<p>通常， 输出运算符应该主要负责打印对象的内容而非控制格式，输出运算符不应该打印换行符。</p>
</blockquote>
<h4 id="2-输入运算符"><a href="#2-输入运算符" class="headerlink" title="2. 输入运算符"></a>2. 输入运算符</h4><p>第一个形参使用非常量的<code>istream</code>对象的引用，第二个形参使用非常量的引用。</p>
<p><code>istream</code>非常量是因为向流写入内容会改变其状态；第二个形参使用非常量引用是因为输入运算符本来就是要把数据读入到这个对象中。</p>
<p><strong>为什么输入和输出运算符的重载是友元函数？</strong></p>
<p>首先不能是类的成员函数，否则调用格式就变成了<code>A a;  a &lt;&lt; ...</code>，另外我们也不能给<code>iostream</code>标准库的类中添加成员，最后为了访问类中的私有成员，所以重载为友元。</p>
<p>所以实际上的调用过程可以理解为<code>&lt;&lt; (cout, a)</code>。</p>
<h3 id="二-算数和关系运算符"><a href="#二-算数和关系运算符" class="headerlink" title="二. 算数和关系运算符"></a>二. 算数和关系运算符</h3><p><strong>定义为成员函数还是友元函数？</strong></p>
<p>最好定义为友元函数。</p>
<p>首先，定义为成员函数是可行的，比如如下定义：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    A <span class="keyword">operator</span> + (<span class="keyword">const</span> A&amp; a) &#123;</span><br><span class="line">        A sum;</span><br><span class="line">        sum.val = val + a.val;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上述代码的返回值类型是对象而不是引用，原因是如果返回的是引用，则<code>sum</code>对象在函数返回之后会被销毁，从而导致引用失效。<br>另一个问题是如果没有新建一个对象，而直接使用<code>val += a.val</code>，则调用函数的对象的值也被修改了。</p>
<p>那么为什么最好定义为友元函数？</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> s = <span class="string">&quot;world&quot;</span>;</span><br><span class="line"><span class="built_in">string</span> t = s + <span class="string">&quot;!&quot;</span>;		<span class="comment">//正确：我们能把一个const char ＊加到一个string对象中</span></span><br><span class="line"><span class="built_in">string</span> u = <span class="string">&quot;hi &quot;</span> + s;	<span class="comment">// 如果＋是string的成员，则产生错误</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果<code>operator ＋</code>是string 类的成员，则上面的第一个加法等价于<code>s.operator+( &quot; ! &quot; ) </code>。<br>同样地，＂hi “ +s 等价于<code>&quot;hi &quot;. operator+(s)</code> 。显然”hi “的类型是const char* ，这是一种内置类型，根本就没有成员函数。</p>
<p>因为string 将<code>＋</code>定义成了普通的非成员函数，所以<code>&quot;hi &quot; + s</code>等价于<code>operator+(&quot;hi  &quot;, s)</code> 。</p>
<p>和任何其他函数调用一样，每个实参都能被转换成形参类型。唯一的要求是至少有一个运算对象是类类型，并且两个运算对象都能准确无误地转换成string 。</p>
</blockquote>
<p>类型转换函数可以被显式定义，如<code>operator int() const &#123; return val; &#125;</code>。</p>
<p>编译器隐式调用类型转换函数或者构造函数进行类型转换可能出现问题，因此为了避免编译器隐式进行类型转换，可以使用<code>explicit</code>字段修饰类型转换函数和构造函数，编译器通常不会使用显式的类型转换运算符用作隐式类型转换。</p>
<blockquote>
<p>该规定存在一个例外，即如果表达式被用作条件，则编译器会将显式的类型转换自动应用于它。换句话说， 当表达式出现在下列位置时， 显式的类型转换将被隐式地执行：</p>
<ul>
<li>if , while 及 do 语句的条件部分</li>
<li>for 语句头的条件表达式</li>
<li>逻辑非运算符（!）、逻辑或运算符（||）、逻辑与运算符（&amp;&amp;）的运算对象</li>
<li>条件运算符（? : ）的条件表达式。</li>
</ul>
</blockquote>
<h4 id="1-算术运算符"><a href="#1-算术运算符" class="headerlink" title="1. 算术运算符"></a>1. 算术运算符</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">const</span> A <span class="keyword">operator</span> + (<span class="keyword">const</span> A&amp; a, <span class="keyword">const</span> A&amp; b) &#123;</span><br><span class="line">        A sum;</span><br><span class="line">        sum.val = a.val + b.val;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>返回值定义为<code>const</code>类型可以避免对函数进行操作，即<code>a + b = c</code>；同时也不会对<code>c = a + b</code>造成影响，<code>c</code>并不要求一定是<code>const</code>类型。</p>
<h4 id="2-关系运算符"><a href="#2-关系运算符" class="headerlink" title="2. 关系运算符"></a>2. 关系运算符</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> A&amp; a, <span class="keyword">const</span> A&amp; b) &#123;</span><br><span class="line">        <span class="keyword">return</span> ...;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="三-赋值运算符"><a href="#三-赋值运算符" class="headerlink" title="三. 赋值运算符"></a>三. 赋值运算符</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    A&amp; <span class="keyword">operator</span> = (<span class="keyword">const</span> A&amp; a) &#123;</span><br><span class="line">        <span class="comment">// ... = a....</span></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>a = b = c</code>首先执行<code>b = c</code>，然后执行<code>a = b</code>。</p>
<p>返回引用的目的就是为了在连续赋值时，完成<code>b = c</code>之后返回一个<code>b</code>的引用，让<code>a</code>能够被<code>b</code>赋值。</p>
<p>如果是<code>(a = b) = c</code>，则是<code>a</code>首先被赋予<code>b</code>的值，其次<code>a</code>又被赋予了<code>c</code>的值。而如果返回的是<code>const</code>引用，则不能这样复制，因为无法给<code>const</code>引用赋值。</p>
<h3 id="四-递增和递减运算符"><a href="#四-递增和递减运算符" class="headerlink" title="四. 递增和递减运算符"></a>四. 递增和递减运算符</h3><h4 id="1-前置递增-递减运算符"><a href="#1-前置递增-递减运算符" class="headerlink" title="1. 前置递增/递减运算符"></a>1. 前置递增/递减运算符</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    A&amp; <span class="keyword">operator</span> ++ () &#123;</span><br><span class="line">        ++val;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="2-后置递增-递减运算符"><a href="#2-后置递增-递减运算符" class="headerlink" title="2. 后置递增/递减运算符"></a>2. 后置递增/递减运算符</h4><p>为了区分前置和后置运算符，后置版本接受一个额外的不被使用的int类型的形参，作为函数重载的区分。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    A <span class="keyword">operator</span> ++ (<span class="keyword">int</span>) &#123;</span><br><span class="line">        A ret = *<span class="keyword">this</span>;</span><br><span class="line">        ++val;</span><br><span class="line">        <span class="comment">// ++(*this);		// 此处也可以直接调用之前定义好的前置运算符</span></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>与前置递增/递减运算符不同的是，<strong>后置的运算符返回的是对象而不是引用</strong>，因为后置运算符返回的是在函数内新定义的对象，离开函数时会被析构，所以返回值类型是对象，从而调用复制构造函数生成一个新的对象。</p>
<p><strong>如何显式调用前置/后置递增/递减运算符？</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">A a;</span><br><span class="line">++a;	<span class="comment">// 隐式调用前置</span></span><br><span class="line">a++;	<span class="comment">// 隐式调用后置</span></span><br><span class="line">a.<span class="keyword">operator</span>++();		<span class="comment">// 显式调用前置</span></span><br><span class="line">a.<span class="keyword">operator</span>++(<span class="number">0</span>);	<span class="comment">// 显式调用后置。此处随便传入一个整数值，作为重载函数的区分</span></span><br></pre></td></tr></table></figure>





<p>部分内容摘自《C++ Primer （第5版）》</p>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>为什么函数返回对象时没有调用复制构造函数？</title>
    <url>/copy-constructor-rvo/</url>
    <content><![CDATA[<h3 id="1-复制构造函数被调用的三种情况"><a href="#1-复制构造函数被调用的三种情况" class="headerlink" title="1. 复制构造函数被调用的三种情况"></a>1. 复制构造函数被调用的三种情况</h3><ol>
<li><p>使用已有的对象创建新的对象。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">A <span class="title">a1</span><span class="params">(a)</span></span>;</span><br><span class="line">A a2 = a;</span><br></pre></td></tr></table></figure>
</li>
<li><p>函数的参数类型是对象。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(A a)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>函数返回值的类型是对象。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">A <span class="title">func</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="2-示例代码"><a href="#2-示例代码" class="headerlink" title="2. 示例代码"></a>2. 示例代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;constructor&quot;</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    ~A() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;destructor&quot;</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    A(<span class="keyword">const</span> A&amp; a) &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;copy constructor&quot;</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">A <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;func()&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A a = func();</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;return&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">constructor		&#x2F;&#x2F; A a &#x3D; func()调用func中A a</span><br><span class="line">func()</span><br><span class="line">return			&#x2F;&#x2F; main结束</span><br><span class="line">destructor		&#x2F;&#x2F; 析构a</span><br></pre></td></tr></table></figure>

<p>而相较预期的结果少了<code>func()</code>返回值的临时对象的复制构造函数，和用函数返回值生成<code>A a</code>对象的复制构造函数。</p>
<h3 id="3-原因"><a href="#3-原因" class="headerlink" title="3. 原因"></a>3. 原因</h3><p>产生这个问题的原因是编译器进行了返回值优化RVO，减少了不必要对象的构造，提高效率。</p>
<p>以下内容摘自<a href="https://zh.wikipedia.org/wiki/%E8%BF%94%E5%9B%9E%E5%80%BC%E4%BC%98%E5%8C%96">维基百科</a>：</p>
<blockquote>
<p><strong>返回值优化</strong>（Return value optimization，缩写为<strong>RVO</strong>）是C++的一项编译优化技术。即删除保持函数返回值的临时对象。这可能会省略两次复制构造函数，即使复制构造函数有副作用。</p>
</blockquote>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++：const修饰符的常见用法</title>
    <url>/cpp-const/</url>
    <content><![CDATA[<h3 id="1-const常量"><a href="#1-const常量" class="headerlink" title="1. const常量"></a>1. const常量</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> a = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> a;	<span class="comment">// error 需要在创建时初始化</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p> 当以编译时初始化的方式定义一个const 对象时，编译器将在编译过程中把用到该变量的地方都替换成对应的值。<br>为了执行上述替换，编译器必须知道变量的初始值。</p>
<p>默认情况下， const 对象被设定为仅在文件内有效。<br>如果想只在一个文件中定义const，而在其他多个文件中声明并使用它。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// file_l.cc 定义并初始化了一个常量，该常量能被其他文件访问</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">int</span> bufSize =fcn ();</span><br><span class="line"><span class="comment">// file_l.h 头文件</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">int</span> bufSize; <span class="comment">// 与file_l.cc中定义的bufSize是同一个</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="2-const引用"><a href="#2-const引用" class="headerlink" title="2. const引用"></a>2. const引用</h3><p>const修饰引用表示不能通过引用修改值，如果引用的是常量，则引用必须也是const。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>&amp; r1 = a;		<span class="comment">// const引用指向的可以不是常量，但是不能通过引用修改其值</span></span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> &amp; r2 = a;</span><br><span class="line"><span class="keyword">int</span>&amp; <span class="keyword">const</span> r3 = a;		<span class="comment">// error 引用本身就不能修改指向，不需要再额外使用const修饰</span></span><br></pre></td></tr></table></figure>



<h3 id="3-const与指针"><a href="#3-const与指针" class="headerlink" title="3. const与指针"></a>3. const与指针</h3><ul>
<li><p>指向常量的指针：pointer to const</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>* p1 = &amp;a;		<span class="comment">// p1 is a pointer to int const</span></span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span>* p2 = &amp;a;		<span class="comment">// p2 is a pointer to const int</span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>* p1 = &amp;a;</span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span>* p2 = &amp;b;		<span class="comment">// 指向常量的指针指向的可以不是常量，只是不能通过指针修改指向的值</span></span><br><span class="line">p1 = &amp;b;				<span class="comment">// 指向常量的指针可以改变指向</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>常量指针：const pointer</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>* <span class="keyword">const</span> p = &amp;a;		<span class="comment">// p is a const pointer to int</span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span>* <span class="keyword">const</span> p1 = &amp;a;			<span class="comment">// error 常量只能被指向常量的指针指向</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>* <span class="keyword">const</span> p2 = &amp;a;	<span class="comment">// 指向常量的常量指针，既不能通过指针修改所指的值，也不能修改指向</span></span><br><span class="line"><span class="keyword">int</span>* <span class="keyword">const</span> p2 = &amp;b;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h3 id="4-const与普通函数"><a href="#4-const与普通函数" class="headerlink" title="4. const与普通函数"></a>4. const与普通函数</h3><h4 id="4-1-const修饰返回值"><a href="#4-1-const修饰返回值" class="headerlink" title="4.1. const修饰返回值"></a>4.1. const修饰返回值</h4><h5 id="返回值是整型"><a href="#返回值是整型" class="headerlink" title="返回值是整型"></a>返回值是整型</h5><p>const修饰返回值使得返回的是常量。</p>
<p>而常量的返回是受限的，比如如下代码的const是没有意义的：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ret = func(<span class="number">3</span>);		<span class="comment">// ret == 6</span></span><br><span class="line">ret = <span class="number">5</span>;				<span class="comment">// ret == 5</span></span><br></pre></td></tr></table></figure>

<p>虽然返回值类型是常量，但是因为被赋值给了其他的变量，所以返回值还是可以修改的（修改的是变量ret）。</p>
<h5 id="返回值是指向常量的指针"><a href="#返回值是指向常量的指针" class="headerlink" title="返回值是指向常量的指针"></a>返回值是指向常量的指针</h5><p>如果const修饰的返回值是指针类型，则结果有所不同。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">int</span>* <span class="title">func</span><span class="params">(<span class="keyword">int</span>* p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">3</span>;</span><br><span class="line"><span class="comment">// int *p = func(&amp;a);		// error const int* -x&gt; int*</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *p = func(&amp;a);</span><br><span class="line"><span class="comment">// *p = 5;					// error</span></span><br></pre></td></tr></table></figure>

<h5 id="返回值为常量指针"><a href="#返回值为常量指针" class="headerlink" title="返回值为常量指针"></a>返回值为常量指针</h5><p>同样，还有返回值类型为常量指针：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>* <span class="keyword">const</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>* p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span> *p = func(&amp;a);</span><br><span class="line">p = <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure>

<p>由于<code>int* const</code>限制的是返回的临时对象是常量指针，而常量指针是可以被赋值给其他非常量指针的，所以此处的const也没有作用。</p>
<h5 id="返回值为指向常量的引用"><a href="#返回值为指向常量的引用" class="headerlink" title="返回值为指向常量的引用"></a>返回值为指向常量的引用</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">int</span>&amp; <span class="title">func</span><span class="params">(<span class="keyword">int</span>&amp; a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ++a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;r = func(a);</span><br><span class="line"><span class="comment">// int&amp; r = func(a);		// error const reference -x&gt; reference</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>&amp; r = func(a);		<span class="comment">// r is a</span></span><br></pre></td></tr></table></figure>

<p>返回值是指向常量的引用，不能传递给指向变量的引用。</p>
<h4 id="4-2-const修饰函数"><a href="#4-2-const修饰函数" class="headerlink" title="4.2. const修饰函数"></a>4.2. const修饰函数</h4><p>const是可以修饰成员函数的，格式为<code>int A::func() const &#123;&#125;</code>，代表内部不会修改成员变量，可能修改静态成员变量，常对象仅能调用常成员函数。</p>
<p>而const是不能修饰普通的非类的成员的函数的，即没有<code>int func() const &#123;&#125;</code>的格式。</p>
<p>因为常成员函数的目的是避免修改成员变量，为常对象提供调用函数，而普通的函数如果想要避免修改其他变量，则在传入对象时规定为常量即可，所以不需要额外定义一种常函数。</p>
<h3 id="5-const与成员函数"><a href="#5-const与成员函数" class="headerlink" title="5. const与成员函数"></a>5. const与成员函数</h3><h4 id="5-1-const修饰返回值"><a href="#5-1-const修饰返回值" class="headerlink" title="5.1. const修饰返回值"></a>5.1. const修饰返回值</h4><p>同const修饰普通函数的返回值。</p>
<h4 id="5-2-const修饰成员函数（常成员函数）"><a href="#5-2-const修饰成员函数（常成员函数）" class="headerlink" title="5.2. const修饰成员函数（常成员函数）"></a>5.2. const修饰成员函数（常成员函数）</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="comment">// pval = 3;		// error</span></span><br><span class="line">        <span class="comment">// val = 3;			// error</span></span><br><span class="line">        sval = <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> pval;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> sval;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> A::sval = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">    a.func();				<span class="comment">// sval = 10;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>常成员函数无法修改成员变量，可以修改静态成员变量，无法调用非常成员函数，不论公有私有。</p>
<p>对象的this指针被声明为<code>A* const</code>类型，因此无法改变指向，在常成员函数中，this指针是<code>const A* const</code>类型，因此既无法改变指向，又无法改变this指针所指的值。</p>
<h4 id="5-3-const成员函数的重载"><a href="#5-3-const成员函数的重载" class="headerlink" title="5.3. const成员函数的重载"></a>5.3. const成员函数的重载</h4><p>const是可以用于类成员函数的重载的。</p>
<p>非常量对象优先调用非常成员函数，常量对象只能调用常成员函数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;func()&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;func() const&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">A a1;	a1.func();		<span class="comment">// func();</span></span><br><span class="line"><span class="keyword">const</span> A a2;	a2.func();	<span class="comment">// func() const;</span></span><br></pre></td></tr></table></figure>



<h3 id="6-constexpr"><a href="#6-constexpr" class="headerlink" title="6. constexpr"></a>6. constexpr</h3><blockquote>
<p>C++ 11 新标准规定，允许将变量声明为constexpr类型以便由编译器来验证变量的值是否是一个常量表达式。</p>
</blockquote>
<p>即声明为constexpr的变量和函数，代表它们是常量表达式，其值在编译期是可知的，用constexpr告知编译器可以进行优化。</p>
<p>而const是“只读”，不能被修改，编译器检查到修改const会直接报错。</p>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>117. 填充每个节点的下一个右侧节点指针 II</title>
    <url>/populating-next-right-pointers-in-each-node-ii/</url>
    <content><![CDATA[<h2 id="1-层次遍历"><a href="#1-层次遍历" class="headerlink" title="1. 层次遍历"></a>1. 层次遍历</h2><p>层次遍历获得同一层的节点，然后依次让next指向右侧的节点。<br>时间<code>O(n)</code>，空间<code>O(n)</code>。  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    Node* left;</span></span><br><span class="line"><span class="comment">    Node* right;</span></span><br><span class="line"><span class="comment">    Node* next;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node() : val(0), left(NULL), right(NULL), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val, Node* _left, Node* _right, Node* _next)</span></span><br><span class="line"><span class="comment">        : val(_val), left(_left), right(_right), next(_next) &#123;&#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">connect</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">queue</span>&lt;Node*&gt; q;</span><br><span class="line">        Node* cur = root;</span><br><span class="line">        q.push(cur);</span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> n = q.size();</span><br><span class="line">            <span class="keyword">while</span> (n-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                cur = q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                <span class="keyword">if</span> (cur-&gt;left != <span class="literal">nullptr</span>)</span><br><span class="line">                    q.push(cur-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (cur-&gt;right != <span class="literal">nullptr</span>)</span><br><span class="line">                    q.push(cur-&gt;right);</span><br><span class="line">                <span class="keyword">if</span> (n &gt; <span class="number">0</span>)</span><br><span class="line">                    cur-&gt;next = q.front();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2-迭代"><a href="#2-迭代" class="headerlink" title="2. 迭代"></a>2. 迭代</h2><p>通过上一层已经构造好的next指针获取下一层新的节点，并不断修改下一层节点的next值。<br>时间<code>O(n)</code>，空间<code>O(1)</code>。  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">connect</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        Node* lastLayer = root;</span><br><span class="line">        Node* cur = <span class="literal">nullptr</span>;</span><br><span class="line">        curHead = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span> (lastLayer != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (lastLayer != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (lastLayer-&gt;left != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (cur == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                        cur = lastLayer-&gt;left;</span><br><span class="line">                        curHead = cur;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        cur-&gt;next = lastLayer-&gt;left;</span><br><span class="line">                        cur = cur-&gt;next;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (lastLayer-&gt;right != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (cur == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                        cur = lastLayer-&gt;right;</span><br><span class="line">                        curHead = cur;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        cur-&gt;next = lastLayer-&gt;right;</span><br><span class="line">                        cur = cur-&gt;next;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                lastLayer = lastLayer-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = <span class="literal">nullptr</span>;</span><br><span class="line">            lastLayer = curHead;</span><br><span class="line">            curHead = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>235.二叉搜索树的最近公共祖先</title>
    <url>/lowest-common-ancestor-of-a-binary-search-tree/</url>
    <content><![CDATA[<h2 id="1-普通二叉树的最近公共祖先"><a href="#1-普通二叉树的最近公共祖先" class="headerlink" title="1. 普通二叉树的最近公共祖先"></a>1. 普通二叉树的最近公共祖先</h2><p>参照“<a href="https://zkkkillua.github.io/lowest-common-ancestor-of-a-binary-tree/">236.二叉树的最近公共祖先</a>”，可以使用递归或迭代求解。  </p>
<p>递归求解是到左右子树中查找有无给定的p和q节点，根据不同的条件返回指针。<br>迭代求解是使用hash表记录各节点的父节点，然后比较p和q的各祖先节点，可以是朴素比较/记录层数/记录是否访问。  </p>
<h2 id="2-迭代"><a href="#2-迭代" class="headerlink" title="2. 迭代"></a>2. 迭代</h2><p>如果p或q等于当前节点，返回当前节点。<br>如果p和q都小于或者都大于当前节点，则到左子树或右子树中查找。<br>如果p和q一个大于当前节点，一个小于当前节点，说明p和q在当前节点处分开，则当前节点一定是二者的最近公共祖先。<br>相较于普通的二叉树，利用二叉搜索树的性质减少了对不必要的分支的访问。<br>时间<code>O(n)</code>，空间<code>O(1)</code>。  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        </span><br><span class="line">        TreeNode* ans = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span> (root != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;val &lt; root-&gt;val &amp;&amp; q-&gt;val &lt; root-&gt;val) </span><br><span class="line">                root = root-&gt;left;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p-&gt;val &gt; root-&gt;val &amp;&amp; q-&gt;val &gt; root-&gt;val)</span><br><span class="line">                root = root-&gt;right;            </span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                ans = root;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>236. 二叉树的最近公共祖先</title>
    <url>/lowest-common-ancestor-of-a-binary-tree/</url>
    <content><![CDATA[<h2 id="1-递归"><a href="#1-递归" class="headerlink" title="1. 递归"></a>1. 递归</h2><p>递归到以当前root为根的子树中查找是否包含p或q节点。<br>因为包含与否分四种情况：都不包含，只含p，只含q，都包含。<br>因此只用简单的true/false是不容易表示的，因此可以考虑返回指针，分别返回：null, &amp;p, &amp;q, root。<br>时间<code>O(n)</code>，空间<code>O(n)</code>。  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val == p-&gt;val || root-&gt;val == q-&gt;val)</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">        TreeNode* leftTree = lowestCommonAncestor(root-&gt;left, p, q);</span><br><span class="line">        TreeNode* rightTree = lowestCommonAncestor(root-&gt;right, p, q);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (leftTree == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> rightTree;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (rightTree == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> leftTree;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2-迭代"><a href="#2-迭代" class="headerlink" title="2. 迭代"></a>2. 迭代</h2><p>使用hash表记录每个节点的parent，然后分别找p和q节点的parent一直到整棵树的root，在此过程中查找最近公共祖先。<br>这就相当于在两个数组中查找最接近开始位置的相等值的位置。  </p>
<ul>
<li><p>一种方法是朴素查找，p每访问一层parent，q遍历所有层的parent，时间复杂度<code>O(n^2)</code>。  </p>
</li>
<li><p>第二种方法是hash表同时记录该parent的层数，然后p和q从parent的同一层出发公式向上找LCA。  </p>
</li>
<li><p>第三种方法是使用另一个hash表记录是否访问，p首先遍历各层的parent并标记为true，q在向上查找过程中访问到为true的节点即为公共祖先。  </p>
</li>
</ul>
<p>时间<code>O(n)</code>，空间<code>O(n)</code>。  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, TreeNode*&gt; parent;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">bool</span>&gt; vis;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; que;</span><br><span class="line"></span><br><span class="line">        parent[root-&gt;val] = <span class="literal">nullptr</span>;</span><br><span class="line">        que.push(root);</span><br><span class="line">        <span class="keyword">while</span> (!que.empty()) &#123;</span><br><span class="line">            root = que.front();</span><br><span class="line">            que.pop();</span><br><span class="line">            <span class="keyword">if</span> (root-&gt;left != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                que.push(root-&gt;left);</span><br><span class="line">                parent[root-&gt;left-&gt;val] = root;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (root-&gt;right != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                que.push(root-&gt;right);</span><br><span class="line">                parent[root-&gt;right-&gt;val] = root;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            vis[p-&gt;val] = <span class="literal">true</span>;</span><br><span class="line">            p = parent[p-&gt;val];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (q != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (vis[q-&gt;val])</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            q = parent[q-&gt;val];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> q;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>113.路径总和 II</title>
    <url>/path-sum-ii/</url>
    <content><![CDATA[<h2 id="1-递归-回溯"><a href="#1-递归-回溯" class="headerlink" title="1. 递归+回溯"></a>1. 递归+回溯</h2><p>类似于“112.路经总和”，不过要记录路径上的各个点。<br>只需要在原有递归访问子节点并修改目标值的基础上，增加把当前节点加入数组的过程即可，在回到上一层时需要回溯。<br>时间<code>O(n^2)</code>，空间<code>O(n^2)</code>  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">pathSum</span><span class="params">(TreeNode* root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        dfs(root, sum);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        subAns.push_back(root-&gt;val);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left == <span class="literal">nullptr</span> &amp;&amp; root-&gt;right == <span class="literal">nullptr</span> &amp;&amp; root-&gt;val == sum) </span><br><span class="line">            ans.push_back(subAns);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left != <span class="literal">nullptr</span>) </span><br><span class="line">            dfs(root-&gt;left, sum - root-&gt;val);</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;right != <span class="literal">nullptr</span>)</span><br><span class="line">            dfs(root-&gt;right, sum - root-&gt;val);</span><br><span class="line">        </span><br><span class="line">        subAns.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; subAns;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2-迭代"><a href="#2-迭代" class="headerlink" title="2. 迭代"></a>2. 迭代</h2><p>层次遍历的访问方法，同“112.路径总和”的迭代访问一样，使用队列同时暂存对应的节点和当前目标值。<br>此外，由于这道题还需要获得具体路径，因此还需要一个额外的队列记录开头到当前节点的路径。  </p>
<p>这样的问题在于使用了较多的空间存储了较多重复还不一定有用的路径。<br>可以考虑最后确定路经总和能够到达目标值时，再寻找根到叶子结点的路径。<br>为了方便路径的寻找，可以使用hash表记录每个节点的根节点，从叶子节点出发直接一路找到根节点。  </p>
<p>另外此处需要扩展的是，使用hash表需要提供hash函数的问题。  </p>
<ul>
<li><strong>自建类型</strong>使用hash表是<strong>需要</strong>提供hash函数的，比如<code>unordered_map&lt;pair&lt;int, int&gt;, int&gt; m</code>就会报错，因为没提供pair类型的hash函数。  </li>
<li>而<strong>自建类型的指针</strong>是<strong>不需要</strong>的，比如<code>unordered_map&lt;pair&lt;int, int&gt;*, int&gt; m</code>就没有问题，同时指针不论指向何种类型，大小都是一样的。  </li>
</ul>
<p>时间<code>O(n^2)</code>，空间<code>O(n^2)</code>。  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">pathSum</span><span class="params">(TreeNode* root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        </span><br><span class="line">        parent[root] = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="built_in">pair</span>&lt;TreeNode*, <span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">        q.emplace(root, sum);</span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            TreeNode* cur = q.front().first;</span><br><span class="line">            <span class="keyword">int</span> curSum = q.front().second;</span><br><span class="line">            q.pop();</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (cur-&gt;left == <span class="literal">nullptr</span> &amp;&amp; cur-&gt;right == <span class="literal">nullptr</span> &amp;&amp; cur-&gt;val == curSum)</span><br><span class="line">                ans.push_back(getPath(cur));</span><br><span class="line">            <span class="keyword">if</span> (cur-&gt;left != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                parent[cur-&gt;left] = cur;</span><br><span class="line">                q.emplace(cur-&gt;left, curSum - cur-&gt;val);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cur-&gt;right != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                parent[cur-&gt;right] = cur;</span><br><span class="line">                q.emplace(cur-&gt;right, curSum - cur-&gt;val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">getPath</span><span class="params">(TreeNode* node)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path;</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            path.push_back(node-&gt;val);</span><br><span class="line">            node = parent[node];</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(path.begin(), path.end());      <span class="comment">//#include &lt;algorithm&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> path;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;TreeNode*, TreeNode*&gt; parent;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>树</tag>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>112. 路径总和</title>
    <url>/path-sum/</url>
    <content><![CDATA[<h2 id="1-递归"><a href="#1-递归" class="headerlink" title="1. 递归"></a>1. 递归</h2><p>递归访问子节点，同时修改目标值。<br>需要注意的是空节点被看作空，而不是0，所以需要调整边界条件的判断。<br>时间<code>O(n)</code>，空间<code>O(n)</code>。  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasPathSum</span><span class="params">(TreeNode* root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left == <span class="literal">nullptr</span> &amp;&amp; root-&gt;right == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> root-&gt;val == sum;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> hasPathSum(root-&gt;left, sum - root-&gt;val) || hasPathSum(root-&gt;right, sum - root-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2-迭代"><a href="#2-迭代" class="headerlink" title="2. 迭代"></a>2. 迭代</h2><p>使用队列暂存节点和当前的目标值，不断访问队首元素，判断其是否为叶子节点以及将其子节点和对应目标值入队列。<br>时间<code>O(n)</code>，空间<code>O(n)</code>。  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasPathSum</span><span class="params">(TreeNode* root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="built_in">pair</span>&lt;TreeNode*, <span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">        q.emplace(root, sum);</span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            TreeNode* cur = q.front().first;</span><br><span class="line">            <span class="keyword">int</span> curSum = q.front().second;</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="keyword">if</span> (cur-&gt;left == <span class="literal">nullptr</span> &amp;&amp; cur-&gt;right == <span class="literal">nullptr</span> &amp;&amp; cur-&gt;val == curSum) &#123;</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cur-&gt;left != <span class="literal">nullptr</span>)</span><br><span class="line">                q.emplace(cur-&gt;left, curSum - cur-&gt;val);</span><br><span class="line">            <span class="keyword">if</span> (cur-&gt;right != <span class="literal">nullptr</span>)</span><br><span class="line">                q.emplace(cur-&gt;right, curSum - cur-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>106. 从中序与后序遍历序列构造二叉树</title>
    <url>/construct-binary-tree-from-inorder-and-postorder-traversal/</url>
    <content><![CDATA[<h2 id="1-递归"><a href="#1-递归" class="headerlink" title="1. 递归"></a>1. 递归</h2><p>参照“105. 从前序与中序遍历序列构造二叉树”。<br>中序遍历：左根右<br>后序遍历：左右根  </p>
<p>从后序遍历结尾处获得当前的根节点，然后到中序遍历中查找根节点的位置，并以此划分中序和后序序列为左右子树两部分。<br>同时使用hash表优化，避免每次都要遍历中序序列才能找到根节点，降低时间复杂度。<br>时间<code>O(n)</code>，空间<code>O(n)</code>。  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; postorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = inorder.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) </span><br><span class="line">            index[inorder[i]] = i;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> buildTree(postorder, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; postorder, <span class="keyword">int</span> ibegin, <span class="keyword">int</span> iend, <span class="keyword">int</span> pbegin, <span class="keyword">int</span> pend)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ibegin &gt; iend)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        </span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> TreeNode(postorder[pend]);</span><br><span class="line">        <span class="keyword">int</span> leftCount = index[postorder[pend]] - ibegin;</span><br><span class="line">        root-&gt;left = buildTree(postorder, ibegin, ibegin + leftCount - <span class="number">1</span>, pbegin, pbegin + leftCount - <span class="number">1</span>);</span><br><span class="line">        root-&gt;right = buildTree(postorder, ibegin + leftCount + <span class="number">1</span>, iend, pbegin + leftCount, pend - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; index;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>105. 从前序与中序遍历序列构造二叉树</title>
    <url>/construct-binary-tree-from-perorder-and-inorder-traversal/</url>
    <content><![CDATA[<h2 id="1-递归"><a href="#1-递归" class="headerlink" title="1. 递归"></a>1. 递归</h2><p>前序遍历是根左右，因此前序序列的首个字符为根节点，之后一部分是左子树的节点，左子树部分的右侧一部分是右子树节点。<br>中序遍历是左根右，因此中序遍历的开头一部分是左子树的节点，然后是根节点，之后剩下的右部分是右子树的节点。  </p>
<p>因此可以首先根据前序遍历的首个字符，确定根节点。<br>然后在中序序列中找到根节点，其左侧的部分就是左子树的节点，右侧部分就是右子树的节点。<br>根据中序序列中左右部分的长度，就可以在前序序列中划分出左右子树的部分。<br>然后递归构造即可。<br>时间<code>O(n^2)</code>，空间<code>O(n)</code>。  </p>
<p>因为每次都要遍历中序序列，找到当前的root，所以时间复杂度比较高。<br>因此可以使用hash预先处理中序序列，之后每次就能用<code>O(1)</code>的方法查找到当前的root，时间复杂度降低到<code>O(n)</code>。<br><code>unordered_map&lt;序列中的值, 该值对应在序列中的位置&gt;</code>  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; preorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = preorder.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            index[inorder[i]] = i;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> buildTree(preorder, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; preorder, <span class="keyword">int</span> pstart, <span class="keyword">int</span> pend, <span class="keyword">int</span> istart, <span class="keyword">int</span> iend)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pstart &gt; pend)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        </span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> TreeNode(preorder[pstart]);</span><br><span class="line">        <span class="keyword">int</span> leftCount = index[preorder[pstart]] - istart;</span><br><span class="line">        root-&gt;left = buildTree(preorder, pstart + <span class="number">1</span>, pstart + leftCount, istart, istart + leftCount - <span class="number">1</span>);</span><br><span class="line">        root-&gt;right = buildTree(preorder, pstart + leftCount + <span class="number">1</span>, pend, istart + leftCount + <span class="number">1</span>, iend);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; index;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>501.二叉搜索树中的众数</title>
    <url>/find-mode-in-binary-search-tree/</url>
    <content><![CDATA[<h2 id="1-中序遍历-辅助数组"><a href="#1-中序遍历-辅助数组" class="headerlink" title="1. 中序遍历+辅助数组"></a>1. 中序遍历+辅助数组</h2><p>中序遍历获得有相同值的BST的非严格递增序列，存入辅助数组中，然后统计众数。<br>时间<code>O(n)</code>，空间<code>O(n)</code>。  </p>
<h2 id="2-中序遍历"><a href="#2-中序遍历" class="headerlink" title="2. 中序遍历"></a>2. 中序遍历</h2><p>在中序遍历的过程中，可以直接记录和统计当前数据的出现次数，跟之前出现过的最大次数比较即可，不需要辅助数组。<br>时间<code>O(n)</code>，空间<code>O(n)</code>。  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">findMode</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; st;</span><br><span class="line">        <span class="keyword">int</span> maxMode, maxCount = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> cur, curCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (root != <span class="literal">nullptr</span> || !st.empty()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                root = st.top();</span><br><span class="line">                st.pop();</span><br><span class="line">                <span class="keyword">if</span> (cur == root-&gt;val)</span><br><span class="line">                    curCount++;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    cur = root-&gt;val;</span><br><span class="line">                    curCount = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (curCount == maxCount) </span><br><span class="line">                    ans.push_back(cur);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (curCount &gt; maxCount) &#123;</span><br><span class="line">                    maxCount = curCount;</span><br><span class="line">                    <span class="keyword">if</span> (maxMode != cur) &#123;</span><br><span class="line">                        maxMode = cur;</span><br><span class="line">                        ans.clear();</span><br><span class="line">                        ans.push_back(maxMode);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                root = root-&gt;right;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                st.push(root);</span><br><span class="line">                root = root-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>617.合并二叉树</title>
    <url>/merge-two-binary-trees/</url>
    <content><![CDATA[<h2 id="1-递归"><a href="#1-递归" class="headerlink" title="1. 递归"></a>1. 递归</h2><p>合并两棵二叉树相当于新建一个值为两棵二叉树根节点值和的根节点，然后递归合并左子树和右子树。<br>时间<code>O(m + n)</code>，空间<code>O(m + n)</code>。  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">mergeTrees</span><span class="params">(TreeNode* t1, TreeNode* t2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (t1 == <span class="literal">nullptr</span> &amp;&amp; t2 == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        </span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> TreeNode(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (t1 != <span class="literal">nullptr</span>)</span><br><span class="line">            root-&gt;val += t1-&gt;val;</span><br><span class="line">        <span class="keyword">if</span> (t2 != <span class="literal">nullptr</span>)</span><br><span class="line">            root-&gt;val += t2-&gt;val;</span><br><span class="line">        </span><br><span class="line">        root-&gt;left = mergeTrees(t1 == <span class="literal">nullptr</span> ? <span class="literal">nullptr</span> : t1-&gt;left, t2 == <span class="literal">nullptr</span> ? <span class="literal">nullptr</span> : t2-&gt;left);</span><br><span class="line">        root-&gt;right = mergeTrees(t1 == <span class="literal">nullptr</span> ? <span class="literal">nullptr</span> : t1-&gt;right, t2 == <span class="literal">nullptr</span> ? <span class="literal">nullptr</span> : t2-&gt;right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>538.把二叉搜索树转换为累加树</title>
    <url>/convert-bst-to-greater-tree/</url>
    <content><![CDATA[<h2 id="1-中序遍历"><a href="#1-中序遍历" class="headerlink" title="1. 中序遍历"></a>1. 中序遍历</h2><p>BST的中序遍历得到的结果是从小到大的有序序列，可以使用一个数组记录这个序列，然后遍历BST，对每个节点累加值。<br>为了降低累加过程需要的时间，可以使用hash表统计大于各个值的节点值之和，从而避免每次都要重新求和。<br>时间<code>O(n)</code>，空间<code>O(n)</code>。  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">convertBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vals;</span><br><span class="line">        midOrder(root, vals);</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; sum;</span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = vals.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            temp += vals[i];</span><br><span class="line">            sum[vals[i]] = temp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        TreeNode* cur;</span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            cur = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            cur-&gt;val = sum[cur-&gt;val];</span><br><span class="line">            <span class="keyword">if</span> (cur-&gt;left != <span class="literal">nullptr</span>)</span><br><span class="line">                q.push(cur-&gt;left);</span><br><span class="line">            <span class="keyword">if</span> (cur-&gt;right != <span class="literal">nullptr</span>)</span><br><span class="line">                q.push(cur-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">midOrder</span><span class="params">(TreeNode* root, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; vals)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; st;</span><br><span class="line">        <span class="keyword">while</span> (root != <span class="literal">nullptr</span> || !st.empty()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                root = st.top();</span><br><span class="line">                st.pop();</span><br><span class="line">                vals.push_back(root-&gt;val);</span><br><span class="line">                root = root-&gt;right;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                st.push(root);</span><br><span class="line">                root = root-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2-反向中序遍历"><a href="#2-反向中序遍历" class="headerlink" title="2. 反向中序遍历"></a>2. 反向中序遍历</h2><p>要修改一个节点需要获取比这个节点大的值，比它大的值在它的右子树中，同时还来自于它的各层父节点（如果它是父节点的左孩子的话）。<br>如果按照这个思路求解每个节点的比它大的所有值是有些困难的，但是联想到中序遍历得到的有序序列就会比较简单。<br>中序左根右遍历BST得到的是由小到大的有序序列，因此反向中序右根左遍历BST得到的是由大到小的有序序列。<br>题目需要的比每个节点大的值正好由反向中序遍历提供了。<br>时间<code>O(n)</code>，空间<code>O(n)</code>。  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">convertBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        TreeNode* keepRoot = root;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; st;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (root != <span class="literal">nullptr</span> || !st.empty()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                root = st.top();</span><br><span class="line">                st.pop();</span><br><span class="line">                sum += root-&gt;val;</span><br><span class="line">                root-&gt;val = sum;</span><br><span class="line">                root = root-&gt;left;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                st.push(root);</span><br><span class="line">                root = root-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> keepRoot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>196.删除重复的电子邮箱</title>
    <url>/196-%E5%88%A0%E9%99%A4%E9%87%8D%E5%A4%8D%E7%9A%84%E7%94%B5%E5%AD%90%E9%82%AE%E7%AE%B1/</url>
    <content><![CDATA[<h2 id="1-group-by"><a href="#1-group-by" class="headerlink" title="1. group by"></a>1. group by</h2><p>因为要求保留每种邮箱中最小的Id，因此只需要根据邮箱分组，筛选出每组邮箱最小的Id，然后删除不是最小的Id即可。  </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> Person</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">Id</span> <span class="keyword">not</span> <span class="keyword">in</span> (</span><br><span class="line">    <span class="keyword">select</span> t.Id <span class="keyword">from</span> (</span><br><span class="line">        <span class="keyword">select</span> <span class="keyword">min</span>(<span class="keyword">Id</span>) <span class="keyword">as</span> <span class="keyword">Id</span></span><br><span class="line">        <span class="keyword">from</span> Person</span><br><span class="line">        <span class="keyword">group</span> <span class="keyword">by</span> Email</span><br><span class="line">    ) t</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h2 id="2-自连接"><a href="#2-自连接" class="headerlink" title="2. 自连接"></a>2. 自连接</h2><p>使用<code>delete t1 from t1, t2 where..</code>语句，而不是<code>delete from t1 where...</code>语句。<br>这条语句不是从t1和t2表连接得到的临时表中删除数据，而是根据where的条件从删除t1中的数据，from只是方便where的条件。  </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> p1</span><br><span class="line"><span class="keyword">from</span> Person p1 <span class="keyword">join</span> Person p2 <span class="keyword">on</span> p1.Email = p2.Email</span><br><span class="line"><span class="keyword">where</span> p1.Id &gt; p2.Id</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>sql</category>
      </categories>
      <tags>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title>从“各组得分最高的员工”到“各组得分前N高的员工“，以”部门公司前三高的所有员工“为例。</title>
    <url>/185-%E9%83%A8%E9%97%A8%E5%B7%A5%E8%B5%84%E5%89%8D%E4%B8%89%E9%AB%98%E7%9A%84%E6%89%80%E6%9C%89%E5%91%98%E5%B7%A5/</url>
    <content><![CDATA[<h2 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h2><p>首先需要了解<strong>“各组得分最高的员工”</strong>要如何求解，参考这篇文章：<br><a href="https://zkkkillua.github.io/184-%E9%83%A8%E9%97%A8%E5%B7%A5%E8%B5%84%E6%9C%80%E9%AB%98%E7%9A%84%E5%91%98%E5%B7%A5/">如何查找各组得分最高的员工？以“部门工资最高的员工”为例。</a></p>
<p>类比”184.部门工资最高的员工“，可以考虑找出每个分组的工资前三高的值，然后通过子查询或者是连接这个临时表找出各组工资前三高的员工。</p>
<p>但实际上，各组前三高的工资并不能像各组最高的工资一样直接group by就能求出，所以这个方法并没有想象中那么简单。</p>
<h2 id="前N高的含义"><a href="#前N高的含义" class="headerlink" title="前N高的含义"></a>前N高的含义</h2><p>所以可以考虑工资前N高的含义，即工资比这些员工高的不到N个。</p>
<p>以下以 leetcode <a href="https://leetcode-cn.com/problems/department-top-three-salaries/">185.部门工资前三高的所有员工</a>为例。</p>
<h3 id="1-子查询"><a href="#1-子查询" class="headerlink" title="1. 子查询"></a>1. 子查询</h3><p>可以使用子查询，对于每一条数据在子查询中查找工资更高的，并通过count()统计个数。</p>
<p>由于子查询跟外部查询相关，因此这里的子查询是相关子查询，对于外部的每一条数据都要进行一次子查询，效率较低。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> d.Name <span class="keyword">as</span> Department, e1.name <span class="keyword">as</span> Employee, e1.Salary</span><br><span class="line"><span class="keyword">from</span> Employee e1 <span class="keyword">join</span> Department d <span class="keyword">on</span> e1.DepartmentId = d.Id</span><br><span class="line"><span class="keyword">where</span> <span class="number">3</span> &gt; (</span><br><span class="line">    <span class="keyword">select</span> <span class="keyword">count</span>(<span class="keyword">distinct</span> e2.Salary)</span><br><span class="line">    <span class="keyword">from</span> Employee e2</span><br><span class="line">    <span class="keyword">where</span> e1.DepartmentId = e2.DepartmentId <span class="keyword">and</span> e1.Salary &lt; e2.Salary</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h3 id="2-自连接"><a href="#2-自连接" class="headerlink" title="2. 自连接"></a>2. 自连接</h3><p>由于上述相关子查询的效率较低，因此可以考虑使用自连接，通过on控制条件，使得连接起来的数据属于同一个部门，并且之前存在工资的大小关系。</p>
<p>这条连接查询语句的效率要比上述使用相关子查询的语句高。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> d.Name <span class="keyword">as</span> Department, e1.name <span class="keyword">as</span> Employee, e1.Salary</span><br><span class="line"><span class="keyword">from</span> Employee e1 <span class="keyword">join</span> Department d <span class="keyword">on</span> e1.DepartmentId = d.Id <span class="keyword">join</span> Employee e2 <span class="keyword">on</span> e1.DepartmentId = e2.DepartmentId <span class="keyword">and</span> e1.Salary &lt;= e2.Salary</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> e1.Id</span><br><span class="line"><span class="keyword">having</span> <span class="number">3</span> &gt;= <span class="keyword">count</span>(<span class="keyword">distinct</span> e2.Salary);</span><br></pre></td></tr></table></figure>



<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>类似地，也可以使用这种方法找出<strong>”所有人中排名前N的员工“</strong>（可以直接order by），<strong>”每个组中排名前N的员工“</strong>，以及<strong>”所有人/每个部门排名第N的员工“</strong>（order by … limit 或上述换为等号）等。  </p>
]]></content>
      <categories>
        <category>sql</category>
      </categories>
      <tags>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title>78.子集</title>
    <url>/subsets/</url>
    <content><![CDATA[<h2 id="1-递归-回溯"><a href="#1-递归-回溯" class="headerlink" title="1. 递归+回溯"></a>1. 递归+回溯</h2><p>类似于求各种组合，选择-&gt;递归选择之后的元素-&gt;回溯。<br>为了避免重复计算，在每次递归时将数组加入答案中即可，不需要每个数组都是从头开始计算。<br>时间<code>O(n*2^n)</code>，空间<code>O(n)</code>递归栈。  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">subsets</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        dfs(nums, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> begin)</span> </span>&#123;</span><br><span class="line">        ans.push_back(subAns);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = begin; i &lt; n; i++) &#123;</span><br><span class="line">            subAns.push_back(nums[i]);</span><br><span class="line">            dfs(nums, i + <span class="number">1</span>);</span><br><span class="line">            subAns.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; subAns;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2-迭代"><a href="#2-迭代" class="headerlink" title="2. 迭代"></a>2. 迭代</h2><p>首先记录空集，然后在此基础上每次向后追加新元素。<br>如：<code>[] -&gt; [], [1] -&gt; [], [1], [2], [1,2] -&gt; [], [1], [2], [1,2], [3], [1,3], [2,3], [1,2,3]</code>  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">subsets</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">            </span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; subAns;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line"></span><br><span class="line">        ans.push_back(subAns);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> curSize = ans.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; curSize; j++) &#123;</span><br><span class="line">                subAns = ans[j];</span><br><span class="line">                subAns.push_back(nums[i]);</span><br><span class="line">                ans.push_back(subAns);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>如何查找各组得分最高的员工？以“部门工资最高的员工”为例。</title>
    <url>/184-%E9%83%A8%E9%97%A8%E5%B7%A5%E8%B5%84%E6%9C%80%E9%AB%98%E7%9A%84%E5%91%98%E5%B7%A5/</url>
    <content><![CDATA[<h2 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h2><p>首先需要掌握的是查找所有人中得分最高的员工。  </p>
<p>如果只查最高分的话，<code>select max(score) from table</code>就足够了。而如果还需要查出相关人员的信息，则需要进行一定的调整。</p>
<h3 id="1-子查询"><a href="#1-子查询" class="headerlink" title="1. 子查询"></a>1. 子查询</h3><p>一种查询方式是使用子查询，首先查找出所有人中最高的得分，然后扫描整个表，查找分数等于最高分的人。  </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> e.Name, e.Salary</span><br><span class="line"><span class="keyword">from</span> Employee e</span><br><span class="line"><span class="keyword">where</span> e.Salary = (</span><br><span class="line">    <span class="keyword">select</span> <span class="keyword">max</span>(Salary)</span><br><span class="line">    <span class="keyword">from</span> Employee);</span><br></pre></td></tr></table></figure>

<p>子查询一般可以转换为连接查询的形式。<br>并且<strong>由于子查询过程会生成和删除临时表，因此速度一般要比连接查询慢</strong>。</p>
<p>另外此处联系一下<strong>相关子查询</strong>和<strong>非相关子查询</strong>：</p>
<ul>
<li><strong>非相关子查询</strong>：子查询跟外部查询是无关的，执行过程是先执行子查询返回一个结果供外部查询使用。</li>
<li><strong>相关子查询</strong>：子查询跟外部查询是相关的，执行过程是外部查询每查询一行，就要将该行的相关数据传递给子查询使用，即每一行都需要进行一次子查询，因此效率较低。</li>
</ul>
<h3 id="2-连接查询"><a href="#2-连接查询" class="headerlink" title="2. 连接查询"></a>2. 连接查询</h3><h4 id="2-1-连接临时表"><a href="#2-1-连接临时表" class="headerlink" title="2.1. 连接临时表"></a>2.1. 连接临时表</h4><p>首先查询出所有人中最高的得分，然后将结果作为临时表与原来的表进行连接，通过连接筛选出满足要求的结果。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> e.Name, e.Salary</span><br><span class="line"><span class="keyword">from</span> Employee e <span class="keyword">join</span> (</span><br><span class="line">    <span class="keyword">select</span> <span class="keyword">max</span>(Salary) <span class="keyword">as</span> Salary</span><br><span class="line">    <span class="keyword">from</span> Employee) t <span class="keyword">on</span> e.Salary = t.Salary;</span><br></pre></td></tr></table></figure>

<h4 id="2-2-自连接"><a href="#2-2-自连接" class="headerlink" title="2.2. 自连接"></a>2.2. 自连接</h4><p>使用on控制连接条件，通过having计数得到最大值。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> e1.Name, e1.Salary</span><br><span class="line"><span class="keyword">from</span> Employee e1 <span class="keyword">join</span> Employee e2 <span class="keyword">on</span> e1.Salary &lt;= e2.Salary</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> e1.Id</span><br><span class="line"><span class="keyword">having</span> <span class="keyword">count</span>(<span class="keyword">distinct</span> e2.Salary) = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>



<h2 id="各组最高"><a href="#各组最高" class="headerlink" title="各组最高"></a>各组最高</h2><p><strong>文章中使用的表基于leetcode <a href="https://leetcode-cn.com/problems/department-highest-salary/">184. 部门工资最高的员工</a>。</strong></p>
<p>首先<code>Employee left join Department</code>得到一个员工信息和部门信息关联的临时表。<br>然后<code>group by DepartmentId</code>分组，从每个组中找出max值。  </p>
<h3 id="错误示范1"><a href="#错误示范1" class="headerlink" title="错误示范1"></a>错误示范1</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> d.Name <span class="keyword">as</span> Department, e.Name <span class="keyword">as</span> Employee, <span class="keyword">max</span>(Salary) <span class="keyword">as</span> Salary</span><br><span class="line"><span class="keyword">from</span> Employee e <span class="keyword">left</span> <span class="keyword">join</span> Department d <span class="keyword">on</span> e.DepartmentId = d.Id</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> e.DepartmentId;</span><br></pre></td></tr></table></figure>
<p>上述代码错误的原因是，select中的max只挑选出了一个最大值，而忽略了可能有多个员工的薪资同为最大值的情况。<br><strong>并且！select找出的max(Salary)并不是对应的行的Salary，而是整个组中的Salary</strong><br>另外还存在的问题是，对于mysql 5.7及以上的版本，select的字段必须是被group by包含的字段，或是使用聚合函数。  </p>
<h3 id="错误示范2"><a href="#错误示范2" class="headerlink" title="错误示范2"></a>错误示范2</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> d.Name <span class="keyword">as</span> Department, e.Name <span class="keyword">as</span> Employee, Salary</span><br><span class="line"><span class="keyword">from</span> Employee e <span class="keyword">left</span> <span class="keyword">join</span> Department d <span class="keyword">on</span> e.DepartmentId = d.Id</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> e.DepartmentId</span><br><span class="line"><span class="keyword">having</span> Salary = <span class="keyword">max</span>(Salary);</span><br></pre></td></tr></table></figure>
<p>上述代码看似解决了max只能去除最大值的问题，以及max(Salary)不是对应行的Salary的问题.<br>但是having子句中是不能出现非聚合函数中的属性名的，原因是group by分组之后得到的是组中的1条数据，所以having Salary只能获得这一条数据的Salary。<br>解决方法是不要在having子句中出现非聚合函数和非具体数据的其他字段。  </p>
<h3 id="正确答案"><a href="#正确答案" class="headerlink" title="正确答案"></a>正确答案</h3><h4 id="1-子查询-1"><a href="#1-子查询-1" class="headerlink" title="1. 子查询"></a>1. 子查询</h4><p>首先找出每个分组及其最大值，然后判断表中每条数据的分组和Salary是否和这个相等。  </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> d.Name <span class="keyword">as</span> Department, e.Name <span class="keyword">as</span> Employee, Salary</span><br><span class="line"><span class="keyword">from</span> Employee e <span class="keyword">join</span> Department d <span class="keyword">on</span> e.DepartmentId = d.Id</span><br><span class="line"><span class="keyword">where</span> (e.DepartmentId, e.Salary) <span class="keyword">in</span> (</span><br><span class="line">    <span class="keyword">select</span> DepartmentId, <span class="keyword">max</span>(Salary)</span><br><span class="line">    <span class="keyword">from</span> Employee</span><br><span class="line">    <span class="keyword">group</span> <span class="keyword">by</span> DepartmentId</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h4 id="2-连接查询-1"><a href="#2-连接查询-1" class="headerlink" title="2. 连接查询"></a>2. 连接查询</h4><h5 id="2-1-连接临时表-1"><a href="#2-1-连接临时表-1" class="headerlink" title="2.1. 连接临时表"></a>2.1. 连接临时表</h5><p>Employee和查询出来的每个分组的最大值连接。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> d.Name <span class="keyword">as</span> Department, e.Name <span class="keyword">as</span> Employee, e.Salary</span><br><span class="line"><span class="keyword">from</span> Employee e <span class="keyword">join</span> Department d <span class="keyword">on</span> e.DepartmentId = d.Id <span class="keyword">join</span> (</span><br><span class="line">    <span class="keyword">select</span> DepartmentId, <span class="keyword">max</span>(Salary) <span class="keyword">as</span> Salary</span><br><span class="line">    <span class="keyword">from</span> Employee</span><br><span class="line">    <span class="keyword">group</span> <span class="keyword">by</span> DepartmentId) t <span class="keyword">on</span> e.DepartmentId = t.DepartmentId <span class="keyword">and</span> e.Salary = t.Salary;</span><br></pre></td></tr></table></figure>

<h5 id="2-2-自连接-1"><a href="#2-2-自连接-1" class="headerlink" title="2.2. 自连接"></a>2.2. 自连接</h5><p>Employee和自身连接，on的条件为部门相同且同时约束Salary的大小。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> d.Name <span class="keyword">as</span> Department, e1.Name <span class="keyword">as</span> Employee, e1.Salary</span><br><span class="line"><span class="keyword">from</span> Employee e1 <span class="keyword">join</span> Department d <span class="keyword">on</span> e1.DepartmentId = d.Id <span class="keyword">join</span> Employee e2 <span class="keyword">on</span> e1.DepartmentId = e2.DepartmentId <span class="keyword">and</span> e1.Salary &lt;= e2.Salary</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> e1.Id</span><br><span class="line"><span class="keyword">having</span> <span class="keyword">count</span>(<span class="keyword">distinct</span> e2.Salary) = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>从最高扩展到前N高/第N高如何计算，请参考：</p>
<p><a href="https://zkkkillua.github.io/185-%E9%83%A8%E9%97%A8%E5%B7%A5%E8%B5%84%E5%89%8D%E4%B8%89%E9%AB%98%E7%9A%84%E6%89%80%E6%9C%89%E5%91%98%E5%B7%A5/">从“各组得分最高的员工”到“各组得分前N高的员工“，以”部门公司前三高的所有员工“为例。</a></p>
]]></content>
      <categories>
        <category>sql</category>
      </categories>
      <tags>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title>181.超过经理收入的员工</title>
    <url>/181-%E8%B6%85%E8%BF%87%E7%BB%8F%E7%90%86%E6%94%B6%E5%85%A5%E7%9A%84%E5%91%98%E5%B7%A5/</url>
    <content><![CDATA[<h2 id="1-salary-gt"><a href="#1-salary-gt" class="headerlink" title="1. salary &gt;"></a>1. salary &gt;</h2><p>通过子查询找出员工的老板，然后select出salary高的员工。<br>这个方法的缺点是对于每个员工，都要执行一次子查询，速度慢。  </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">Name</span> <span class="keyword">as</span> Employee</span><br><span class="line"><span class="keyword">from</span> Employee <span class="keyword">as</span> e</span><br><span class="line"><span class="keyword">where</span> e.Salary &gt; (<span class="keyword">select</span> Salary <span class="keyword">from</span> Employee <span class="keyword">where</span> <span class="keyword">Id</span> = e.ManagerId);</span><br></pre></td></tr></table></figure>

<h2 id="2-内连接"><a href="#2-内连接" class="headerlink" title="2. 内连接"></a>2. 内连接</h2><p>根据Id和ManagerId相等进行自身的内连接，另外还可以附加上salary高的条件。  </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> a.Name <span class="keyword">as</span> Employee</span><br><span class="line"><span class="keyword">from</span> Employee a <span class="keyword">join</span> Employee b <span class="keyword">on</span> a.ManagerId = b.Id <span class="keyword">and</span> a.Salary &gt; b.Salary</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>sql</category>
      </categories>
      <tags>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title>178.分数排名</title>
    <url>/178-%E5%88%86%E6%95%B0%E6%8E%92%E5%90%8D/</url>
    <content><![CDATA[<p>名次实际上就是计算比当前元素大的值的个数，要求名次之间没有间隔，加个distinct即可。<br>灵活使用as重命名。  </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> Score, (<span class="keyword">select</span> <span class="keyword">count</span>(<span class="keyword">distinct</span> Score) <span class="keyword">from</span> Scores <span class="keyword">where</span> Score &gt;= s.Score) <span class="keyword">as</span> <span class="string">`Rank`</span></span><br><span class="line"><span class="keyword">from</span> Score <span class="keyword">as</span> s</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> Score <span class="keyword">desc</span>;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>sql</category>
      </categories>
      <tags>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title>176.第二高的薪水</title>
    <url>/176-%E7%AC%AC%E4%BA%8C%E9%AB%98%E7%9A%84%E8%96%AA%E6%B0%B4/</url>
    <content><![CDATA[<h3 id="1-找出最大值，再从小于最大值的值中找出最大值"><a href="#1-找出最大值，再从小于最大值的值中找出最大值" class="headerlink" title="1. 找出最大值，再从小于最大值的值中找出最大值"></a>1. 找出最大值，再从小于最大值的值中找出最大值</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">max</span>(Salary) <span class="keyword">as</span> SecondHighestSalary</span><br><span class="line"><span class="keyword">from</span> Employee</span><br><span class="line"><span class="keyword">where</span> Salary &lt; (<span class="keyword">select</span> <span class="keyword">max</span>(Salary) <span class="keyword">from</span> Employee)</span><br></pre></td></tr></table></figure>
<p>这种方法的优点是如果存在第二大的，则一定能返回；如果不存在，则会返回null。<br>缺点是难以处理第3, 4, 5…大的数据。  </p>
<h3 id="2-limit与offset"><a href="#2-limit与offset" class="headerlink" title="2. limit与offset"></a>2. <code>limit</code>与<code>offset</code></h3><p><code>limit</code>可以限制结果的条数，<code>offset</code>是跟<code>limit</code>连用的，可以限制<code>limit</code>开始的位置。<br>如数据为1,2,3,4,5，<code>limit 2</code>获得的是1,2，而如果<code>limit 2 offset 1</code>返回的就是2，3，开始<code>limit</code>的位置向后偏移了1位。<br>另外，<code>limit m offset n</code>可以写成<code>limit n, m</code><br>如果offset超出了数据范围，则不会报错，结果会得到空集，代表0条记录，而不是结果为null。  </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> Salary <span class="keyword">as</span> SecondHighestSalary</span><br><span class="line"><span class="keyword">from</span> Employee</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> Salary <span class="keyword">desc</span></span><br><span class="line"><span class="keyword">limit</span> <span class="number">1</span> <span class="keyword">offset</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>上述代码的问题是，当不存在第二大的值时，如仅有数据为2，offset超出范围，返回的结果是空集，而不是题目中要求的null。<br>为了解决这个特殊情况，使用<code>IFNULL(expression, alt_value)</code>函数，当expression为null时返回alt_value，当expression不为null时，返回expression。<br>修改上述代码为：  </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">ifnull</span>(</span><br><span class="line">    (<span class="keyword">select</span> <span class="keyword">distinct</span> Salary</span><br><span class="line">    <span class="keyword">from</span> Employee</span><br><span class="line">    <span class="keyword">order</span> <span class="keyword">by</span> Salary <span class="keyword">desc</span></span><br><span class="line">    <span class="keyword">limit</span> <span class="number">1</span> <span class="keyword">offset</span> <span class="number">1</span>), <span class="literal">null</span>) <span class="keyword">as</span> SecondHighestSalary;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>sql</category>
      </categories>
      <tags>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title>404.左叶子之和</title>
    <url>/sum-of-left-leaves/</url>
    <content><![CDATA[<h2 id="1-递归"><a href="#1-递归" class="headerlink" title="1. 递归"></a>1. 递归</h2><p>递归求解左叶子的和，直接在最小的树（2层）中定位到左叶子，而不是递归到只剩一个节点，因为这样无法判断左右。<br>时间<code>O(n)</code>，空间<code>O(n)</code>.  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumOfLeftLeaves</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;left != <span class="literal">nullptr</span> &amp;&amp; root-&gt;left-&gt;left == <span class="literal">nullptr</span> &amp;&amp; root-&gt;left-&gt;right == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> root-&gt;left-&gt;val + sumOfLeftLeaves(root-&gt;right);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> sumOfLeftLeaves(root-&gt;left) + sumOfLeftLeaves(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2-迭代"><a href="#2-迭代" class="headerlink" title="2. 迭代"></a>2. 迭代</h2><p>使用层次遍历，逐个判断是否为左叶子。<br>时间<code>O(n)</code>，空间<code>O(n)</code>。  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumOfLeftLeaves</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            TreeNode* cur = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="keyword">if</span> (cur-&gt;left != <span class="literal">nullptr</span> &amp;&amp; cur-&gt;left-&gt;left == <span class="literal">nullptr</span> &amp;&amp; cur-&gt;left-&gt;right == <span class="literal">nullptr</span>)</span><br><span class="line">                ans += cur-&gt;left-&gt;val;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cur-&gt;left != <span class="literal">nullptr</span>)</span><br><span class="line">                q.push(cur-&gt;left);</span><br><span class="line">            <span class="keyword">if</span> (cur-&gt;right != <span class="literal">nullptr</span>)</span><br><span class="line">                q.push(cur-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>47.全排列 II</title>
    <url>/permutations-ii/</url>
    <content><![CDATA[<h2 id="1-回溯"><a href="#1-回溯" class="headerlink" title="1. 回溯"></a>1. 回溯</h2><p>类似的题目是46.全排列，数组中不包含可重复数字，所以直接对于每一位遍历每一个，选择然后回溯不选择。<br>而这道题目的数组中包含重复数字，因此如果按照上述方法，会出现重复排列。<br>如：  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">   &#x2F;   |   \  </span><br><span class="line">  1    1    2      位置1 </span><br><span class="line"> &#x2F;\   &#x2F;\    &#x2F;\  </span><br><span class="line">1  2  1 2   1 1    位置2  </span><br><span class="line">|  |  | |   | |  </span><br><span class="line">2  1  2 1   1 1    位置3  </span><br></pre></td></tr></table></figure>
<p>出现重复排列的原因是，对于当前位置，已经选择过的数字在之后又被重新选择了（但选择的不是同一个元素，只是它们的值相等）<br>因此避免重复的方法就是，在当前位置，避免选择之前已经选择过的数字。  </p>
<p>想象在当前位置，第一次选择某个数字，则这个数字一定是所有相等的数字中，第一个在数组中未被选择的，选择它并置vis为true。<br>在获得当前位置为这个数字得到的所有排列之后，当前位置的数字被重新选择，并将之前元素的vis置为false。<br>如果选择到的元素还是相等的数字，则之后的排列一定是已经获得过的，并且可以发现它不是数组的相等数字中第一个未被选择的。<br>因此算法是，先将数组排序，将相等的元素放在一起，然后dfs，选择元素时只选择前一个相等元素被选择过的。<br>时间<code>O(n*n!)</code>，空间<code>O(n)</code>。  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">permuteUnique</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">vis</span><span class="params">(n, <span class="literal">false</span>)</span></span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; subAns;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line"></span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        dfs(nums, vis, subAns, ans);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&amp; vis, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; subAns, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; ans)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">if</span> (subAns.size() == n) &#123;</span><br><span class="line">            ans.push_back(subAns);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] &amp;&amp; !vis[i - <span class="number">1</span>])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (!vis[i]) &#123;</span><br><span class="line">                subAns.push_back(nums[i]);</span><br><span class="line">                vis[i] = <span class="literal">true</span>;</span><br><span class="line">                dfs(nums, vis, subAns, ans);</span><br><span class="line">                subAns.pop_back();</span><br><span class="line">                vis[i] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>226.翻转二叉树</title>
    <url>/invert-binary-tree/</url>
    <content><![CDATA[<h2 id="1-递归"><a href="#1-递归" class="headerlink" title="1. 递归"></a>1. 递归</h2><p>先交换左右子节点，然后再递归反转左右子树。<br>时间<code>O(n)</code>，空间<code>O(n)</code>。  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">invertTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            TreeNode* temp = root-&gt;left;</span><br><span class="line">            root-&gt;left = root-&gt;right;</span><br><span class="line">            root-&gt;right = temp;</span><br><span class="line">            invertTree(root-&gt;left);</span><br><span class="line">            invertTree(root-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>145.二叉树的后序遍历</title>
    <url>/binary-tree-postorder-traversal/</url>
    <content><![CDATA[<h2 id="相关"><a href="#相关" class="headerlink" title="相关"></a>相关</h2><ol>
<li>二叉树的前序遍历：144</li>
<li>二叉树的中序遍历：94</li>
<li>N叉树的前序遍历：589</li>
<li>N叉树的后序遍历：590</li>
</ol>
<h2 id="1-递归"><a href="#1-递归" class="headerlink" title="1. 递归"></a>1. 递归</h2><p>左右根<br>时间<code>O(n)</code>，空间<code>O(n)</code>。  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        postorderTraversal(ans, root);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">postorderTraversal</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; ans, TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        postorderTraversal(ans, root-&gt;left);</span><br><span class="line">        postorderTraversal(ans, root-&gt;right);</span><br><span class="line">        ans.push_back(root-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2-迭代"><a href="#2-迭代" class="headerlink" title="2. 迭代"></a>2. 迭代</h2><ol>
<li><p>左左左，放入栈中</p>
</li>
<li><p>当<code>root == nullptr</code>时，取栈顶元素，如果当前栈顶元素的right不为nullptr，则放回栈顶元素，令<code>root = top-&gt;right</code>，回到1。（实际上就相当于先不弹出栈顶元素）</p>
</li>
<li><p>但是只这样写的代码是可能陷入死循环的，原因是right访问完又回到父节点，而父节点又访问了right，造成循环。<br>比如下面的错误代码：  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1  </span><br><span class="line"> \  </span><br><span class="line">  2  </span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; st;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (root != <span class="literal">nullptr</span> || !st.empty()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (st.top()-&gt;right != <span class="literal">nullptr</span>)</span><br><span class="line">                    root = st.top()-&gt;right;     <span class="comment">// 此处死循环</span></span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    root = st.top();</span><br><span class="line">                    st.pop();</span><br><span class="line">                    ans.push_back(root-&gt;val);</span><br><span class="line">                    root = <span class="literal">nullptr</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                st.push(root);</span><br><span class="line">                root = root-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>解决循环的方法：</strong>  </p>
<ol>
<li>在访问栈顶的right前，push到栈中一个nullptr作为标记，当再次访问栈顶遇到nullptr时，说明次栈顶的right已访问过。  </li>
<li>因为在栈中，root和root-&gt;right一定是相邻的（如果有的话），所以可以使用一个指针记录当前访问的地址，在需要取栈顶的right时，对比二者是否相等，可以得知是否已经访问过right。  </li>
</ol>
<p><strong>方法1：</strong>  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; st;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (root != <span class="literal">nullptr</span> || !st.empty()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (st.top() == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                    st.pop();</span><br><span class="line">                    root = st.top();</span><br><span class="line">                    st.pop();</span><br><span class="line">                    ans.push_back(root-&gt;val);</span><br><span class="line">                    root = <span class="literal">nullptr</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (st.top()-&gt;right != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                    root = st.top()-&gt;right;</span><br><span class="line">                    st.push(<span class="literal">nullptr</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (st.top()-&gt;right == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                    root = st.top();</span><br><span class="line">                    st.pop();</span><br><span class="line">                    ans.push_back(root-&gt;val);</span><br><span class="line">                    root = <span class="literal">nullptr</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                st.push(root);</span><br><span class="line">                root = root-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>方法2：</strong>  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; st;</span><br><span class="line"></span><br><span class="line">        TreeNode* pre = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span> (root != <span class="literal">nullptr</span> || !st.empty()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (st.top()-&gt;right != <span class="literal">nullptr</span> &amp;&amp; st.top()-&gt;right != pre) </span><br><span class="line">                    root = st.top()-&gt;right;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    root = st.top();</span><br><span class="line">                    st.pop();</span><br><span class="line">                    ans.push_back(root-&gt;val);</span><br><span class="line">                    pre = root;</span><br><span class="line">                    root = <span class="literal">nullptr</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                st.push(root);</span><br><span class="line">                root = root-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>590.N叉树的后序遍历</title>
    <url>/n-ary-tree-postorder-traversal/</url>
    <content><![CDATA[<h2 id="相关"><a href="#相关" class="headerlink" title="相关"></a>相关</h2><ol>
<li>二叉树的前序遍历：144</li>
<li>二叉树的中序遍历：94</li>
<li>二叉树的后序遍历：145</li>
<li>N叉树的前序遍历：589</li>
</ol>
<h2 id="1-递归"><a href="#1-递归" class="headerlink" title="1. 递归"></a>1. 递归</h2><p>时间<code>O(n)</code>，空间<code>O(n)</code>。  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    vector&lt;Node*&gt; children;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node() &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val, vector&lt;Node*&gt; _children) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        children = _children;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">postorder</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        postorder(ans, root);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">postorder</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; ans, Node* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; root-&gt;children.size(); i++)</span><br><span class="line">            postorder(ans, root-&gt;children[i]);</span><br><span class="line">        ans.push_back(root-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2-迭代"><a href="#2-迭代" class="headerlink" title="2. 迭代"></a>2. 迭代</h2><ol>
<li>访问到一个root节点时，将其子节点从右到左移次放入栈中。  </li>
<li><code>root = root-&gt;children[0], if(!(root-&gt;children.empty())</code></li>
<li>当root为空时，并且栈顶元素的右子树已访问完毕时（使用nullptr入栈作为标记或者pre记录上一次访问的指针并与root的最右子节点比较），取栈顶元素访问；当栈顶元素的子节点还未被访问时，到1.<br>这里相比于145.二叉树的后序遍历的一点不同是需要将子节点自右向左放入栈中。<br>实际上二叉树的后序遍历也是需要将子节点自右至左放入栈中，即先放右节点，再放左节点。但是由于在判断栈顶元素的右子节点还未访问时，需要将右子节点入栈，因此这两个过程就合并起来了。<br>而在N叉树的后序遍历中，由于不方便记录到底是访问到了root的哪一个子节点，所以最好还是在开始时就将子节点自右向左存入栈中。  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">postorder</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="built_in">stack</span>&lt;Node*&gt; st;</span><br><span class="line">        st.push(root);</span><br><span class="line"></span><br><span class="line">        Node* pre = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span> (root != <span class="literal">nullptr</span> || !st.empty()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                Node* temp = st.top();</span><br><span class="line">                <span class="keyword">if</span> (temp-&gt;children.empty() || pre == temp-&gt;children[temp-&gt;children.size() - <span class="number">1</span>]) &#123;</span><br><span class="line">                    st.pop();</span><br><span class="line">                    ans.push_back(temp-&gt;val);</span><br><span class="line">                    pre = temp;</span><br><span class="line">                &#125; <span class="keyword">else</span></span><br><span class="line">                    root = temp;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = root-&gt;children.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">                    st.push(root-&gt;children[i]);</span><br><span class="line">                root = root-&gt;children.empty() ? <span class="literal">nullptr</span> : root-&gt;children[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>377. 组合总和IV</title>
    <url>/combination-sum-iv/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这道题目跟“39.组合总和”是一样的，都是无重复数组，可重复选择。<br>区别是39题返回的是全部的组合（数组），而这道题是仅返回组合数目。<br>所以39题需要使用递归和回溯，在此过程中记录满足要求的组合到数组中；而由于递归过程中出现了许多重复计算，并且在这道题中仅要求组合的数目，不需要组合，因此使用记忆化去掉重复计算。  </p>
<h2 id="1-递归-回溯"><a href="#1-递归-回溯" class="headerlink" title="1. 递归+回溯"></a>1. 递归+回溯</h2><p>可以重复选择，并且考虑顺序，因此在递归时全部从头重新选择。<br>超时。  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">combinationSum4</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        ans = <span class="number">0</span>;</span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        dfs(nums, target);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">0</span>) &#123;</span><br><span class="line">            ans++;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (target &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (target &lt; nums[i])</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            dfs(nums, target - nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2-dp"><a href="#2-dp" class="headerlink" title="2. dp"></a>2. dp</h2><p>通过下图可以看到，重复的选择非常多。<br><img src="repetition.png" alt="repetition"><br>虽然之前回溯做过的组合总和题目中，也有重复选择，但是由于之前的题目都是在下次递归时会将数组的索引向前推进一个，所以不会有太多的重复选择。<br>所以此处做一个记忆化，可以使用<code>dp[i]</code>记录target为i的组合答案。<br><code>dp[i] = sum(dp[i - nums[j]])</code><br>时间<code>O(kn)</code>，空间<code>O(k)</code>  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">combinationSum4</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(target + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= target; i++) </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">                <span class="keyword">if</span> (i - nums[j] &gt;= <span class="number">0</span>)</span><br><span class="line">                    dp[i] += dp[i - nums[j]];   <span class="comment">// overflow!</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上面这种算法计算了1到target的每个取值的组合数。<br>对于<code>[3, 33, 333], 10000</code>这组数据来说，求解target为9999时溢出极为严重（long long都不能cover），并且实际上target为10000是组合数为0.<br>所以可以改为递归计算，从<code>dp[target]</code>开始，需要什么就通过递归计算其值。<br>需要注意的是，递归更可能出现重复，比如dp[10]=0，后面还会多次重复计算dp[10]的值，所以可以考虑把已经计算过的仍为0的结果置为-1，代表已经计算过，不需要重复计算。  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">combinationSum4</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">count</span><span class="params">(target + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        count[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp(nums, count, target);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dp</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; count, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (count[k] == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++)</span><br><span class="line">                <span class="keyword">if</span> (k &gt;= nums[i])</span><br><span class="line">                    count[k] += dp(nums, count, k - nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (count[k] == <span class="number">0</span>) </span><br><span class="line">            count[k] = <span class="number">-1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (count[k] == <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> count[k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>216.组合总和III</title>
    <url>/combination-sum-iii/</url>
    <content><![CDATA[<h2 id="1-递归-回溯"><a href="#1-递归-回溯" class="headerlink" title="1. 递归+回溯"></a>1. 递归+回溯</h2><p>还是基本的递归回溯模板，只是将candidates数组改为了1~9的正整数，并且除了和为target之外还限制了数的个数。  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">combinationSum3</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        dfs(<span class="number">1</span>, <span class="number">9</span>, k, n);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> begin, <span class="keyword">int</span> end, <span class="keyword">int</span> count, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (sum == <span class="number">0</span> &amp;&amp; count == <span class="number">0</span>) &#123;</span><br><span class="line">            ans.push_back(subAns);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (count &gt; <span class="number">0</span> &amp;&amp; sum &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = begin; i &lt;= end; i++) &#123;</span><br><span class="line">                subAns.push_back(i);</span><br><span class="line">                dfs(i + <span class="number">1</span>, end, count - <span class="number">1</span>, sum - i);</span><br><span class="line">                subAns.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; subAns;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>40.组合总和II</title>
    <url>/combination-sum-ii/</url>
    <content><![CDATA[<h2 id="1-递归-回溯"><a href="#1-递归-回溯" class="headerlink" title="1. 递归+回溯"></a>1. 递归+回溯</h2><p>39.组合总和是无重复数字，可重复使用；这道题是有重复数字，不可重复使用。<br>如果直接按照普通的回溯做，是可能出现重复组合的。<br>比如[1, 1, 3, 1]和4，会出现3组[1, 3]的组合。  </p>
<p>解决方法是排序后，每一层级的相同数字只使用第一个元素向后扫描一次。<br>如[1, 2, 3, 2, 2]和5，首先排序为[1, 2, 2, 2, 3]，排序的目的是为了能够得到一连串的相同元素。<br>在普通的递归和回溯的过程中，框架一般如下：  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = begin; i &lt; end; i++) &#123;</span><br><span class="line">    subAns.push_back(candidates[i]);</span><br><span class="line">    dfs(i, end, k - candidates[i]);</span><br><span class="line">    subAns.pop_back();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>问题就出在循环上，比如已经得到了[1, 2, 2]，然后又弹出2，通过循环又加入了下一个2.<br>但实际上只加入当前层级（即i == begin时）中相等元素的第一个就足够了，因为如果不需要当前的元素，则后面相等的元素也不会被需要，可以直接跳过；如果需要当前的元素，则后面剩余元素组合产生的可能解一定包含弹出当前元素再选择下一个元素再使用后面剩余元素组合产生解的个数多。<br>所以调整之后的框架是  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = begin; i &lt; end; i++) &#123;</span><br><span class="line">    <span class="comment">// i == begin是当前层级的第一个元素，所以不能跳过</span></span><br><span class="line">    <span class="keyword">if</span> (i &gt; begin &amp;&amp; candidates[i] == candidates[i - <span class="number">1</span>])    <span class="comment">// 同一层级 &amp;&amp; 前面已经求解</span></span><br><span class="line">        <span class="keyword">continue</span>;           <span class="comment">// 直接跳过</span></span><br><span class="line">    subAns.push_back(candidates[i]);</span><br><span class="line">    dfs(i, end, k - candidates[i]);</span><br><span class="line">    subAns.pop_back();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">combinationSum2</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = candidates.size();</span><br><span class="line">        sort(candidates.begin(), candidates.end());</span><br><span class="line">        dfs(candidates, <span class="number">0</span>, target);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> begin, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (k &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (k == <span class="number">0</span>) &#123;</span><br><span class="line">            ans.push_back(subAns);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> n = candidates.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = begin; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; begin &amp;&amp; candidates[i] == candidates[i - <span class="number">1</span>])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            subAns.push_back(candidates[i]);</span><br><span class="line">            dfs(candidates, i + <span class="number">1</span>, k - candidates[i]);</span><br><span class="line">            subAns.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; subAns;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>39. 组合总和</title>
    <url>/combination-sum/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这道题目跟“377.组合总和iv”是一样的，都是无重复数组，可重复选择。<br>区别是这道题返回的是全部的组合（数组），而377是仅返回组合数目。<br>所以该题需要使用递归和回溯，在此过程中记录满足要求的组合到数组中；而由于递归过程中出现了许多重复计算，并且在377中仅要求组合的数目，不需要组合，因此377可以使用记忆化去掉重复计算，利用dp求解。  </p>
<h2 id="1-递归和回溯"><a href="#1-递归和回溯" class="headerlink" title="1. 递归和回溯"></a>1. 递归和回溯</h2><p>类似77.组合，递归+回溯不断选择新的元素，判断满足target时记录。<br>但时间复杂度可能超级高？<br>空间复杂度最坏为<code>O(target)</code>。  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">combinationSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        sum = <span class="number">0</span>;</span><br><span class="line">        dfs(candidates, <span class="number">0</span>, target);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> begin, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (sum &gt; target)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (sum == target) &#123;</span><br><span class="line">            ans.push_back(subAns);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> n = candidates.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = begin; i &lt; n; i++) &#123;</span><br><span class="line">            subAns.push_back(candidates[i]);</span><br><span class="line">            sum += candidates[i];</span><br><span class="line">            dfs(candidates, i, target);</span><br><span class="line">            subAns.pop_back();</span><br><span class="line">            sum -= candidates[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; subAns;</span><br><span class="line">    <span class="keyword">int</span> sum;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>77. 组合</title>
    <url>/combinations/</url>
    <content><![CDATA[<h2 id="1-递归"><a href="#1-递归" class="headerlink" title="1. 递归"></a>1. 递归</h2><p>n中选k个数，可以看作在对当前的数进行选择或放弃之后，在剩余的n-1个数中选k或k-1个数。<br>时间<code>O(k*C(n, k))</code>，空间<code>O(n)</code>递归栈。  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">combine</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> selection(<span class="number">1</span>, n, k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">selection</span><span class="params">(<span class="keyword">int</span> begin, <span class="keyword">int</span> end, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (begin &gt; end || k &lt;= <span class="number">0</span> || end - begin + <span class="number">1</span> &lt; k)</span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans, subAns;</span><br><span class="line">        <span class="comment">// choose begin</span></span><br><span class="line">        subAns = selection(begin + <span class="number">1</span>, end, k - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; subAns.size(); i++)</span><br><span class="line">            subAns[i].insert(subAns[i].begin(), begin);</span><br><span class="line">        <span class="keyword">if</span> (subAns.empty())</span><br><span class="line">            subAns = &#123;&#123;begin&#125;&#125;;</span><br><span class="line">        ans.insert(ans.end(), subAns.begin(), subAns.end());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// not choose begin</span></span><br><span class="line">        subAns = selection(begin + <span class="number">1</span>, end, k);</span><br><span class="line">        ans.insert(ans.end(), subAns.begin(), subAns.end());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2-dfs"><a href="#2-dfs" class="headerlink" title="2. dfs"></a>2. dfs</h2><p>方法1的思路是利用递归思想，找到一系列更短的组合。<br>另一种思想是每次直接找定长为k的组合序列，类似于dfs，判断长度到达k时直接储存结果。<br>时间<code>O(k*C(n, k))</code>，空间<code>O(n)</code>递归栈。  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">combine</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        dfs(<span class="number">1</span>, n, k);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (k &lt;= <span class="number">0</span> || subAns.size() + end - start + <span class="number">1</span> &lt; k)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (subAns.size() == k) &#123;</span><br><span class="line">            ans.push_back(subAns);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt;= end; i++) &#123;</span><br><span class="line">            subAns.push_back(i);</span><br><span class="line">            dfs(i + <span class="number">1</span>, end, k);</span><br><span class="line">            subAns.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; subAns;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>347.前K个高频元素</title>
    <url>/top-k-frequent-elements/</url>
    <content><![CDATA[<h2 id="1-小根堆"><a href="#1-小根堆" class="headerlink" title="1.小根堆"></a>1.小根堆</h2><p>首先遍历一次数组，统计得到每个数字的出现次数。<br>然后遍历第二次，通过小根堆筛选出k个高频元素。<br>时间<code>O(nlogk)</code>，空间<code>O(n)</code>记录次数。<br>记录数字出现次数使用hash表<code>unordered_map</code>.<br><em><code>map</code>的实现依赖于红黑树，内部是有序的，实现了对数级别的查找。</em><br><em><code>map</code>与hash表没有关系。hash表用更大的空间实现了更快的查找：<code>O(1)</code>。</em><br><em>hash表可以使用<code>unordered_map</code>，由hash函数实现，所以查找插入和删除都是<code>O(1)</code>的。</em><br><em>也正因为如此，<code>unordered_map</code>的内部元素是无序的，而<code>map</code>内部是有序的。</em><br><em>至于<code>hash-map</code>，它与<code>unordered_map</code>功能相同，但是不属于STL，是历史原因，使用<code>unordered_map</code>即可。</em>  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">topKFrequent</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; counter;</span><br><span class="line">        <span class="built_in">priority_queue</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (counter.count(nums[i]) == <span class="number">0</span>) </span><br><span class="line">                counter[nums[i]] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                counter[nums[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> iter = counter.begin(); iter != counter.end(); ++iter) &#123;</span><br><span class="line">            <span class="keyword">if</span> (q.size() &lt; k)</span><br><span class="line">                q.push(<span class="built_in">make_pair</span>(-iter-&gt;second, iter-&gt;first));</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (iter-&gt;second &gt; -q.top().first) &#123;</span><br><span class="line">                q.pop();</span><br><span class="line">                q.push(<span class="built_in">make_pair</span>(-iter-&gt;second, iter-&gt;first));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            ans.push_back(q.top().second);</span><br><span class="line">            q.pop();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>堆</tag>
      </tags>
  </entry>
  <entry>
    <title>1.两数之和</title>
    <url>/two-sum/</url>
    <content><![CDATA[<p>Given an array of integers, return indices of the two numbers such that they add up to a specific target.</p>
<p>You may assume that each input would have exactly one solution, and you may not use the same element twice.</p>
<p>Example:</p>
<p>Given nums = [2, 7, 11, 15], target = 9,</p>
<p>Because nums[0] + nums[1] = 2 + 7 = 9,<br>return [0, 1].</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/two-sum">https://leetcode-cn.com/problems/two-sum</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。<br>——————————————————————————————————</p>
<h2 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">twoSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1-暴力求解"><a href="#1-暴力求解" class="headerlink" title="1. 暴力求解"></a>1. 暴力求解</h2><p>直接遍历，O(n^2)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">twoSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size() - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; nums.size(); ++j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] + nums[j] == target)&#123;</span><br><span class="line">                ans.push_back(i);</span><br><span class="line">                ans.push_back(j);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-hash-对数级查找"><a href="#2-hash-对数级查找" class="headerlink" title="2. hash/对数级查找"></a>2. hash/对数级查找</h2><p>遍历nums的数据，每遍历一个数据x，去hash表中查找有无target - x的数据，并将该数据x插入到hash表中。<br>hash表中，key储存数据x或者数据x需要的数据target - x，value储存其index<br>ash表的查找可以看作是O(1)<em>（如果不发生碰撞的话）</em><del>（map是O(logn)）</del>，所以复杂度为O(n)<del>或O(nlogn)</del><br>后补：<br>*<code>map</code>的实现依赖于红黑树，内部是有序的，实现了对数级别的查找，以下代码是依靠<code>map</code>实现的。*<br><em><code>map</code>与hash表没有关系。hash表用更大的空间实现了更快的查找：<code>O(1)</code>。</em><br><em>hash表可以使用<code>unordered_map</code>，由hash函数实现，所以查找插入和删除都是<code>O(1)</code>的。</em><br><em>也正因为如此，<code>unordered_map</code>的内部元素是无序的，而<code>map</code>内部是有序的。</em><br><em>至于<code>hash-map</code>，它与<code>unordered_map</code>功能相同，但是不属于STL，是历史原因，使用<code>unordered_map</code>即可。</em>  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">twoSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; need;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(need.count(nums[i]))&#123;    <span class="comment">//返回0 or 1，用来判断在不在，也可以使用need.find(nums[i]) != need.end()</span></span><br><span class="line">            ans.push_back(need[nums[i]]);</span><br><span class="line">            ans.push_back(i);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">            need[target - nums[i]] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>415. 字符串相加</title>
    <url>/add-strings/</url>
    <content><![CDATA[<h2 id="1-模拟"><a href="#1-模拟" class="headerlink" title="1. 模拟"></a>1. 模拟</h2><p>直接在string上逐位模拟加法的过程。<br>需要特别注意的是仍有剩余部分的字符串的处理过程。<br>时间<code>O(len)</code>，空间<code>O(1)</code>.  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">addStrings</span><span class="params">(<span class="built_in">string</span> num1, <span class="built_in">string</span> num2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n1 = num1.length(), n2 = num2.length();</span><br><span class="line">        <span class="keyword">int</span> i1 = n1 - <span class="number">1</span>, i2 = n2 - <span class="number">1</span>, c = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">string</span> sum = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">while</span> (i1 &gt;= <span class="number">0</span> || i2 &gt;= <span class="number">0</span> || c != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i1 &gt;= <span class="number">0</span>)</span><br><span class="line">                c += num1[i1--] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (i2 &gt;= <span class="number">0</span>)</span><br><span class="line">                c += num2[i2--] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            sum = to_string(c % <span class="number">10</span>) + sum;</span><br><span class="line">            c /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>114.二叉树展开为链表</title>
    <url>/flatten-binary-tree-to-linked-list/</url>
    <content><![CDATA[<h2 id="1-前序遍历（递归）"><a href="#1-前序遍历（递归）" class="headerlink" title="1. 前序遍历（递归）"></a>1. 前序遍历（递归）</h2><p>查看题目和示例，发现展开之后的链表的顺序和二叉树的前序遍历的顺序是一致的。<br>因此可以首先前序遍历获得顺序，然后逐个修改节点的左右子节点指向。<br>时间<code>O(n)</code>，空间<code>O(n)</code>。  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;TreeNode*&gt; nodes;</span><br><span class="line">        preorderTraversal(root, nodes);</span><br><span class="line">        <span class="keyword">int</span> n = nodes.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            nodes[i]-&gt;left = <span class="literal">nullptr</span>;</span><br><span class="line">            nodes[i]-&gt;right = nodes[i + <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">preorderTraversal</span><span class="params">(TreeNode* root, <span class="built_in">vector</span>&lt;TreeNode*&gt;&amp; nodes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            nodes.push_back(root);</span><br><span class="line">            preorderTraversal(root-&gt;left, nodes);</span><br><span class="line">            preorderTraversal(root-&gt;right, nodes);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2-前序遍历（迭代）"><a href="#2-前序遍历（迭代）" class="headerlink" title="2. 前序遍历（迭代）"></a>2. 前序遍历（迭代）</h2><p>上述方法的问题是需要首先通过前序遍历获得顺序之后，才能继续后面的链接操作。<br>考虑是否可以在访问每个节点的过程中直接修改左右子节点的指向。<br>借助一个栈保存当前节点的右子节点，调整pre指针和cur指针的位置实现遍历过程中直接修改。<br>时间<code>O(n)</code>，空间<code>O(n)</code>。  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; s;</span><br><span class="line">        TreeNode* pre = <span class="literal">nullptr</span>;</span><br><span class="line">        TreeNode* cur = root;</span><br><span class="line">        <span class="keyword">while</span> (!s.empty() || cur != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                cur = s.top();</span><br><span class="line">                s.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (pre != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                pre-&gt;right = cur;</span><br><span class="line">                pre-&gt;left = <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cur-&gt;right != <span class="literal">nullptr</span>)</span><br><span class="line">                s.push(cur-&gt;right);</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = pre-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="3-根据题目定义和示例直接求解"><a href="#3-根据题目定义和示例直接求解" class="headerlink" title="3. 根据题目定义和示例直接求解"></a>3. 根据题目定义和示例直接求解</h2><p>整个过程实际是把root的展平的左子树移动到右子节点，再把root原来的展平的右子树接到左子树的最右下叶子节点。<br>但直接用递归实现的话，由于递归栈，空间还是<code>O(n)</code>。  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        flatten(root-&gt;left);</span><br><span class="line">        flatten(root-&gt;right);</span><br><span class="line">        TreeNode* pre = <span class="literal">nullptr</span>;</span><br><span class="line">        TreeNode* cur = root-&gt;left;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = cur-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pre != <span class="literal">nullptr</span>)</span><br><span class="line">            pre-&gt;right = root-&gt;right;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left != <span class="literal">nullptr</span>)</span><br><span class="line">            root-&gt;right = root-&gt;left;</span><br><span class="line">        root-&gt;left = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>因此可以继续详细化上述过程：把左子树移动到右子节点，原来的右子树接到左子树的最右下叶子节点。<br>这样实现了空间<code>O(1)</code>的算法。  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (root != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            TreeNode* right = root-&gt;right;</span><br><span class="line">            <span class="keyword">if</span> (root-&gt;left != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                root-&gt;right = root-&gt;left;</span><br><span class="line">                root-&gt;left = <span class="literal">nullptr</span>;</span><br><span class="line">                TreeNode* pre = root-&gt;right;</span><br><span class="line">                TreeNode* cur = root-&gt;right-&gt;right;</span><br><span class="line">                <span class="keyword">while</span> (cur != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                    pre = cur;</span><br><span class="line">                    cur = cur-&gt;right;</span><br><span class="line">                &#125;</span><br><span class="line">                pre-&gt;right = right;</span><br><span class="line">            &#125;</span><br><span class="line">            root = root-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>面试题 08.03. 魔术索引</title>
    <url>/magic-index-lcci/</url>
    <content><![CDATA[<h2 id="1-顺序遍历"><a href="#1-顺序遍历" class="headerlink" title="1. 顺序遍历"></a>1. 顺序遍历</h2><p>逐个判断，时间<code>O(n)</code>，空间<code>O(1)</code>。  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMagicIndex</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == nums[i]) &#123;</span><br><span class="line">                ans = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>343.整数拆分</title>
    <url>/integer-break/</url>
    <content><![CDATA[<h2 id="1-数学"><a href="#1-数学" class="headerlink" title="1. 数学"></a>1. 数学</h2><p>分析将一个数拆成以下部分：<br>拆1：没用<br>拆2：可以<br>拆3：可以<br>拆4：可以，跟2一样<br>拆5+：对半拆分后的乘积要比原来的值大<br>综上，尽可能拆出3，不要剩余1.<br>时间<code>O(1)</code>，空间<code>O(1)</code>。  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">integerBreak</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">3</span>)</span><br><span class="line">            <span class="keyword">return</span> n - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> n3 = n / <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">int</span> n2 = <span class="number">0</span>;</span><br><span class="line">        n %= <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            n3--;</span><br><span class="line">            n2 = <span class="number">2</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">2</span>)</span><br><span class="line">            n2 = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">pow</span>(<span class="number">3</span>, n3) * <span class="built_in">pow</span>(<span class="number">2</span>, n2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>41. 缺失的第一个正数</title>
    <url>/first-missing-positive/</url>
    <content><![CDATA[<h2 id="1-辅助数组"><a href="#1-辅助数组" class="headerlink" title="1. 辅助数组"></a>1. 辅助数组</h2><p><code>bool</code>类型的<code>1~n</code>的数组记录数据的出现情况，n为数据的个数。<br>时间<code>O(n)</code>，空间<code>O(n)</code>。  </p>
<h2 id="2-原地重排"><a href="#2-原地重排" class="headerlink" title="2. 原地重排"></a>2. 原地重排</h2><p>题目要求空间是<code>O(1)</code>的，单纯使用额外变量又没法记录得到最小值，同时又不能使用额外的空间，因此考虑原地重排。<br>数据和位置的对应关系如下：  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[<span class="number">3</span>,<span class="number">4</span>,<span class="number">-1</span>,<span class="number">1</span>]</span><br><span class="line"> <span class="number">0</span>,<span class="number">1</span>, <span class="number">2</span>,<span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>遍历每个数据，如果不满足<code>i + 1 == nums[i]</code>，则将当前的<code>nums[i]</code>数据与<code>nums[nums[i] - 1]</code>数据交换。<br>并将交换到<code>i</code>位置的数据也交换到其应该在的位置，直到当前位置满足上述条件或者交换过来的数据越界（负数或过大的正数）。<br>因为所有数据至多交换n次，所以时间复杂度<code>O(n)</code>，空间复杂度<code>O(1)</code>。  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">firstMissingPositive</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (i + <span class="number">1</span> != nums[i] &amp;&amp; nums[i] &gt; <span class="number">0</span> &amp;&amp; nums[i] &lt;= n &amp;&amp; nums[nums[i] - <span class="number">1</span>] != nums[i]) &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = nums[nums[i] - <span class="number">1</span>];</span><br><span class="line">                nums[nums[i] - <span class="number">1</span>] = nums[i];</span><br><span class="line">                nums[i] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i + <span class="number">1</span> != nums[i]) &#123;</span><br><span class="line">                ans = i + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ans == <span class="number">0</span>)</span><br><span class="line">            ans = n + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>739. 每日温度</title>
    <url>/daily-temperatures/</url>
    <content><![CDATA[<h2 id="1-单调栈"><a href="#1-单调栈" class="headerlink" title="1. 单调栈"></a>1. 单调栈</h2><p>使用一个辅助的单调递减栈，栈内存放数据的索引。<br>当当前元素大于栈顶元素时，弹出栈顶元素，并同时可以得到弹出的栈顶元素距离右侧第一个大于它的元素的位置。<br>当当前元素小于等于栈顶元素时，入栈。<br>时间<code>O(n)</code>，空间<code>O(n)</code>。  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dailyTemperatures</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; T)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">        <span class="keyword">int</span> n = T.size();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">ans</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.empty() || T[i] &lt;= T[s.top()])</span><br><span class="line">                s.push(i);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> topIndex = s.top();</span><br><span class="line">                <span class="keyword">while</span> (!s.empty() &amp;&amp; T[i] &gt; T[topIndex]) &#123;</span><br><span class="line">                    s.pop();</span><br><span class="line">                    ans[topIndex] = i - topIndex;</span><br><span class="line">                    <span class="keyword">if</span> (s.empty()) </span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    topIndex = s.top();</span><br><span class="line">                &#125;</span><br><span class="line">                s.push(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>栈</tag>
        <tag>单调栈</tag>
      </tags>
  </entry>
  <entry>
    <title>32.最长有效括号</title>
    <url>/longest-valid-parentheses/</url>
    <content><![CDATA[<h2 id="1-朴素"><a href="#1-朴素" class="headerlink" title="1. 朴素"></a>1. 朴素</h2><p><strong>错误！！</strong>  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line"><span class="string">&quot;()(()&quot;</span></span><br><span class="line">输出</span><br><span class="line"><span class="number">4</span></span><br><span class="line">预期结果</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>题目要求的是子串，而不是任意匹配即可。<br>求从每一个’(‘的位置开始，最长的有效括号子串的长度。<br>时间<code>O(n^2)</code>，空间<code>O(1)</code>。  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> temp = <span class="number">0</span>, llen = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[j] == <span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">                    llen++;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (llen &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        llen--;</span><br><span class="line">                        temp++;</span><br><span class="line">                    &#125; <span class="keyword">else</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                ans = ans &gt;= temp ? ans : temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans * <span class="number">2</span>;     <span class="comment">// 返回的是子串的长度</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2-修改后的朴素"><a href="#2-修改后的朴素" class="headerlink" title="2. 修改后的朴素"></a>2. 修改后的朴素</h2><p>根据1中的错误可知，需要在左括号个数清零时才能累计个数++。  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> cur = <span class="number">0</span>, temp = <span class="number">0</span>, llen = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[j] == <span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">                    llen++;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (llen &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        llen--;</span><br><span class="line">                        temp++;</span><br><span class="line">                        <span class="keyword">if</span> (llen == <span class="number">0</span>) &#123;</span><br><span class="line">                            cur += temp;</span><br><span class="line">                            temp = <span class="number">0</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                ans = ans &gt;= cur ? ans : cur;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans * <span class="number">2</span>;     <span class="comment">// 返回的是子串的长度</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="3-继续优化上述算法"><a href="#3-继续优化上述算法" class="headerlink" title="3. 继续优化上述算法"></a>3. 继续优化上述算法</h2><p>已经知道了需要在左括号数目清零时才++个数，所以可以不需要再在每个左括号处都作为起始来计算长度了。<br>时间<code>O(n)</code>，空间<code>O(1)</code>.  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> cur = <span class="number">0</span>, temp = <span class="number">0</span>, llen = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">                llen++;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (llen &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    llen--;</span><br><span class="line">                    temp++;</span><br><span class="line">                    <span class="keyword">if</span> (llen == <span class="number">0</span>) &#123;</span><br><span class="line">                        cur += temp;</span><br><span class="line">                        temp = <span class="number">0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (cur != <span class="number">0</span>) &#123;</span><br><span class="line">                        ans = ans &gt;= cur ? ans : cur;</span><br><span class="line">                        cur = <span class="number">0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> max(ans * <span class="number">2</span>, cur * <span class="number">2</span>);     <span class="comment">// 返回的是子串的长度</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>104.二叉树的最大深度</title>
    <url>/maximum-depth-of-binary-tree/</url>
    <content><![CDATA[<h2 id="1-递归"><a href="#1-递归" class="headerlink" title="1. 递归"></a>1. 递归</h2><p>时间<code>O(n)</code>，空间<code>O(height)</code>（递归栈）  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> max(maxDepth(root-&gt;left), maxDepth(root-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2-迭代"><a href="#2-迭代" class="headerlink" title="2. 迭代"></a>2. 迭代</h2><p>类似层次遍历，时间<code>O(n)</code>，空间<code>O(n)</code>.  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> height = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            height++;</span><br><span class="line">            <span class="keyword">int</span> n = q.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                TreeNode* temp = q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                <span class="keyword">if</span> (temp-&gt;left != <span class="literal">nullptr</span>)</span><br><span class="line">                    q.push(temp-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (temp-&gt;right != <span class="literal">nullptr</span>)</span><br><span class="line">                    q.push(temp-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> height;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>329.矩阵中的最长递增路径</title>
    <url>/longest-increasing-path-in-a-matrix/</url>
    <content><![CDATA[<h2 id="1-dfs-记忆化搜索"><a href="#1-dfs-记忆化搜索" class="headerlink" title="1. dfs+记忆化搜索"></a>1. dfs+记忆化搜索</h2><p>其实就是dp的思想。<br><code>dp[i][j]</code>代表<code>nums[i][j]</code>开始，能够得到的最长递增路径的长度.<br>则<code>dp[i][j]</code>依赖于上下左右四个位置中值比当前值大的位置。  </p>
<p>这样存在的问题是依赖位置的dp值不一定是已经求得的。  </p>
<p>一种方法是先从大到小排序，按这个顺序求解。  </p>
<p>另一种方法是递归求依赖但还未求解的位置的值。  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestIncreasingPath</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        rows = matrix.size();</span><br><span class="line">        <span class="keyword">if</span> (rows == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        cols = matrix[<span class="number">0</span>].size();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(rows, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(cols, <span class="number">-1</span>))</span></span>;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++) </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cols; j++) </span><br><span class="line">                ans = max(ans, dfs(matrix, dp, i, j));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; dp, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span> || x &gt;= rows || y &lt; <span class="number">0</span> || y &gt;= cols)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (dp[x][y] != <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">return</span> dp[x][y];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; k++) &#123;</span><br><span class="line">            <span class="keyword">int</span> nx = x + dx[k], ny = y + dy[k];</span><br><span class="line">            <span class="keyword">if</span> (nx &gt;= <span class="number">0</span> &amp;&amp; nx &lt; rows &amp;&amp; ny &gt;= <span class="number">0</span> &amp;&amp; ny &lt; cols &amp;&amp; matrix[nx][ny] &gt; matrix[x][y])</span><br><span class="line">                dp[x][y] = max(dp[x][y], dfs(matrix, dp, nx, ny) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dp[x][y] == <span class="number">-1</span>)</span><br><span class="line">            dp[x][y] = <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[x][y];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> rows, cols;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> dy[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>dfs</tag>
      </tags>
  </entry>
  <entry>
    <title>392. 判断子序列</title>
    <url>/is-subsequence/</url>
    <content><![CDATA[<h2 id="1-双指针遍历"><a href="#1-双指针遍历" class="headerlink" title="1. 双指针遍历"></a>1. 双指针遍历</h2><p>遍历s和t，时间<code>O(len(t))</code>，空间<code>O(1)</code>。<br>如果短字符串s有无限多个，则可以预先处理t，得到每个位置开始下一个给定字符的最近位置，这样就可以直接跳转到下一个需要的位置了。  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSubsequence</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n1 = s.length(), n2 = t.length();</span><br><span class="line">        <span class="keyword">if</span> (n1 == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">int</span> i1 = <span class="number">0</span>, i2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">bool</span> ans = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">while</span> (i2 &lt; n2) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i1] == t[i2])</span><br><span class="line">                i1++;</span><br><span class="line">            <span class="keyword">if</span> (i1 &gt;= n1) &#123;</span><br><span class="line">                ans = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            i2++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>1025.除数博弈</title>
    <url>/divisor-game/</url>
    <content><![CDATA[<h2 id="1-dp"><a href="#1-dp" class="headerlink" title="1. dp"></a>1. dp</h2><p>设<code>dp[i]</code>为<code>N = i</code>时Alice的胜负情况，则<code>dp[i]</code>取决于<code>i</code>的<code>[1, i - 1]</code>范围内的因数。<br><img src="gameTheory.png" alt="gameTheory"><br>时间<code>O(n^2)</code>，遍历<code>1~n</code>是<code>O(n)</code>，对每个数求因数又是<code>O(n)</code>。空间复杂度<code>O(n)</code>。  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">divisorGame</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">dp</span><span class="params">(N + <span class="number">1</span>, <span class="literal">false</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= N; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i % j == <span class="number">0</span> &amp;&amp; dp[i - j] == <span class="literal">false</span>) &#123;</span><br><span class="line">                    dp[i] = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[N];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2-博弈数学"><a href="#2-博弈数学" class="headerlink" title="2. 博弈数学"></a>2. 博弈数学</h2><p>初始时只有<code>dp[1] = false</code>和<code>dp[2] = true</code>.<br>考虑对于之后的奇数节点，由于奇数的因数必为奇数，所以<code>dp[奇数]</code>必转移到<code>dp[偶数]</code>.<br>而偶数的因数必有一个1，所以可以转移到前一个奇数，而奇数目前(<code>dp[1]</code>)是必败的，所以偶数选1使对方必败，自己则必胜。<br>因此<code>dp[偶数]</code>是必胜的，<code>dp[奇数]</code>被迫转移到偶数之后也必败。<br>所以只需要判断奇偶性即可，时间空间复杂度均为<code>O(1)</code>.  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">divisorGame</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> N % <span class="number">2</span> == <span class="number">0</span> ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>博弈</tag>
      </tags>
  </entry>
  <entry>
    <title>312.戳气球</title>
    <url>/burst-balloons/</url>
    <content><![CDATA[<h2 id="1-dp"><a href="#1-dp" class="headerlink" title="1. dp"></a>1. dp</h2><p>因为不知道戳爆哪个气球得到的奖励最高，所以可以遍历i都戳戳试试。<br>当戳爆第i个气球时，得到<code>nums[i - 1] * nums[i] * nums[i + 1]</code>的奖励，<br><strong>同时把气球分为左右两部分</strong>  </p>
<p>假设首先戳爆<code>i~j</code>的气球k，则非常不好计算：<br>因为k被戳爆之后，左侧部分最后一个气球的戳爆依赖于右部分第一个气球，右侧部分第一个气球的戳爆依赖于左侧部分最后一个气球。<br>所以可以假设最后戳爆气球k，这样左右两部分就不会产生关联。  </p>
<p>可以设<code>dp[i][j]</code>是戳爆<code>nums[i] ~ nums[j]</code>可得的最大收益。<br><code>dp[i][j] = max_k(dp[i][k - 1] + dp[k + 1][j] + nums[i - 1] * nums[k] * nums[j + 1])</code><br>时间<code>O(n^3)</code>，因为状态有<code>O(n^2)</code>种，每个状态的计算是<code>O(n)</code>。空间<code>O(n^2)</code>。  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxCoins</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n, <span class="number">0</span>))</span></span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = i; k &lt;= j; k++) &#123;</span><br><span class="line">                    dp[i][j] = max(dp[i][j], dpv(dp, i, k - <span class="number">1</span>) + dpv(dp, k + <span class="number">1</span>, j) + mult(nums, i, j, k));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dpv</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; dp, <span class="keyword">const</span> <span class="keyword">int</span>&amp; i, <span class="keyword">const</span> <span class="keyword">int</span>&amp; j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (j &lt; i)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> dp[i][j];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">mult</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">const</span> <span class="keyword">int</span>&amp; i, <span class="keyword">const</span> <span class="keyword">int</span>&amp; j, <span class="keyword">const</span> <span class="keyword">int</span>&amp; k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = i - <span class="number">1</span> &gt;= <span class="number">0</span> ? nums[i - <span class="number">1</span>] : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> b = j + <span class="number">1</span> &lt; nums.size() ? nums[j + <span class="number">1</span>] : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> a * b * nums[k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>63.不同路径II</title>
    <url>/unique-paths-ii/</url>
    <content><![CDATA[<h2 id="1-dp"><a href="#1-dp" class="headerlink" title="1. dp"></a>1. dp</h2><p>类似[62. 不同路径]，只是在遇到障碍时清零dp即可。  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; obstacleGrid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = obstacleGrid.size(), n = obstacleGrid[<span class="number">0</span>].size();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (obstacleGrid[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                    dp[j] = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (j &gt; <span class="number">0</span>) </span><br><span class="line">                    dp[j] += dp[j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>62.不同路径</title>
    <url>/unique-paths/</url>
    <content><![CDATA[<h2 id="1-dp"><a href="#1-dp" class="headerlink" title="1. dp"></a>1. dp</h2><p>设<code>dp[i][j]</code>为从左上角到<code>(i, j)</code>位置的路径条数。<br><code>dp[i][j] = dp[i][j - 1] + dp[i - 1][j]</code><br>时间<code>O(mn)</code>，空间<code>O(mn)</code>但可以优化到<code>O(n)</code>。  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n, <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++) </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++)</span><br><span class="line">                dp[j] += dp[j - <span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>64. 最小路径和</title>
    <url>/minimum-path-sum/</url>
    <content><![CDATA[<h2 id="1-dp"><a href="#1-dp" class="headerlink" title="1. dp"></a>1. dp</h2><p>最开始想的是bfs，但是没法实现，因为每次扩展出去的距离是不一样的。<br>bfs可以解决的是每次位移距离都是1（这跟bfs的每次扩展过程是相同的），网格中有障碍的情况。<br>可以使用dp来解决，<code>dp[i][j]</code>代表从左上角到达<code>grid[i][j]</code>需要的最小的路径和。<br><code>dp[i][j] = min(dp[i][j - 1], dp[i - 1][j]) + grid[i][j]</code><br>时间<code>O(mn)</code>，空间<code>O(mn)</code>但可以优化到<code>O(n)</code>。  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = grid.size(), n = grid[<span class="number">0</span>].size();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = grid[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++)</span><br><span class="line">                    dp[j] = dp[j - <span class="number">1</span>] + grid[i][j];</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j == <span class="number">0</span>)</span><br><span class="line">                    dp[j] = dp[j] + grid[i][j];</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    dp[j] = min(dp[j], dp[j - <span class="number">1</span>]) + grid[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>152.乘积最大子数组</title>
    <url>/maximum-product-subarray/</url>
    <content><![CDATA[<h2 id="1-dp"><a href="#1-dp" class="headerlink" title="1. dp"></a>1. dp</h2><p>最直接想到的是<code>dp[i]</code>代表以<code>nums[i]</code>为结尾的乘积最大值，<code>dp[i+1]</code>依赖<code>dp[i]</code>。<br>但实际上这并不满足“最优子结构”，比如可能<code>nums[i]</code>为负，将<code>dp[i-1]</code>的正最大值变成了负值。  </p>
<p>如果不用dp的话，又很难想到方法使得<code>dp[i+1]</code>依赖于<code>dp[i]</code>。<br>所以可以根据正负考虑转移关系。  </p>
<ul>
<li><code>nums[i] &gt; 0</code>时，<code>dp[i]</code>肯定依赖于为非负的最大值<code>dp[i-1]</code>  </li>
<li><code>nums[i] &lt; 0</code>时，<code>dp[i]</code>依赖于i-1的最小值<br>所以需要两个dp数组，分别记录以<code>nums[i]</code>为结尾的乘积最大值和最小值。  </li>
</ul>
<p>设<code>dpMax[i]</code>和<code>dpMin[i]</code>分别代表以<code>nums[i]</code>为结尾的乘积的最大值和最小值。<br><code>dpMax[i] = max(dpMax[i - 1] * nums[i], dpMin[i - 1] * nums[i], nums[i])</code><br><code>dpMin[i] = min(dpMax[i - 1] * nums[i], dpMin[i - 1] * nums[i], nums[i])</code><br>时间<code>O(n)</code>,空间<code>O(n)</code>但可以优化到<code>O(1)</code>。  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">int</span> dpMax = nums[<span class="number">0</span>], dpMin = nums[<span class="number">0</span>], ans = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> tempMax = dpMax;</span><br><span class="line">            dpMax = max(tempMax * nums[i], max(dpMin * nums[i], nums[i]));</span><br><span class="line">            dpMin = min(tempMax * nums[i], min(dpMin * nums[i], nums[i]));</span><br><span class="line">            ans = max(ans, dpMax);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer 11. 旋转数组的最小数字</title>
    <url>/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/</url>
    <content><![CDATA[<h2 id="1-朴素"><a href="#1-朴素" class="headerlink" title="1. 朴素"></a>1. 朴素</h2><p>直接遍历所有节点，获得最小值。<br>时间<code>O(n)</code>，空间<code>O(1)</code>。  </p>
<h2 id="2-二分"><a href="#2-二分" class="headerlink" title="2. 二分"></a>2. 二分</h2><p>如果数组中没有重复元素，则同[153. 寻找旋转排序数组中的最小值]。<br>此处存在重复元素，需要额外判断<code>nums[mid] == nums[right]</code>的情况。<br>当二者相等时，实际上没法判断mid所处的位置，如下图：<br><img src="binarySearch_equality.png" alt="binarySearch_equality"><br>所以一种方法是二分左半部分和右半部分，比较得到的最小值，可以通过递归实现。<br>另一种方法是中间值和右侧值相等时，<code>right--</code>，因为这样总不会错过正确答案。<br>时间<code>O(logn)</code>，最差是<code>O(n)</code>，因为受限于相等的值，可能需要搜索绝大部分甚至全部的值。  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; numbers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = numbers.size();</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (numbers[mid] &gt; numbers[r])</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (numbers[mid] &lt; numbers[r])</span><br><span class="line">                r = mid;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                r--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> numbers[l];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title>153.寻找旋转排序数组中的最小值</title>
    <url>/find-minimum-in-rotated-sorted-array/</url>
    <content><![CDATA[<h2 id="1-朴素"><a href="#1-朴素" class="headerlink" title="1. 朴素"></a>1. 朴素</h2><p><code>O(n)</code>扫描一遍。  </p>
<h2 id="2-二分"><a href="#2-二分" class="headerlink" title="2. 二分"></a>2. 二分</h2><p>判断mid和右节点right。<br>不判断mid和左节点left的原因是不方便判断，而且已经判断了right也没必要再去根据left判断了。<br><img src="binarySearch_right.png" alt="binarySearch_right">  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (r - l) / <span class="number">2</span> + l;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt; nums[r])</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; nums[r])</span><br><span class="line">                r = mid;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> nums[l];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title>95。不同的二叉搜索树II</title>
    <url>/unique-binary-search-trees-ii/</url>
    <content><![CDATA[<h2 id="1-回溯"><a href="#1-回溯" class="headerlink" title="1. 回溯"></a>1. 回溯</h2><p>最开始想到的是回溯，先通过回溯产生1~n的所有排列，然后把排列作为插入顺序，通过插入实现二叉搜索树。<br>问题在于不同的序列对应的二叉树可能是相等的，比如2, 1, 3和2, 3, 1对应的是同一棵二叉树，会产生重复。<br>暂时没有想到解决重复的方法。  </p>
<h2 id="2-dp"><a href="#2-dp" class="headerlink" title="2. dp"></a>2. dp</h2><p>参照[96. 不同的二叉搜索树]，题干相同，但96题仅要求返回种数，而不需要返回所有可能的树。<br>96题的方法是dp，<code>g[i]</code>代表1<del>i产生的二叉搜索树的种数，则<code>g[n]</code>就是遍历i作为根节点，左子树是<code>g[i-1]</code>，右子树是<code>g[n-i]</code>，求乘积即可。<br>参照96题，这道题也可以记录1</del>i产生的二叉搜索树，最终结果是遍历i作为根节点，左子树是1<del>i-1可能组成的二叉搜索树，右子树是i+1</del>n。<br>左子树可以直接重用之前建好的节点，右子树可以复制1~n-i对应的二叉搜索树，然后整体加上一个偏移值。<br>如果左子树是复用之前的节点，则速度要比递归快一些，因为左子树有重叠。  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;TreeNode*&gt; <span class="title">generateTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;TreeNode*&gt;&gt; <span class="title">halfTrees</span><span class="params">(n + <span class="number">1</span>)</span></span>;    <span class="comment">// halfTrees[i]代表1~i产生的二叉树</span></span><br><span class="line">        halfTrees[<span class="number">0</span>] = &#123;<span class="literal">nullptr</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++) &#123;</span><br><span class="line">                <span class="built_in">vector</span>&lt;TreeNode*&gt; leftChild = halfTrees[j - <span class="number">1</span>];</span><br><span class="line">                <span class="built_in">vector</span>&lt;TreeNode*&gt; rightChild = copyTrees(halfTrees[i - j], j);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> ci = <span class="number">0</span>; ci &lt; leftChild.size(); ci++) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> cj = <span class="number">0</span>; cj &lt; rightChild.size(); cj++) &#123;</span><br><span class="line">                        TreeNode* root = <span class="keyword">new</span> TreeNode(j);</span><br><span class="line">                        root-&gt;left = leftChild[ci];</span><br><span class="line">                        root-&gt;right = rightChild[cj];</span><br><span class="line">                        halfTrees[i].push_back(root);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> halfTrees[n];</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">copyTree</span><span class="params">(TreeNode* root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        TreeNode* p = <span class="keyword">new</span> TreeNode(root-&gt;val + sum, copyTree(root-&gt;left, sum), copyTree(root-&gt;right, sum));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;TreeNode*&gt; <span class="title">copyTrees</span><span class="params">(<span class="built_in">vector</span>&lt;TreeNode*&gt; trees, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (trees.size() == <span class="number">1</span> &amp;&amp; trees[<span class="number">0</span>] == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> trees;</span><br><span class="line">        <span class="built_in">vector</span>&lt;TreeNode*&gt; ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; trees.size(); i++) </span><br><span class="line">            ans.push_back(copyTree(trees[i], sum));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="3-递归"><a href="#3-递归" class="headerlink" title="3. 递归"></a>3. 递归</h2><p><code>gen(begin, end)</code>产生begin~end的二叉搜索树。<br>可以遍历中间的i作为根节点，左子树是<code>gen(begin, i-1)</code>，右子树是<code>gen(i+1, end)</code>。  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;TreeNode*&gt; <span class="title">generateTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;TreeNode*&gt; ans = generateTrees(<span class="number">1</span>, n);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;TreeNode*&gt; <span class="title">generateTrees</span><span class="params">(<span class="keyword">int</span> begin, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (begin &gt; end)</span><br><span class="line">            <span class="keyword">return</span> &#123;<span class="literal">nullptr</span>&#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">vector</span>&lt;TreeNode*&gt; ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = begin; i &lt;= end; i++) &#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;TreeNode*&gt; leftChild = generateTrees(begin, i - <span class="number">1</span>);</span><br><span class="line">            <span class="built_in">vector</span>&lt;TreeNode*&gt; rightChild = generateTrees(i + <span class="number">1</span>, end);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; leftChild.size(); j++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; rightChild.size(); k++) &#123;</span><br><span class="line">                    TreeNode* root = <span class="keyword">new</span> TreeNode(i);</span><br><span class="line">                    root-&gt;left = leftChild[j];</span><br><span class="line">                    root-&gt;right = rightChild[k];</span><br><span class="line">                    ans.push_back(root);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>144.二叉树的前序遍历</title>
    <url>/binary-tree-preorder-traversal/</url>
    <content><![CDATA[<h2 id="相关"><a href="#相关" class="headerlink" title="相关"></a>相关</h2><ol>
<li>二叉树的中序遍历：94</li>
<li>二叉树的后序遍历：145</li>
<li>N叉树的前序遍历：589</li>
<li>N叉树的后序遍历：590</li>
</ol>
<h2 id="1-递归"><a href="#1-递归" class="headerlink" title="1. 递归"></a>1. 递归</h2><p>根左右直接递归实现。<br>时间<code>O(n)</code>，空间<code>O(n)</code>.  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        ans.push_back(root-&gt;val);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; leftAns = preorderTraversal(root-&gt;left);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; rightAns = preorderTraversal(root-&gt;right);</span><br><span class="line">        ans.insert(ans.end(), leftAns.begin(), leftAns.end());</span><br><span class="line">        ans.insert(ans.end(), rightAns.begin(), rightAns.end());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2-迭代"><a href="#2-迭代" class="headerlink" title="2. 迭代"></a>2. 迭代</h2><p>用stack模拟递归栈。<br>访问栈顶元素（根） -&gt; 右节点压栈 -&gt; 左节点压栈 -&gt;<br>上述循环中，左节点入栈之后接着就出栈了，所以可以只将右节点入栈，下次直接访问左节点。<br>时间<code>O(n)</code>，空间<code>O(n)</code>.  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; st;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">while</span> (!st.empty() || root != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                root = st.top();</span><br><span class="line">                st.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            ans.push_back(root-&gt;val);</span><br><span class="line">            <span class="keyword">if</span> (root-&gt;right != <span class="literal">nullptr</span>)</span><br><span class="line">                st.push(root-&gt;right);</span><br><span class="line">            root = root-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>167.两数之和 II - 输入有序数组</title>
    <url>/two-sum-ii-input-array-is-sorted/</url>
    <content><![CDATA[<h2 id="1-朴素"><a href="#1-朴素" class="headerlink" title="1. 朴素"></a>1. 朴素</h2><p>遍历每一个数字，然后从它右侧的数字中查找是否有数字满足要求。<br>时间<code>O(n^2)</code>，空间<code>O(1)</code>。<br><strong>超时。</strong>  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">twoSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; numbers, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = numbers.size();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (numbers[i] + numbers[j] == target) &#123;</span><br><span class="line">                    flag = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (flag)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> &#123;i + <span class="number">1</span>, j + <span class="number">1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2-二分"><a href="#2-二分" class="headerlink" title="2. 二分"></a>2. 二分</h2><p>利用数组是递增的特点，遍历每个数据，然后对它右侧的数据进行二分，判断是否满足target。<br>时间<code>O(nlogn)</code>，空间<code>O(1)</code>。<br><strong>超时。</strong>  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">twoSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; numbers, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = numbers.size();</span><br><span class="line">        <span class="keyword">int</span> i, j;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> l = i + <span class="number">1</span>, r = n - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">                <span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span> (numbers[i] + numbers[mid] == target) &#123;</span><br><span class="line">                    j = mid;</span><br><span class="line">                    flag = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (numbers[i] + numbers[mid] &lt; target)</span><br><span class="line">                    l++;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    r--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (flag)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> &#123;i + <span class="number">1</span>, j + <span class="number">1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="3-滑动窗口-双指针"><a href="#3-滑动窗口-双指针" class="headerlink" title="3. 滑动窗口/双指针"></a>3. 滑动窗口/双指针</h2><p>初始化窗口的左右两侧分别为数组的起始和结束位置，然后向中间收窄。  </p>
<ul>
<li><code>numbers[left] + numbers[right] &lt; target, left++</code>  </li>
<li><code>numbers[left] + numbers[right] &gt; target, right--</code><br>时间<code>O(n)</code>，空间<code>O(1)</code>。  </li>
</ul>
<p>由于数组是递增的，还可以先用二分法确定右侧指针的位置，而不是默认从最右侧开始。  </p>
<p><em>会不会移动过程中跳过答案？</em><br>不会，可以参考<a href="https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/solution/yi-zhang-tu-gao-su-ni-on-de-shuang-zhi-zhen-jie-fa/">削减矩形搜索空间</a>  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">twoSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; numbers, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = numbers.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">if</span> (numbers[l] + numbers[r] == target)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (numbers[l] + numbers[r] &lt; target)</span><br><span class="line">                l++;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                r--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> &#123;l + <span class="number">1</span>, r + <span class="number">1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>双指针</tag>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title>670.最大交换</title>
    <url>/maximum-swap/</url>
    <content><![CDATA[<h2 id="1-贪心，找一个右侧的最大值替换到左侧"><a href="#1-贪心，找一个右侧的最大值替换到左侧" class="headerlink" title="1. 贪心，找一个右侧的最大值替换到左侧"></a>1. 贪心，找一个右侧的最大值替换到左侧</h2><p>最开始居然贼蠢，想找个右侧的最大值直接替换最左侧的位置，忽略了最左侧本身就是最大值，如5523这种情况。<br>所以应该是找一个右侧的最大值替换左侧第一个比它小的值。  </p>
<p>可以是用一个0~9的数组记录每个数字出现的最右侧的位置，然后从左扫描看能否跟右侧互换一个最大值。<br>因为是从最左侧开始，尽量交换最左侧的数和这个数右侧部分的最大值，所以也可以用一个数组记录数据的每一位数右侧的最大值的位置，这样的空间复杂度就由<code>O(10)</code>到了<code>O(length)</code>。  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maximumSwap</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">digits</span><span class="params">(<span class="number">10</span>, <span class="number">-1</span>)</span></span>;</span><br><span class="line">        <span class="built_in">string</span> s = to_string(num);</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            digits[s[i] - <span class="string">&#x27;0&#x27;</span>] = i;</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">9</span>; k &gt; <span class="number">0</span>; k--) &#123;</span><br><span class="line">                <span class="keyword">if</span> (digits[k] &gt; i &amp;&amp; k &gt; s[i] - <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">                    <span class="keyword">char</span> temp = s[i];</span><br><span class="line">                    s[i] = k + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                    s[digits[k]] = temp;</span><br><span class="line">                    flag = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (flag)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> stoi(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面算法的小缺点是至少需要<code>O(10)</code>的空间或者是<code>O(length)</code>的空间记录每个数字最右侧出现的位置或者是每位数右侧的最大数的位置。<br>可以优化到只需要<code>O(1)</code>的空间直接找到右侧交换的最大值。<br>为了实现<code>O(1)</code>的空间，需要找到一个位置将数据分为左右两端，找到右侧最大的数字，与左侧对应位置交换。<br>这个位置是破坏从最左侧开始递减顺序的数字的位置，因为递减部分一定找不到一个数来与它左侧的数互换。  </p>
<ol>
<li>首先根据递减找到该分割位置。  </li>
<li>然后在其右侧找一个最大值的位置，即为需要交换的位置。  </li>
<li>在该分割位置的左侧找与右侧最大值相对应可以替换的位置，互换。  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maximumSwap</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> s = to_string(num);</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">int</span> midLoc = <span class="number">0</span>, leftLoc = <span class="number">0</span>, rightLoc;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] &lt; s[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                midLoc = i;     <span class="comment">// 找到中间分割位置</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        rightLoc = midLoc;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = midLoc + <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">            <span class="keyword">if</span> (s[i] &gt;= s[rightLoc])</span><br><span class="line">                rightLoc = i;   <span class="comment">// 找到右半部分的最大值位置</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= midLoc; i++) &#123; <span class="comment">// 找到左半部分可交换的最左侧位置</span></span><br><span class="line">            <span class="keyword">if</span> (s[i] &lt; s[rightLoc]) &#123;</span><br><span class="line">                leftLoc = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span> temp = s[leftLoc];</span><br><span class="line">        s[leftLoc] = s[rightLoc];</span><br><span class="line">        s[rightLoc] = temp;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> stoi(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>162.寻找峰值</title>
    <url>/find-peak-element/</url>
    <content><![CDATA[<h2 id="1-二分"><a href="#1-二分" class="headerlink" title="1. 二分"></a>1. 二分</h2><p>要求复杂度是<code>O(logn)</code>，说明了是要二分。<br>结果只要求一个值，因此二分到<code>nums[i-1] &lt; nums[i] &lt; nums[i+1]</code>的i即可。  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findPeakElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = nums.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (l == r)</span><br><span class="line">                ans = l++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (mid &gt; <span class="number">0</span> &amp;&amp; nums[mid] &gt; nums[mid - <span class="number">1</span>] &amp;&amp; nums[mid] &gt; nums[mid + <span class="number">1</span>]) &#123;</span><br><span class="line">                ans = mid;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; nums[mid + <span class="number">1</span>])</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; nums[mid + <span class="number">1</span>])</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title>852.山脉数组的峰顶索引</title>
    <url>/peak-index-in-a-mountain-array/</url>
    <content><![CDATA[<h2 id="1-朴素"><a href="#1-朴素" class="headerlink" title="1. 朴素"></a>1. 朴素</h2><p>直接<code>O(n)</code>扫描一遍，记录最大值索引。  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">peakIndexInMountainArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = A.size();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="keyword">if</span> (A[i] &gt; A[ans])</span><br><span class="line">                ans = i;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2-二分"><a href="#2-二分" class="headerlink" title="2. 二分"></a>2. 二分</h2><p>二分根据mid判断是递增一侧还是递减一侧，复杂度<code>O(logn)</code>。  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">peakIndexInMountainArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = A.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (mid == <span class="number">0</span>) &#123;</span><br><span class="line">                ans = A[ans] &gt; A[r] ? ans : r;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = A[ans] &gt; A[mid] ? ans : mid;</span><br><span class="line">            <span class="keyword">if</span> (A[mid] &gt; A[mid - <span class="number">1</span>] &amp;&amp; A[mid] &gt; A[mid + <span class="number">1</span>])</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (A[mid] &gt;= A[mid - <span class="number">1</span>])</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (A[mid] &lt;= A[mid - <span class="number">1</span>])</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title>97.交错字符串</title>
    <url>/interleaving-string/</url>
    <content><![CDATA[<h2 id="1-递归"><a href="#1-递归" class="headerlink" title="1. 递归"></a>1. 递归</h2><p>第一反应是双指针，s3判断一个，对应的s1或者s2向后移一位。<br>但问题在于，当s1和s2的当前位相同时，无法确定s1/s2向后移位。<br>如果加上回溯，则跟递归类似。<br>复杂度指数级。<br>可以通过记忆化降低复杂度。  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isInterleave</span><span class="params">(<span class="built_in">string</span> s1, <span class="built_in">string</span> s2, <span class="built_in">string</span> s3)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = s1.length(), n = s2.length();</span><br><span class="line">        <span class="keyword">if</span> (m + n != s3.length())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (m == <span class="number">0</span> &amp;&amp; n == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (m == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s2[<span class="number">0</span>] == s3[<span class="number">0</span>])</span><br><span class="line">                <span class="keyword">return</span> isInterleave(s1, s2.substr(<span class="number">1</span>), s3.substr(<span class="number">1</span>));</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s1[<span class="number">0</span>] == s3[<span class="number">0</span>])</span><br><span class="line">                <span class="keyword">return</span> isInterleave(s1.substr(<span class="number">1</span>), s2, s3.substr(<span class="number">1</span>));</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (s1[<span class="number">0</span>] == s3[<span class="number">0</span>] &amp;&amp; s2[<span class="number">0</span>] != s3[<span class="number">0</span>])</span><br><span class="line">                <span class="keyword">return</span> isInterleave(s1.substr(<span class="number">1</span>), s2, s3.substr(<span class="number">1</span>));</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (s1[<span class="number">0</span>] != s3[<span class="number">0</span>] &amp;&amp; s2[<span class="number">0</span>] == s3[<span class="number">0</span>])</span><br><span class="line">                <span class="keyword">return</span> isInterleave(s1, s2.substr(<span class="number">1</span>), s3.substr(<span class="number">1</span>));</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (s1[<span class="number">0</span>] == s3[<span class="number">0</span>] &amp;&amp; s2[<span class="number">0</span>] == s3[<span class="number">0</span>])</span><br><span class="line">                <span class="keyword">return</span> isInterleave(s1.substr(<span class="number">1</span>), s2, s3.substr(<span class="number">1</span>)) || isInterleave(s1, s2.substr(<span class="number">1</span>), s3.substr(<span class="number">1</span>));</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2-动态规划"><a href="#2-动态规划" class="headerlink" title="2. 动态规划"></a>2. 动态规划</h2><p><code>f[i][j]</code>代表s1的前i个字符和s2的前j个字符是否符合s3的前i+j个字符。<br><img src="dp1.png" alt="dp"><br>时间复杂度：<code>O(mn)</code><br>空间复杂度：<code>O(mn)</code>，但是因为更新只需要上一行，所以可以优化到<code>O(n)</code>的空间  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isInterleave</span><span class="params">(<span class="built_in">string</span> s1, <span class="built_in">string</span> s2, <span class="built_in">string</span> s3)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = s1.length(), n = s2.length();</span><br><span class="line">        <span class="keyword">if</span> (m + n != s3.length())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// vector&lt;bool&gt; 不是bool类型的数组，而是特殊的vector。</span></span><br><span class="line">        <span class="comment">// 内部可能使用1bit代表一个bool，参照http://www.cplusplus.com/reference/vector/vector-bool/</span></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, <span class="literal">false</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i &gt; <span class="number">0</span>)</span><br><span class="line">                    dp[j] = dp[j] &amp;&amp; s1[i - <span class="number">1</span>] == s3[i + j - <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (j &gt; <span class="number">0</span>)</span><br><span class="line">                    dp[j] = dp[j] || (dp[j - <span class="number">1</span>] &amp;&amp; s2[j - <span class="number">1</span>] == s3[i + j - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>96.不同的二叉搜索树</title>
    <url>/unique-binary-search-trees/</url>
    <content><![CDATA[<h2 id="1-动态规划"><a href="#1-动态规划" class="headerlink" title="1. 动态规划"></a>1. 动态规划</h2><p>设<code>G(n)</code>是以1 … n为节点组成的二叉搜索树的种数，<code>f(i)</code>是以i为根节点的二叉搜索树的种数，则有：<br><code>G(n) = f(1) + f(2) + ... + f(n)</code><br>以<code>f(i)</code>为例，其左子树为1 … i-1节点组成的二叉搜索树，右子树为i+1 … n节点组成的二叉搜索树，即<br><code>f(i) = G(i - 1) * G(n - i)</code><br>综上，有：<br><code>G(n) = G(0)G(n-1) + G(1)G(n-2) + ... + G(n-1)G(0)</code><br>时间复杂度：<code>(n^2)</code>，需要算n个<code>G(i)</code>，每个需要<code>O(n)</code>。<br>空间复杂度：<code>O(n)</code>。  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>* g = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>]();</span><br><span class="line">        <span class="comment">// new的过程是 分配空间 - 使用默认构造函数初始化</span></span><br><span class="line">        <span class="comment">// 而对于内置数据类型，new仅分配内存而不进行初始化，需要加()表示进行初始化</span></span><br><span class="line">        <span class="comment">// int* a = new int [10](1, 2) 之类的这种在()内部指定值的方法是错误的</span></span><br><span class="line">        <span class="comment">// 上一行的()可以改为&#123;&#125;代表列表初始化</span></span><br><span class="line">        g[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        g[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++)</span><br><span class="line">                g[i] += g[j] * g[i - <span class="number">1</span> - j];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ans = g[n];</span><br><span class="line">        <span class="keyword">delete</span> []g;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>680.验证回文字符串II</title>
    <url>/valid-palindrome-ii/</url>
    <content><![CDATA[<h2 id="1-朴素"><a href="#1-朴素" class="headerlink" title="1. 朴素"></a>1. 朴素</h2><p>首先判断不删除字符的情况下，s本身是不是回文串。<br>之后遍历判断删除每个字符，剩下的部分是否是回文串。<br>时间<code>O(n^2)</code>，空间<code>O(1)</code>，超时。  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindromic</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n / <span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] != s[n - i - <span class="number">1</span>])</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">validPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isPalindromic(s))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isPalindromic(s.erase(i)))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2-双指针-贪心"><a href="#2-双指针-贪心" class="headerlink" title="2. 双指针+贪心"></a>2. 双指针+贪心</h2><p>初始双指针指在s的左右两侧。  </p>
<ol>
<li>判断s是否是回文串，若是则返回true，否则继续。  </li>
<li>若s不是回文串，则将s的开头和结尾的相等的部分删除，直到开头和结尾的字符不相等。  </li>
<li>当开头和结尾不相等时，则<code>s[1:-1]</code>和<code>s[0:-2]</code>之中必须有一个是回文串，否则不可能满足删除至多一个字符得到回文串的要求。  </li>
</ol>
<p>这样，最多只需要执行3次<code>isPalindromic()</code>函数即可实现。<br>时间<code>O(n)</code>，空间<code>O(1)</code>。  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindromic</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n / <span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] != s[n - i - <span class="number">1</span>])</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">validPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isPalindromic(s))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> i, n = s.length();</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n / <span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] != s[n - i - <span class="number">1</span>])</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> isPalindromic(s.substr(i, n - <span class="number">2</span> * i - <span class="number">1</span>)) || isPalindromic(s.substr(i + <span class="number">1</span>, n - <span class="number">2</span> * i - <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>136.只出现一次的数字</title>
    <url>/single-number/</url>
    <content><![CDATA[<h2 id="1-hash表"><a href="#1-hash表" class="headerlink" title="1. hash表"></a>1. hash表</h2><p>直接hash表记录次数，但是空间占用有点多。<br>时间<code>O(n)</code>，空间<code>O(n)</code>.  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; hashTable;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++)</span><br><span class="line">            hashTable[nums[i]]++;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::iterator it = hashTable.begin(); it != hashTable.end(); ++it)</span><br><span class="line">            <span class="keyword">if</span> (it-&gt;second == <span class="number">1</span>) &#123;</span><br><span class="line">                ans = it-&gt;first;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2-位运算异或"><a href="#2-位运算异或" class="headerlink" title="2.　位运算异或"></a>2.　位运算异或</h2><p>偶数个相同的数据异或之后变成0，而任何数异或0还是它本身。<br>时间<code>O(n)</code>，空间<code>O(1)</code>。  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++)</span><br><span class="line">            ans ^= nums[i];</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>94.二叉树的中序遍历</title>
    <url>/binary-tree-inorder-traversal/</url>
    <content><![CDATA[<h2 id="相关"><a href="#相关" class="headerlink" title="相关"></a>相关</h2><ol>
<li>二叉树的前序遍历：144</li>
<li>二叉树的后序遍历：145</li>
</ol>
<h2 id="1-递归"><a href="#1-递归" class="headerlink" title="1. 递归"></a>1. 递归</h2><p>左根右直接递归实现。<br>时间<code>O(n)</code>，空间<code>O(n)</code>.  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; leftAns = inorderTraversal(root-&gt;left);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; rightAns = inorderTraversal(root-&gt;right);</span><br><span class="line">        ans.insert(ans.end(), leftAns.begin(), leftAns.end());</span><br><span class="line">        ans.push_back(root-&gt;val);</span><br><span class="line">        ans.insert(ans.end(), rightAns.begin(), rightAns.end());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2-迭代"><a href="#2-迭代" class="headerlink" title="2. 迭代"></a>2. 迭代</h2><p>中序遍历的访问顺序是左根右。<br>想象一棵二叉树，实际的访问过程是一直左左左访问到最左，直到左子树为空才输出节点的值，然后去到右节点，继续左左左…<br>所以可以直接模拟出上述过程，时间<code>O(n)</code>，空间<code>O(n)</code>.  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; st;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!st.empty() || root != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                root = st.top();</span><br><span class="line">                st.pop();</span><br><span class="line">                ans.push_back(root-&gt;val);</span><br><span class="line">                root = root-&gt;right;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                st.push(root);</span><br><span class="line">                root = root-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>589.N叉树的前序遍历</title>
    <url>/n-ary-tree-preorder-traversal/</url>
    <content><![CDATA[<h2 id="相关"><a href="#相关" class="headerlink" title="相关"></a>相关</h2><ol>
<li>二叉树的前序遍历：144</li>
<li>二叉树的中序遍历：94</li>
<li>二叉树的后序遍历：145</li>
<li>N叉树的后序遍历：590</li>
</ol>
<h2 id="1-递归"><a href="#1-递归" class="headerlink" title="1. 递归"></a>1. 递归</h2><p>跟二叉树一样，时间<code>O(n)</code>，空间<code>O(n)</code>。  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    vector&lt;Node*&gt; children;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node() &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val, vector&lt;Node*&gt; _children) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        children = _children;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">preorder</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        ans.push_back(root-&gt;val);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; root-&gt;children.size(); i++) &#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; subArray = preorder(root-&gt;children[i]);</span><br><span class="line">            ans.insert(ans.end(), subArray.begin(), subArray.end());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2-迭代"><a href="#2-迭代" class="headerlink" title="2. 迭代"></a>2. 迭代</h2><p>仿照二叉树的前序遍历的迭代实现方式。<br>访问根节点  -&gt; 将右部分的节点按照从右往左的顺序入栈 -&gt; 左节点入栈 -&gt;<br>同样，我们还是可以将左节点入栈出栈的部分省去。<br>时间<code>O(n)</code>，空间<code>O(n)</code>.  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">preorder</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;Node*&gt; st;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">while</span> (!st.empty() || root != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                root = st.top();</span><br><span class="line">                st.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            ans.push_back(root-&gt;val);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = root-&gt;children.size() - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--)</span><br><span class="line">                st.push(root-&gt;children[i]);</span><br><span class="line">            root = root-&gt;children.empty() ? <span class="literal">nullptr</span> : root-&gt;children[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>102.二叉树的层序遍历</title>
    <url>/binary-tree-level-order-traversal/</url>
    <content><![CDATA[<h2 id="1-queue实现层次遍历"><a href="#1-queue实现层次遍历" class="headerlink" title="1. queue实现层次遍历"></a>1. queue实现层次遍历</h2><p>时间<code>O(n)</code>，空间<code>O(n)</code>。  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">levelOrder</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">nullptr</span>)</span><br><span class="line">            q.push(root);</span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sub;</span><br><span class="line">            <span class="keyword">int</span> qsz = q.size();</span><br><span class="line">            <span class="keyword">while</span> (qsz--) &#123;</span><br><span class="line">                TreeNode* temp = q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                sub.push_back(temp-&gt;val);</span><br><span class="line">                <span class="keyword">if</span> (temp-&gt;left != <span class="literal">nullptr</span>)</span><br><span class="line">                    q.push(temp-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (temp-&gt;right != <span class="literal">nullptr</span>)</span><br><span class="line">                    q.push(temp-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            ans.push_back(sub);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>115.最小栈</title>
    <url>/min-stack/</url>
    <content><![CDATA[<h2 id="1-直接模拟"><a href="#1-直接模拟" class="headerlink" title="1. 直接模拟"></a>1. 直接模拟</h2><p>用一个变量记录最小元素的位置就可以了。  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    MinStack() &#123;</span><br><span class="line">        vals = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">        capacity = <span class="number">10</span>;</span><br><span class="line">        minLoc = <span class="number">0</span>;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ~MinStack() &#123;</span><br><span class="line">        <span class="keyword">delete</span> []vals;</span><br><span class="line">        vals = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;      <span class="comment">// 时间复杂度均摊`O(1)`</span></span><br><span class="line">        <span class="keyword">if</span> (size == capacity) &#123;</span><br><span class="line">            <span class="keyword">int</span>* temp = <span class="keyword">new</span> <span class="keyword">int</span>[capacity * <span class="number">2</span>];</span><br><span class="line">            capacity *= <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">                temp[i] = vals[i];</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">delete</span> []vals;</span><br><span class="line">            vals = temp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vals[size++] = x;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; vals[minLoc])</span><br><span class="line">            minLoc = size - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;            <span class="comment">// 时间复杂度最坏`O(n)`</span></span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">if</span> (minLoc == size) &#123;</span><br><span class="line">            minLoc = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; size; i++)</span><br><span class="line">                <span class="keyword">if</span> (vals[i] &lt; vals[minLoc])</span><br><span class="line">                    minLoc = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> vals[size - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> vals[minLoc];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span>* vals;</span><br><span class="line">    <span class="keyword">int</span> capacity;</span><br><span class="line">    <span class="keyword">int</span> minLoc;</span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MinStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MinStack* obj = new MinStack();</span></span><br><span class="line"><span class="comment"> * obj-&gt;push(x);</span></span><br><span class="line"><span class="comment"> * obj-&gt;pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj-&gt;top();</span></span><br><span class="line"><span class="comment"> * int param_4 = obj-&gt;getMin();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h2 id="2-辅助栈"><a href="#2-辅助栈" class="headerlink" title="2. 辅助栈"></a>2. 辅助栈</h2><p>用一个辅助栈记录过程中的最小值，用额外<code>O(n)</code>的空间将<code>pop()</code>的复杂度降低为<code>O(1)</code>。<br>以下两种方式都可以：  </p>
<ul>
<li><strong>同步辅助栈</strong><br>数据栈：3, 1, 2, 4, 5, 1<br>辅助栈：3, 1, 1, 1, 1, 1  </li>
<li><strong>不同步辅助栈</strong><br>数据栈：3, 1, 2, 4, 5, 1<br>辅助栈：3, 1, 1  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    MinStack() &#123;</span><br><span class="line">        vals = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">        auxiliary = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">        capacity = <span class="number">10</span>;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">        auxCapa = <span class="number">10</span>;</span><br><span class="line">        auxSize = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~MinStack() &#123;</span><br><span class="line">        <span class="keyword">delete</span> []vals;</span><br><span class="line">        <span class="keyword">delete</span> []auxiliary;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (size == capacity) &#123;</span><br><span class="line">            vals = doubleArray(vals, size);</span><br><span class="line">            capacity *= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (auxSize == auxCapa) &#123;</span><br><span class="line">            auxiliary = doubleArray(auxiliary, auxSize);</span><br><span class="line">            auxCapa *= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vals[size++] = x;</span><br><span class="line">        <span class="keyword">if</span> (auxSize == <span class="number">0</span> || (auxSize &gt; <span class="number">0</span> &amp;&amp; x &lt;= auxiliary[auxSize - <span class="number">1</span>]))</span><br><span class="line">            auxiliary[auxSize++] = x;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (vals[size - <span class="number">1</span>] == auxiliary[auxSize - <span class="number">1</span>])</span><br><span class="line">            auxSize--;</span><br><span class="line">        size--;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> vals[size - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> auxiliary[auxSize - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span>* vals;</span><br><span class="line">    <span class="keyword">int</span>* auxiliary;</span><br><span class="line">    <span class="keyword">int</span> capacity;</span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">int</span> auxCapa;</span><br><span class="line">    <span class="keyword">int</span> auxSize;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span>* <span class="title">doubleArray</span><span class="params">(<span class="keyword">int</span>* before, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>* after = <span class="keyword">new</span> <span class="keyword">int</span>[n * <span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            after[i] = before[i];</span><br><span class="line">        <span class="keyword">delete</span> []before;</span><br><span class="line">        <span class="keyword">return</span> after;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MinStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MinStack* obj = new MinStack();</span></span><br><span class="line"><span class="comment"> * obj-&gt;push(x);</span></span><br><span class="line"><span class="comment"> * obj-&gt;pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj-&gt;top();</span></span><br><span class="line"><span class="comment"> * int param_4 = obj-&gt;getMin();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>50.Pow(x,n)</title>
    <url>/powx-n/</url>
    <content><![CDATA[<h2 id="1-快速幂"><a href="#1-快速幂" class="headerlink" title="1. 快速幂"></a>1. 快速幂</h2><p>时间<code>O(logn)</code>，空间<code>O(1)</code>。  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> N = n;</span><br><span class="line">        <span class="keyword">bool</span> isNegative = x &lt; <span class="number">0</span> &amp;&amp; N % <span class="number">2</span> == <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (isNegative)</span><br><span class="line">            x = -x;</span><br><span class="line">        <span class="keyword">if</span> (N &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// n = -n;     // n == INT32_MIN时不能直接取负，会溢出</span></span><br><span class="line">            N = -N;</span><br><span class="line">            x = <span class="number">1</span> / x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">double</span> ans = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (N &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (N &amp; <span class="number">1</span>)</span><br><span class="line">                ans *= x;</span><br><span class="line">            x *= x;</span><br><span class="line">            N &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isNegative)</span><br><span class="line">            ans = -ans;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>69.x的平方根</title>
    <url>/sqrtx/</url>
    <content><![CDATA[<h2 id="1-二分"><a href="#1-二分" class="headerlink" title="1. 二分"></a>1. 二分</h2><p>时间复杂度：<code>O(logn)</code>，空间复杂度<code>O(1)</code>。  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = x;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> midv = (<span class="keyword">long</span> <span class="keyword">long</span>)mid * mid;</span><br><span class="line">            <span class="keyword">if</span> (midv == x) &#123;</span><br><span class="line">                ans = mid;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (midv &lt; x) &#123;</span><br><span class="line">                ans = mid;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> </span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title>221.最大正方形</title>
    <url>/maximal-square/</url>
    <content><![CDATA[<h2 id="1-动态规划"><a href="#1-动态规划" class="headerlink" title="1. 动态规划"></a>1. 动态规划</h2><p>设<code>dp[i][j]</code>代表以<code>matrix[i][j]</code>为右下角的最大正方形的边长。<br>当<code>matrix[i][j] == 0</code>时，<code>dp[i][j] = 0</code>.<br>当<code>matrix[i][j] == 1</code>时，<code>dp[i][j] = min(dp[i-1][j-1], dp[i][j-1], dp[i-1][j]) + 1</code>.<br>如果越界，则上述min取0.  </p>
<p><code>matrix[i][j] == 1</code>的状态转移方程如上是因为：  </p>
<ol>
<li>假如<code>dp[i][j]</code>根据<code>dp[i-1][j-1]</code>来求，则需要判断i行j列的连续的1最多有多少，然后取<code>min(dp[i-1][j-1], i行的1, j列的1)</code>再加上1就是<code>dp[i][j]</code>。  </li>
<li>假如<code>dp[i][j]</code>根据<code>dp[i][j-1]</code>来求，则需要判断j列的连续的1最多有多少，如果j列的小，则<code>dp[i][j] = j列 + 1</code>，而如果j列的大，还需要判断<code>i-dp[i][j-1]</code>行有没有足够的1使得可以形成<code>dp[i][j] = dp[i][j-1] + 1</code>。<br><img src="draft_ij-1.png" alt="draft_ij-1">  </li>
<li>假如<code>dp[i][j]</code>根据<code>dp[i-1][j]</code>来求，则需要判断i行的连续的1最多有多少，如果i行的小，则<code>dp[i][j] = i行 + 1</code>，而如果i行的大，还需要判断<code>j-dp[i][j-1]</code>列有没有足够的1使得可以形成<code>dp[i][j] = dp[i-1][j] + 1</code>。<br><img src="draft_i-1j.png" alt="draft_i-1j">  </li>
</ol>
<p>如果按照上面三种之一的求法，需要在遍历到每个点的时候，最多还要判断<code>O(min(m, n))</code>次，因此时间复杂度是<code>O(mn*min(m, n))</code>。<br>而我们可以发现，1需要的i行j列的连续的1的个数在<code>dp[i][j-1]</code>和<code>dp[i-1][j]</code>中分别有表示，2需要的j列的连续的1在<code>dp[i-1][j]</code>中有所表示，需要的<code>i-dp[i][j-1]</code>行的1的个数在<code>dp[i-1][j-1]</code>和<code>dp[i][j-1]</code>中有所表示。  </p>
<p>所以我们发现，可以取<code>min(dp[i-1][j-1], dp[i][j-1], dp[i-1][j]) + 1</code>作为<code>dp[i][j]</code>，因为三者中最小的正方形要形成+1大的正方形需要的部分是另外两个较大的正方形可以提供的。<br><img src="draft.png" alt="draft">  </p>
<p>由上述状态转移方程可以得到时间复杂度<code>O(mn)</code>，空间复杂度<code>O(mn)</code>。<br>不过该空间复杂度可以优化，因为<code>dp[i][j]</code>的求解仅依赖于左上方三个部分的值，所以可以将<code>O(mn)</code>的数组优化为<code>O(n)</code>的数组，只保留一行，空间复杂度就变成了<code>O(n)</code>。  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maximalSquare</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = matrix.size();</span><br><span class="line">        <span class="keyword">if</span> (m == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = matrix[<span class="number">0</span>].size();</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> mi[<span class="number">3</span>] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> mj[<span class="number">3</span>] = &#123;<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> upperLeft = INT32_MAX;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[i][j] == <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">                    upperLeft = dp[j];</span><br><span class="line">                    dp[j] = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">int</span> limit = INT32_MAX;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">3</span>; k++) &#123;</span><br><span class="line">                    <span class="keyword">int</span> curi = i + mi[k], curj = j + mj[k];</span><br><span class="line">                    <span class="keyword">if</span> (curi &gt;= <span class="number">0</span> &amp;&amp; curi &lt; m &amp;&amp; curj &gt;= <span class="number">0</span> &amp;&amp; curj &lt; n) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (mi[k] == <span class="number">-1</span> &amp;&amp; mj[k] == <span class="number">-1</span>)</span><br><span class="line">                            limit = min(limit, upperLeft);</span><br><span class="line">                        <span class="keyword">else</span> </span><br><span class="line">                            limit = min(limit, dp[curj]);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        limit = <span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (limit == INT32_MAX)</span><br><span class="line">                    limit = <span class="number">0</span>;</span><br><span class="line">                </span><br><span class="line">                upperLeft = dp[j];</span><br><span class="line">                dp[j] = limit + <span class="number">1</span>;</span><br><span class="line">                ans = max(ans, dp[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans * ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>572.另一棵树的子树</title>
    <url>/subtree-of-another-tree/</url>
    <content><![CDATA[<h2 id="相关题目："><a href="#相关题目：" class="headerlink" title="相关题目："></a>相关题目：</h2><p><strong>100. 相同的树</strong>  </p>
<h2 id="1-递归"><a href="#1-递归" class="headerlink" title="1. 递归"></a>1. 递归</h2><p>t是s的子树，则可能是：  </p>
<ol>
<li>s的子树</li>
<li>s的左子树的子树</li>
<li>s的右子树的子树</li>
</ol>
<p>而判断是否是子树的过程，就是判断当前s中为根的节点的子树与t树是否相同。<br>时间复杂度：这里与“相同的树”遍历所有节点<code>O(n)</code>不同，此处最差需要看s的每一个节点对应的子树是否是与t相同的，所以需要<code>O(|s| * |t|)</code>.<br>空间复杂度：递归栈最深是<code>O(n)</code>.  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSameTree</span><span class="params">(TreeNode* s, TreeNode* t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="literal">nullptr</span> &amp;&amp; t == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="literal">nullptr</span> || t == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (s-&gt;val != t-&gt;val)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> isSameTree(s-&gt;left, t-&gt;left) &amp;&amp; isSameTree(s-&gt;right, t-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSubtree</span><span class="params">(TreeNode* s, TreeNode* t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="literal">nullptr</span> &amp;&amp; t == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (s-&gt;val != t-&gt;val)   <span class="comment">// 如果s和t的根节点的值不等，则t只可能是s的左或右子树的子树</span></span><br><span class="line">            <span class="keyword">return</span> isSubtree(s-&gt;left, t) || isSubtree(s-&gt;right, t);</span><br><span class="line">        <span class="keyword">else</span>                    <span class="comment">// 如果s和t的根节点的值相等，则t与s可能相同，而如果不同则只可能是s的左或右子树的子树</span></span><br><span class="line">            <span class="keyword">return</span> isSameTree(s, t) || isSubtree(s-&gt;left, t) || isSubtree(s-&gt;right, t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>100.相同的树</title>
    <url>/same-tree/</url>
    <content><![CDATA[<h2 id="1-递归"><a href="#1-递归" class="headerlink" title="1. 递归"></a>1. 递归</h2><p>两棵树相同，则所有的节点的值和位置相同。<br>可以通过递归比较根左右的想等情况。<br>时间复杂度：遍历所有节点<code>O(n)</code>.<br>空间复杂度：递归栈最深是<code>O(n)</code>.  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSameTree</span><span class="params">(TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="literal">nullptr</span> &amp;&amp; q == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="literal">nullptr</span> || q == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;val != q-&gt;val)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> isSameTree(p-&gt;left, q-&gt;left) &amp;&amp; isSameTree(p-&gt;right, q-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2-迭代"><a href="#2-迭代" class="headerlink" title="2. 迭代"></a>2. 迭代</h2><p>相同的方法，不过用stack模拟递归栈来实现。<br>时间复杂度和空间复杂度与上述递归方法相同。  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSameTree</span><span class="params">(TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="built_in">pair</span>&lt;TreeNode*, TreeNode*&gt; &gt; st;</span><br><span class="line">        st.push(<span class="built_in">make_pair</span>(p, q));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (!st.empty()) &#123;</span><br><span class="line">            <span class="built_in">pair</span>&lt;TreeNode*, TreeNode*&gt; temp = st.top();</span><br><span class="line">            st.pop();</span><br><span class="line">            p = temp.first;</span><br><span class="line">            q = temp.second;</span><br><span class="line">            <span class="keyword">if</span> (p == <span class="literal">nullptr</span> &amp;&amp; q == <span class="literal">nullptr</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (p == <span class="literal">nullptr</span> || q == <span class="literal">nullptr</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;val != q-&gt;val)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            st.push(<span class="built_in">make_pair</span>(p-&gt;left, q-&gt;left));</span><br><span class="line">            st.push(<span class="built_in">make_pair</span>(p-&gt;right, q-&gt;right));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>983.最低票价</title>
    <url>/minimum-cost-for-tickets/</url>
    <content><![CDATA[<h2 id="1-动态规划（从前往后）"><a href="#1-动态规划（从前往后）" class="headerlink" title="1. 动态规划（从前往后）"></a>1. 动态规划（从前往后）</h2><p><code>dp[i]</code>代表从开始到第<code>days[i]</code>天(包括这一天)花费的钱。  </p>
<p>如果求解<code>dp[i]</code>是遍历到i时再去看前1天、前7天和前30天花的钱+再买票的钱是没法计算的，因为前面的那些天已经买票了，即30天前的那一天可能已经花钱买了30天的票，如果再+票钱的话，就多余了。<br>所以就需要在<code>dp[i]</code>这天买票的时候，就将之后的在票范围内的<code>dp[j]</code>更新掉。  </p>
<p>遍历到每一天<code>days[i]</code>，我们都假设这一天没有旅游，需要买票（加上上次旅游花的钱即<code>dp[i-1]</code>），并把买票之后可以访问到的<code>dp[j]</code>更新。<br>这样就可以得到每一个<code>days[j]</code>之前的天数花费一定的票费到达<code>days[j]</code>这一天。</p>
<p>如果是访问到<code>days[i]</code>这天发现已经通过之前的票旅游过了，那么这就是从开始到<code>days[i]</code>天花费的最少的钱。<br>而如果访问到<code>days[i]</code>这天，发现之前旅游买票还没有能长到这天的（即<code>dp[i] == INT32_MAX</code>时），就根据旅游到前一次花费的最少的钱<code>dp[i-1]</code>来更新<code>dp[i]</code>。  </p>
<p>时间复杂度：因为要算后面最多30天的dp，所以<code>O(30*n) = O(n)</code>.<br>空间复杂度：<code>O(n)</code>.  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">mincostTickets</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; days, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; costs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = days.size();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n, INT32_MAX)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> duration[<span class="number">3</span>] = &#123;<span class="number">1</span>, <span class="number">7</span>, <span class="number">30</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> last = i == <span class="number">0</span> ? <span class="number">0</span> : dp[i - <span class="number">1</span>];</span><br><span class="line">            dp[i] = min(dp[i], last + min(&#123;costs[<span class="number">0</span>], costs[<span class="number">1</span>], costs[<span class="number">2</span>]&#125;));</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt; <span class="number">3</span>; k++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n &amp;&amp; days[j] - days[i] &lt; duration[k]; j++)</span><br><span class="line">                    dp[j] = min(dp[j], last + costs[k]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2-动态规划（从后往前）"><a href="#2-动态规划（从后往前）" class="headerlink" title="2. 动态规划（从后往前）"></a>2. 动态规划（从后往前）</h2><p><code>dp[i]</code>代表从第<code>days[i]</code>天到最后一天旅游需要花的最少的费用。  </p>
<p>在<code>days[i]</code>天：  </p>
<ol>
<li>可能买1天的票到达<code>days[i+1]</code>天</li>
<li>可能买7天的票到达<code>days[j7]</code>天</li>
<li>可能买30天的票到达<code>days[j30]</code>天<br><code>days[j7], days[j30]</code>分别代表在<code>days[i]</code>天买7, 30天的票可以到达的最远的一天。<br>因为<code>days[i] &gt;= days[i+1]</code>必成立，所以可以贪心一下找到最后一天。<br><code>dp[i] = min(dp[i + 1] + costs[0/1/2], dp[j7] + costs[2], dp[j30] + costs[3])</code>  </li>
</ol>
<p>时间复杂度：因为要算后面最多30天的dp，所以<code>O(30*n) = O(n)</code>.<br>空间复杂度：<code>O(n)</code>.  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">mincostTickets</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; days, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; costs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = days.size();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n, INT32_MAX)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> duration[<span class="number">3</span>] = &#123;<span class="number">1</span>, <span class="number">7</span>, <span class="number">30</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">int</span> next = i == n - <span class="number">1</span> ? <span class="number">0</span> : dp[i + <span class="number">1</span>];</span><br><span class="line">            dp[i] = next + min(&#123;costs[<span class="number">0</span>], costs[<span class="number">1</span>], costs[<span class="number">2</span>]&#125;);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt; <span class="number">3</span>; k++) </span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n &amp;&amp; days[j] - days[i] &lt; duration[k]; j++)</span><br><span class="line">                    dp[i] = min(dp[i], dp[j] + costs[k]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h2><p>正序遍历和逆序遍历的代码几乎是完全一样的，但是思想上却有很大的差距。<br>正序遍历是根据之前的买上票之后把之后可以到达的更新掉，<br>逆序遍历是根据之后花的最少的钱加上这一天花的可以到达之后那一天的票钱。  </p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>98.验证二叉搜索树</title>
    <url>/validate-binary-search-tree/</url>
    <content><![CDATA[<h2 id="1-中序遍历判断是否是递增序列"><a href="#1-中序遍历判断是否是递增序列" class="headerlink" title="1. 中序遍历判断是否是递增序列"></a>1. 中序遍历判断是否是递增序列</h2><p><strong>中序遍历：左根右</strong><br>可以用递归实现，也可以用栈模拟递归栈来迭代实现，这里用迭代实现。<br>时间复杂度：遍历所有的节点，<code>O(n)</code>。<br>空间复杂度：递归栈，深度最大<code>O(n)</code>。  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pre = INT32_MIN;</span><br><span class="line">        <span class="keyword">bool</span> modified = <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; st;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (root != <span class="literal">nullptr</span> || !st.empty()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (root != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                st.push(root);</span><br><span class="line">                root = root-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            root = st.top();</span><br><span class="line">            st.pop();</span><br><span class="line">            <span class="keyword">if</span> (!modified) &#123;</span><br><span class="line">                pre = root-&gt;val;</span><br><span class="line">                modified = <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (pre &lt; root-&gt;val)</span><br><span class="line">                    pre = root-&gt;val;</span><br><span class="line">                <span class="keyword">else</span> </span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            root = root-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>45.跳跃游戏II</title>
    <url>/jump-game-ii/</url>
    <content><![CDATA[<h2 id="1-朴素dp"><a href="#1-朴素dp" class="headerlink" title="1. 朴素dp"></a>1. 朴素dp</h2><p><code>dp[i]</code>记录从开始到<code>nums[i]</code>节点需要的最少的跳数，则状态转移方程：<br><code>dp[i] = min(dp[j] + 1), if (j &lt; i &amp;&amp; j + nums[j] &gt;= i)</code><br>时间<code>O(n^2)</code>，空间<code>O(n)</code>。<br><em>超时。</em>  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">jump</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span>* dp = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">            dp[i] = INT32_MAX;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j + nums[j] &gt;= i)</span><br><span class="line">                    dp[i] = dp[i] &lt;= dp[j] + <span class="number">1</span> ? dp[i] : dp[j] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ans = dp[n - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">delete</span> []dp;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2-优化方法1的记录方式"><a href="#2-优化方法1的记录方式" class="headerlink" title="2. 优化方法1的记录方式"></a>2. 优化方法1的记录方式</h2><p>可以在访问到i节点的时候，将其可以访问到的右侧的节点的<code>dp[j]</code>更新。<br>而由于定义的<code>dp[i]</code>数组一定是随着i的增加而增大的，所以之后的<code>dp[j]</code>只需要更新第一次即可。<br>由于只需要更新一次dp数组，所以时间复杂度是<code>O(n)</code>，空间复杂度也是<code>O(n)</code>.  </p>
<p>还可以想到，i节点更新完它可以访问到的j节点的<code>dp[j]</code>时，<code>dp[i]</code>的作用就完成了，后续不会再使用。<br>同时，由于一次更新的好多j节点的<code>dp[j]</code>的值都是<code>dp[i]+1</code>，所以可以只用一个变量来记录这个值。<br>这些等待下次被访问的条数相同的节点可以存到队列中，类似BFS，一段一段地向右前进。<br>这样，空间复杂度就变成了最差是<code>O(n)</code>.  </p>
<p>由于每次跳数+1得到的是下一个连续的段，所以可以不用队列储存这一个段的元素，而是使用左右两个索引来记录。<br>这样的空间复杂度就优化到了<code>O(1)</code>.  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">jump</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; n) &#123;</span><br><span class="line">            <span class="keyword">int</span> nextRight = right;</span><br><span class="line">            <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">                nextRight = max(nextRight, left + nums[left]);</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            ans++;</span><br><span class="line">            right = nextRight;</span><br><span class="line">            <span class="keyword">if</span> (right &gt;= n - <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>55.跳跃游戏</title>
    <url>/jump-game/</url>
    <content><![CDATA[<h2 id="1-朴素"><a href="#1-朴素" class="headerlink" title="1. 朴素"></a>1. 朴素</h2><p><code>bool reach[]</code>记录是否可以到达。<br>遍历<code>nums[i]</code>，将其可以到达的位置置为true。时间复杂度是<code>O(n)</code>，因为就算修改<code>reach[]</code>是<code>O(n)</code>，但是还是可能会去访问后续的元素（即使没有修改），导致需要的时间很长。空间复杂度<code>O(n)</code>。  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canJump</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">bool</span> *reach = <span class="keyword">new</span> <span class="keyword">bool</span>[n] &#123;<span class="literal">false</span>&#125;;</span><br><span class="line"></span><br><span class="line">        reach[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!reach[i])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= nums[i]; k++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i + k &gt;= n)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">if</span> (!reach[i + k])</span><br><span class="line">                    reach[i + k] = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span> (i + k == n - <span class="number">1</span>) &#123;       <span class="comment">// 适当剪枝</span></span><br><span class="line">                    <span class="keyword">delete</span> []reach;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">bool</span> ans = reach[n - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">delete</span> []reach;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2-记录右侧最远距离"><a href="#2-记录右侧最远距离" class="headerlink" title="2. 记录右侧最远距离"></a>2. 记录右侧最远距离</h2><p>考虑题目要求，由于可走的长度是&gt;=0的，因此可以直接记录最远的距离，而最远距离左侧的距离一定可达。<br>当当前距离超过最远距离时，意味着当前距离无法到达。<br>时间复杂度<code>O(n)</code>，空间复杂度<code>O(1)</code>。  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canJump</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">int</span> farthest = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; farthest)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            farthest = farthest &gt;= i + nums[i] ? farthest : i + nums[i];</span><br><span class="line">            <span class="keyword">if</span> (farthest &gt;= n - <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>53. 最大子序和</title>
    <url>/maximum-subarray/</url>
    <content><![CDATA[<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1-滑动窗口"><a href="#1-滑动窗口" class="headerlink" title="1. 滑动窗口"></a>1. 滑动窗口</h2><p>当窗口内的值为正时，右边界一直向右移动（因为左侧总是可以作为正数部分）<br>当窗口内的值为负时，左边界跳过右边界（因为左侧已经是负数了）<br>时间<code>O(n)</code>，空间<code>O(1)</code>。  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> loc = <span class="number">0</span>, ans = nums[<span class="number">0</span>], cur = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (loc &lt; n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                cur += nums[loc++];</span><br><span class="line">                ans = ans &gt;= cur ? ans : cur;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                cur = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2-分治"><a href="#2-分治" class="headerlink" title="2. 分治"></a>2. 分治</h2><p><a href="https://leetcode-cn.com/problems/maximum-subarray/solution/zui-da-zi-xu-he-by-leetcode-solution/">https://leetcode-cn.com/problems/maximum-subarray/solution/zui-da-zi-xu-he-by-leetcode-solution/</a><br>很奇妙。<br>维护了区间的：整个区间的和、以左端点为起点的最大子段和、以右端点为终点的最大子段和、整个区间最优的最大子段和。<br>这样，在分治合并的时候，求一个区间的上述四种属性可以这样求：  </p>
<ol>
<li>整个区间的和：左右子区间的整个区间的和之和。</li>
<li>以左端点为起点的最大子段和：可能只是左子区间的以左端点为起点的最大字段和，也有可能是整个左子区间+右子区间以左端点为起点的部分和。  </li>
<li>以右端点为终点的最大子段和：跟2正好相对。  </li>
<li>整个区间的最大子段和：可能是左或右子区间的最大子段和，也可能是跨越左右子区间的（左子区间中以右端点为终点的部分+右子区间中以左端点为起点的部分）  </li>
</ol>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>滑动窗口</tag>
      </tags>
  </entry>
  <entry>
    <title>3.无重复字符的最长子串</title>
    <url>/longest-substring-without-repeating-characters/</url>
    <content><![CDATA[<h2 id="1-滑动窗口"><a href="#1-滑动窗口" class="headerlink" title="1. 滑动窗口"></a>1. 滑动窗口</h2><p>因为只知道是字符，所以用hash表（unordered_map)来判重。<br>hash表中记录字符位置，当遇到重复时，跳过记录的该字符的位置到达下一个位置。<br>时间复杂度<code>O(n)</code>，空间复杂度<code>O(字符数)</code>（hash表占用）  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        <span class="keyword">if</span> (len &lt; <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> len;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; loc;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (right &lt; len) &#123;</span><br><span class="line">            <span class="keyword">if</span> (loc.count(s[right]) == <span class="number">1</span> &amp;&amp; loc[s[right]] &gt;= left) &#123;</span><br><span class="line">                ans = ans &gt;= right - left ? ans : right - left;</span><br><span class="line">                left = loc[s[right]] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            loc[s[right]] = right;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = ans &gt;= right - left ? ans : right - left;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>滑动窗口</tag>
      </tags>
  </entry>
  <entry>
    <title>21.合并两个有序链表</title>
    <url>/merge-two-sorted-lists/</url>
    <content><![CDATA[<h2 id="1-双指针"><a href="#1-双指针" class="headerlink" title="1. 双指针"></a>1. 双指针</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        ListNode* ans = <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* p = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span> (l1 != <span class="literal">nullptr</span> || l2 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ans == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (l1 == <span class="literal">nullptr</span> || (l1 != <span class="literal">nullptr</span> &amp;&amp; l2 != <span class="literal">nullptr</span> &amp;&amp; l1-&gt;val &gt; l2-&gt;val)) &#123;</span><br><span class="line">                    ans = <span class="keyword">new</span> ListNode(l2-&gt;val);</span><br><span class="line">                    l2 = l2-&gt;next;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (l2 == <span class="literal">nullptr</span> || (l1 != <span class="literal">nullptr</span> &amp;&amp; l2 != <span class="literal">nullptr</span> &amp;&amp; l1-&gt;val &lt;= l2-&gt;val)) &#123;</span><br><span class="line">                    ans = <span class="keyword">new</span> ListNode(l1-&gt;val);</span><br><span class="line">                    l1 = l1-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                p = ans;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (l1 == <span class="literal">nullptr</span> || (l1 != <span class="literal">nullptr</span> &amp;&amp; l2 != <span class="literal">nullptr</span> &amp;&amp; l1-&gt;val &gt; l2-&gt;val)) &#123;</span><br><span class="line">                p-&gt;next = <span class="keyword">new</span> ListNode(l2-&gt;val);</span><br><span class="line">                p = p-&gt;next;</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (l2 == <span class="literal">nullptr</span> || (l1 != <span class="literal">nullptr</span> &amp;&amp; l2 != <span class="literal">nullptr</span> &amp;&amp; l1-&gt;val &lt;= l2-&gt;val)) &#123;</span><br><span class="line">                p-&gt;next = <span class="keyword">new</span> ListNode(l1-&gt;val);</span><br><span class="line">                p = p-&gt;next;</span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>202.快乐数</title>
    <url>/happy-number/</url>
    <content><![CDATA[<h2 id="1-直接模拟，set检测是否重复"><a href="#1-直接模拟，set检测是否重复" class="headerlink" title="1. 直接模拟，set检测是否重复"></a>1. 直接模拟，set检测是否重复</h2><p><code>set</code>：<code>find()</code>和<code>count()</code>对数级别复杂度，插入<code>insert()</code>在给定迭代器作为位置的情况下是<code>O(1)</code>，不给则是对数级别复杂度。<br><code>unordered_set</code>：<code>find()</code>和<code>count()</code>平均是<code>O(1)</code>，最坏<code>O(n)</code>（hash函数太差了），插入<code>insert()</code>同查找。  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isHappy</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; unique;</span><br><span class="line">        unique.insert(n);</span><br><span class="line">        <span class="keyword">int</span> copyn = n;</span><br><span class="line">        <span class="keyword">while</span> (n != <span class="number">1</span>) &#123;</span><br><span class="line">            n = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (copyn != <span class="number">0</span>) &#123;</span><br><span class="line">                n += <span class="built_in">pow</span>((copyn % <span class="number">10</span>), <span class="number">2</span>);</span><br><span class="line">                copyn /= <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            copyn = n;</span><br><span class="line">            <span class="keyword">if</span> (unique.count(n) == <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                unique.insert(n);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2-快慢指针"><a href="#2-快慢指针" class="headerlink" title="2. 快慢指针"></a>2. 快慢指针</h2><p>如果有结果，那么就好像是一条链一样。<br>如果没结果，不是快乐数，则代表有循环，也就可以转换成环形链表来做，快慢指针重合时代表不是快乐数。<br>这样就避免了set一直存数。<br>时间上跟unordered_set一样都是<code>O(logn)</code>，空间更优，是<code>O(1)</code>。  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getNext</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">            ans += <span class="built_in">pow</span>(n % <span class="number">10</span>, <span class="number">2</span>);</span><br><span class="line">            n /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isHappy</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> slow = n, quick = getNext(n);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (quick != <span class="number">1</span> &amp;&amp; slow != quick) &#123;</span><br><span class="line">            slow = getNext(slow);</span><br><span class="line">            quick = getNext(getNext(quick));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> quick == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>1095.山脉数组中查找目标值</title>
    <url>/find-in-mountain-array/</url>
    <content><![CDATA[<h2 id="1-二分"><a href="#1-二分" class="headerlink" title="1. 二分"></a>1. 二分</h2><p><del>二分，然后根据左右大小关系判断是上升还是下降，选择不同部分继续二分就好了。</del><br>本来打算一次二分做的，不过发现当<code>nums[mid] &gt; target</code>时，两侧部分都需要进行二分。<br>所以还是先二分找到分界点，然后再二分左侧和右侧吧，最多是3次二分。  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * // This is the MountainArray&#x27;s API interface.</span></span><br><span class="line"><span class="comment"> * // You should not implement it, or speculate about its implementation</span></span><br><span class="line"><span class="comment"> * class MountainArray &#123;</span></span><br><span class="line"><span class="comment"> *   public:</span></span><br><span class="line"><span class="comment"> *     int get(int index);</span></span><br><span class="line"><span class="comment"> *     int length();</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findInMountainArray</span><span class="params">(<span class="keyword">int</span> target, MountainArray &amp;mountainArr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = mountainArr.length();</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> topIndex = <span class="number">-1</span>, topValue = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> midv = mountainArr.get(mid);</span><br><span class="line">            <span class="keyword">int</span> midrv = mountainArr.get(mid + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (midv &lt; midrv) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">                topIndex = mid + <span class="number">1</span>;</span><br><span class="line">                topValue = midrv;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> midlv = mountainArr.get(mid - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (midv &lt; midlv) &#123;</span><br><span class="line">                    right = mid - <span class="number">1</span>;</span><br><span class="line">                    topIndex = mid - <span class="number">1</span>;</span><br><span class="line">                    topValue = midlv;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    topIndex = mid;</span><br><span class="line">                    topValue = midv;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (target &gt; topValue)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (target == topValue)</span><br><span class="line">            <span class="keyword">return</span> topIndex;</span><br><span class="line"></span><br><span class="line">        left = <span class="number">0</span>;</span><br><span class="line">        right = topIndex;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> midv = mountainArr.get(mid);</span><br><span class="line">            <span class="keyword">if</span> (midv == target) &#123;</span><br><span class="line">                ans = mid;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (midv &lt; target) </span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ans != <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        </span><br><span class="line">        left = topIndex + <span class="number">1</span>;</span><br><span class="line">        right = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> midv = mountainArr.get(mid);</span><br><span class="line">            <span class="keyword">if</span> (midv == target) &#123;</span><br><span class="line">                ans = mid;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (midv &lt; target)</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title>面试题56 - I. 数组中数字出现的次数</title>
    <url>/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/</url>
    <content><![CDATA[<h2 id="1-位运算"><a href="#1-位运算" class="headerlink" title="1. 位运算"></a>1. 位运算</h2><p><strong>异或^：相同为0，不同为1.</strong><br>假如只有一个不成对出现的数字，则基于这个性质，成对出现的数字异或起来得到全0，再异或上这个数字，结果就是这个数字，所以只需要全部异或起来就可以了。（妙啊  </p>
<p>如果有两个不成对出现的数字a, b，则全部异或得到a^b，并不是想要的答案。<br>我们可以想到，如果把数据分为两组，1组有a和一部分成对的数据，2组有b和剩余部分成对的数据，则1组全部异或得到a，2组全部异或得到b。<br><em>现在的问题是如何分为两组。</em><br>a^b得到的结果中，有的位是0，有的位是1，而1的位说明a和b在该位上不相等。<br>所以可以取任意一个为1的位，将该位为1的数据分到1组，该位为0的数据分到2组。<br>这样1和2一定可以分开。<br>而由于成对出现的数据在同一位上一定是相同的，所以也可以被分到同一个组中，这样分组就完成了。  </p>
<p>实际上也并不需要显式地分成两部分。<br>只要在循环的时候判断某一位是01，然后对应的异或到相应位置就可以了。  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">singleNumbers</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> nums;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> allXor = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            allXor ^= nums[i];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> loc = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> ((loc &amp; allXor) == <span class="number">0</span>)</span><br><span class="line">            loc &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((nums[i] &amp; loc) == <span class="number">0</span>)</span><br><span class="line">                a ^= nums[i];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                b ^= nums[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> &#123;a, b&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>33.搜索旋转排序数组</title>
    <url>/search-in-rotated-sorted-array/</url>
    <content><![CDATA[<h2 id="1-二分查找"><a href="#1-二分查找" class="headerlink" title="1. 二分查找"></a>1. 二分查找</h2><p>通过左和中的大小关系判断是升序还是中间旋转了。<br>时间<code>O(logn)</code>，空间<code>O(1)</code>。  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[left] &gt; target) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[mid] &gt;= nums[left])</span><br><span class="line">                    left = mid + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (nums[mid] &gt; target)</span><br><span class="line">                        right = mid - <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target)</span><br><span class="line">                        left = mid + <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        ans = mid;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[left] &lt; target) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[mid] &gt;= nums[left]) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (nums[mid] &gt; target)</span><br><span class="line">                        right = mid - <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target)</span><br><span class="line">                        left = mid + <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        ans = mid;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> </span><br><span class="line">                    right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ans = left;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title>23.合并K个排序链表</title>
    <url>/merge-k-sorted-lists/</url>
    <content><![CDATA[<h2 id="1-两个有序链表合并的扩展"><a href="#1-两个有序链表合并的扩展" class="headerlink" title="1. 两个有序链表合并的扩展"></a>1. 两个有序链表合并的扩展</h2><p>每次比较k个链表，这样每合并出一个节点，就需要<code>O(k^2)</code>的时间。所以此处可以优化一下，使用堆就可以以<code>O(klogk)</code>的时间得到最小值，花费最大<code>O(k)</code>空间。<br>为了获得堆顶弹出的元素来自的链表，所以还需要一起记录一下，可以用pair。<br>插入一次需要<code>O(logk)</code>的时间，一共nk个元素都需要进出堆，所以时间复杂度为<code>O(nklogk)</code>。  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(<span class="built_in">vector</span>&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = lists.size();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// pair-&gt;first记录节点值，pair-&gt;second记录来自的链表的编号</span></span><br><span class="line">        <span class="built_in">priority_queue</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;, <span class="built_in">vector</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;, greater&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&gt; heap;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;ListNode*&gt; <span class="title">nextLocs</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;       <span class="comment">// 初始化</span></span><br><span class="line">            <span class="keyword">if</span> (lists[i] != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                heap.push(<span class="built_in">make_pair</span>(lists[i]-&gt;val, i));</span><br><span class="line">                nextLocs[i] = lists[i]-&gt;next;</span><br><span class="line">            &#125; <span class="keyword">else</span> </span><br><span class="line">                nextLocs[i] = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (heap.empty())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; temp = heap.top();</span><br><span class="line">        heap.pop();</span><br><span class="line">        ListNode* ans = <span class="keyword">new</span> ListNode(temp.first);</span><br><span class="line">        ListNode* p = ans;</span><br><span class="line">        <span class="keyword">if</span> (nextLocs[temp.second] != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            heap.push(<span class="built_in">make_pair</span>(nextLocs[temp.second]-&gt;val, temp.second));</span><br><span class="line">            nextLocs[temp.second] = nextLocs[temp.second]-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!heap.empty()) &#123;</span><br><span class="line">            temp = heap.top();</span><br><span class="line">            heap.pop();</span><br><span class="line">            p-&gt;next = <span class="keyword">new</span> ListNode(temp.first);</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (nextLocs[temp.second] != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                heap.push(<span class="built_in">make_pair</span>(nextLocs[temp.second]-&gt;val, temp.second));</span><br><span class="line">                nextLocs[temp.second] = nextLocs[temp.second]-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>堆</tag>
      </tags>
  </entry>
  <entry>
    <title>46.全排列</title>
    <url>/permutations/</url>
    <content><![CDATA[<h2 id="1-递归-回溯"><a href="#1-递归-回溯" class="headerlink" title="1. 递归+回溯"></a>1. 递归+回溯</h2><p><img src="tree.jpg" alt="backtrack_tree"><br>因为回溯是可以画出一棵回溯树的，所以光第一层调用dfs就要n次，而每次dfs还要层层深入，所以复杂度是很高的。<br>leetcode官方题解上分析出（组合数的加法），时间复杂度是<code>O(n*n!)</code>，空间复杂度由于结果数组，所以是<code>O(n*n!)</code>，如果不考虑结果数组的话，则是<code>O(n)</code>。  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">permute</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">cur</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">visited</span><span class="params">(n)</span> </span>&#123;<span class="literal">false</span>&#125;;</span><br><span class="line"></span><br><span class="line">        dfs(nums, cur, ans, visited, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; cur, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; ans, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&amp; visited, <span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (count == nums.size()) &#123;</span><br><span class="line">            ans.push_back(cur);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!visited[i]) &#123;</span><br><span class="line">                cur[count] = nums[i];</span><br><span class="line">                visited[i] = <span class="literal">true</span>;</span><br><span class="line">                dfs(nums, cur, ans, visited, count + <span class="number">1</span>);</span><br><span class="line">                visited[i] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>面试题51. 数组中的逆序对</title>
    <url>/shu-zu-zhong-de-ni-xu-dui-lcof/</url>
    <content><![CDATA[<h2 id="1-归并排序"><a href="#1-归并排序" class="headerlink" title="1. 归并排序"></a>1. 归并排序</h2><p>归并排序的讲解见每日1题-912，<a href="https://oi-wiki.org/basic/merge-sort/">归并排序的一个用途之一就是求解逆序对</a>.<br>归并排序在每次合并的时候，如果是将右半部分的一个元素移入到合并后的数组中，则说明左侧数组中剩下部分的元素都大于右半部分的这个元素。<br>这样一下子就得到了好多逆序对。<br>只需要对原有的归并排序添加count即可。<br>时间复杂度<code>O(nlogn)</code>，空间复杂度<code>O(n)</code>，均同于归并排序。  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">reversePairs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">cpnums</span><span class="params">(nums)</span></span>;   <span class="comment">// 不破坏原有数组nums</span></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">temp</span><span class="params">(n)</span></span>;        <span class="comment">// 临时数组，避免内部频繁构造和析构</span></span><br><span class="line">        mergeSort(cpnums, temp, <span class="number">0</span>, n - <span class="number">1</span>, ans);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; temp, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span>&amp; count)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left &gt;= right)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        mergeSort(nums, temp, left, mid, count);       <span class="comment">// 对左半部分排序</span></span><br><span class="line">        mergeSort(nums, temp, mid + <span class="number">1</span>, right, count);  <span class="comment">// 对右半部分排序</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 合并有序的左右两部分</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &lt;= nums[mid + <span class="number">1</span>])         <span class="comment">// 已经有序</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i = left, j = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = left; k &lt;= right; k++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; mid)</span><br><span class="line">                temp[k] = nums[j++];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (j &gt; right)</span><br><span class="line">                temp[k] = nums[i++];</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] &lt;= nums[j])</span><br><span class="line">                    temp[k] = nums[i++];</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    temp[k] = nums[j++];</span><br><span class="line">                    count += mid - i + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = left; k &lt;= right; k++)</span><br><span class="line">            nums[k] = temp[k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>面试题 08.11. 硬币</title>
    <url>/coin-lcci/</url>
    <content><![CDATA[<h2 id="1-数学方法"><a href="#1-数学方法" class="headerlink" title="1. 数学方法"></a>1. 数学方法</h2><p>时间<code>O(n)</code>，空间<code>O(1)</code>，不过要是能继续把公式往下推的话，可能会有时间<code>O(1)</code>吧。<br><img src="draft.png" alt="draft">  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">waysToChange</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n / <span class="number">25</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = n - <span class="number">25</span> * i;</span><br><span class="line">            ans = (ans + (<span class="keyword">long</span> <span class="keyword">long</span>)(temp / <span class="number">10</span> + <span class="number">1</span>) * (temp / <span class="number">5</span> - temp / <span class="number">10</span> + <span class="number">1</span>) % <span class="number">1000000007</span>) % <span class="number">1000000007</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2-完全背包的方案数"><a href="#2-完全背包的方案数" class="headerlink" title="2. 完全背包的方案数"></a>2. 完全背包的方案数</h2><p>背包容量：n<br>物品价值：1, 5, 10, 25<br>物品体积：1, 5, 10, 25<br>要求恰好装满容量为n的背包，并求解方案数。<br>用完全背包：时间<code>O(NV) = O(4*n) = O(n)</code>，空间<code>O(n)</code>  </p>
<p>如果是求恰好装满的最大价值，则是普通的完全背包问题。<br>初始化<code>dp[i] = -INF; dp[0] = 0</code><br>转移是<code>dp[i] = max(dp[i], dp[i - w[i]] + v[i])</code>  </p>
<p>而现在是求恰好装满的方案数，是一个变种的完全背包问题。<br>初始化<code>dp[i] = 0</code>，代表初始时没有方案可以满足完全装满容量为i的背包。<br>初始化<code>dp[0] = 1</code>，代表容量为0的背包恰好装满有1种方案。<br>转移是<code>dp[i] = dp[i] + dp[i - w[i]]</code>，代表容量为i的背包恰好装满取决于上一次（只看前部分的物品）装满容量为i的背包的方案数（不装当前物品）+上一次装满容量为<code>i-w[i]</code>的背包的方案数（装上当前物品）。  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">waysToChange</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>* dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>]&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> coins[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">25</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = coins[i]; j &lt;= n; j++) </span><br><span class="line">                dp[j] = (dp[j] + dp[j - coins[i]]) % <span class="number">1000000007</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ans = dp[n];</span><br><span class="line">        <span class="keyword">delete</span> []dp;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>背包</tag>
      </tags>
  </entry>
  <entry>
    <title>199.二叉树的右视图</title>
    <url>/binary-tree-right-side-view/</url>
    <content><![CDATA[<h2 id="1-层次遍历"><a href="#1-层次遍历" class="headerlink" title="1. 层次遍历"></a>1. 层次遍历</h2><p>层次遍历，只保留最右侧的那个值。<br>时间复杂度<code>O(n)</code>，空间复杂度<code>O(n)</code>。  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">rightSideView</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        q.push(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> n = q.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                TreeNode* temp = q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                <span class="keyword">if</span> (temp-&gt;left != <span class="literal">nullptr</span>)</span><br><span class="line">                    q.push(temp-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (temp-&gt;right != <span class="literal">nullptr</span>)</span><br><span class="line">                    q.push(temp-&gt;right);</span><br><span class="line">                <span class="keyword">if</span> (i == n - <span class="number">1</span>)</span><br><span class="line">                    ans.push_back(temp-&gt;val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2-DFS"><a href="#2-DFS" class="headerlink" title="2. DFS"></a>2. DFS</h2><p>按照“根右左”的顺序访问节点，则优先访问到的就是最右侧的节点。<br>这种方法需要记录高度，当某个高度第一次被访问到的时候，储存遇到的第一个节点的值。<br>时间<code>O(n)</code>，空间<code>O(n)</code>。  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; ans, TreeNode* root, <span class="keyword">int</span> height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (ans.size() == height)</span><br><span class="line">            ans.push_back(root-&gt;val);</span><br><span class="line">        dfs(ans, root-&gt;right, height + <span class="number">1</span>);</span><br><span class="line">        dfs(ans, root-&gt;left, height + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">rightSideView</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        dfs(ans, root, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>dfs</tag>
      </tags>
  </entry>
  <entry>
    <title>1248.统计「优美子数组」</title>
    <url>/count-number-of-nice-subarrays/</url>
    <content><![CDATA[<h2 id="1-滑动窗口"><a href="#1-滑动窗口" class="headerlink" title="1. 滑动窗口"></a>1. 滑动窗口</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numberOfSubarrays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">if</span> (n &lt; k)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> oddcount = nums[<span class="number">0</span>] % <span class="number">2</span> == <span class="number">1</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> leftcount = <span class="number">0</span>, rightcount = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (oddcount == k) &#123;</span><br><span class="line">                <span class="keyword">while</span> (right &lt; n - <span class="number">1</span> &amp;&amp; nums[right + <span class="number">1</span>] % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                    right++;</span><br><span class="line">                    rightcount++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">while</span> (left &lt;= right &amp;&amp; left &lt; n - <span class="number">1</span> &amp;&amp; nums[left] % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                    left++;</span><br><span class="line">                    leftcount++;</span><br><span class="line">                &#125;</span><br><span class="line">                ans += (leftcount + <span class="number">1</span>) * (rightcount + <span class="number">1</span>);</span><br><span class="line">                leftcount = <span class="number">0</span>;</span><br><span class="line">                rightcount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (right &lt; n - <span class="number">1</span>) &#123;</span><br><span class="line">                    right++;</span><br><span class="line">                    oddcount++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (left &lt;= right &amp;&amp; left &lt; n - <span class="number">1</span>) &#123;</span><br><span class="line">                    left++;</span><br><span class="line">                    oddcount--;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (left == n - <span class="number">1</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (oddcount &lt; k &amp;&amp; right &lt; n - <span class="number">1</span>) &#123;</span><br><span class="line">                right++;</span><br><span class="line">                <span class="keyword">if</span> (nums[right] % <span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">                    oddcount++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (oddcount &lt; k &amp;&amp; right &gt;= n - <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>滑动窗口</tag>
      </tags>
  </entry>
  <entry>
    <title>200.岛屿数量</title>
    <url>/number-of-islands/</url>
    <content><![CDATA[<h2 id="1-BFS"><a href="#1-BFS" class="headerlink" title="1. BFS"></a>1. BFS</h2><p>遍历与BFS。时间复杂度<code>O(mn)</code>，空间复杂度<code>O(mn)</code>(visited数组)。  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = grid.size();</span><br><span class="line">        <span class="keyword">if</span> (m == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> n = grid[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            </span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; &gt; <span class="title">visited</span><span class="params">(m, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(n, <span class="literal">false</span>))</span></span>;</span><br><span class="line">        <span class="keyword">int</span> mvi[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> mvj[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; q;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!visited[i][j] &amp;&amp; grid[i][j] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                    q.push(<span class="built_in">make_pair</span>(i, j));</span><br><span class="line">                    visited[i][j] = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">                        <span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; loc = q.front();</span><br><span class="line">                        q.pop();</span><br><span class="line">                        <span class="keyword">int</span> loci = loc.first, locj = loc.second;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; k++) &#123;</span><br><span class="line">                            <span class="keyword">int</span> curi = loci + mvi[k], curj = locj + mvj[k];</span><br><span class="line">                            <span class="keyword">if</span> (curi &gt;= <span class="number">0</span> &amp;&amp; curi &lt; m &amp;&amp; curj &gt;= <span class="number">0</span> &amp;&amp; curj &lt; n &amp;&amp; grid[curi][curj] == <span class="string">&#x27;1&#x27;</span> &amp;&amp; !visited[curi][curj]) &#123;</span><br><span class="line">                                q.push(<span class="built_in">make_pair</span>(curi, curj));</span><br><span class="line">                                visited[curi][curj] = <span class="literal">true</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    ans++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>bfs</tag>
      </tags>
  </entry>
  <entry>
    <title>11.Container With Most Water</title>
    <url>/container-with-most-water/</url>
    <content><![CDATA[<h2 id="1-双指针"><a href="#1-双指针" class="headerlink" title="1. 双指针"></a>1. 双指针</h2><p>两个指针初始时在左右两侧，逐渐向内靠拢。<br>每次两个指针形成的容器，最小的那个是瓶颈，接下来需要向内移动瓶颈或非瓶颈的指针。<br>如果保持瓶颈指针不动，向内移动非瓶颈指针，由于宽度减小，并且无论非瓶颈指针向内移动后得到的边界是大是小，容器的总容积总是减小（一定受瓶颈指针的影响）<br>因此需要向内移动瓶颈指针，这样才可能遇到更大的容积。<br>时间复杂度<code>O(n)</code>，空间复杂度<code>O(1)</code>.  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = height.size();</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = (right - left) * min(height[left], height[right]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">if</span> (height[left] &lt; height[right])</span><br><span class="line">                left++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (height[left] == height[right]) &#123;</span><br><span class="line">                left++;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                right--;</span><br><span class="line">            ans = max(ans, (right - left) * min(height[left], height[right]));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>56.合并区间</title>
    <url>/merge-intervals/</url>
    <content><![CDATA[<h2 id="1-按左区间由小到大排序"><a href="#1-按左区间由小到大排序" class="headerlink" title="1. 按左区间由小到大排序"></a>1. 按左区间由小到大排序</h2><p>时间复杂度需要排序<code>O(nlogn)</code>，空间复杂度存答案<code>O(n)</code>。 </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// static bool cmp(const vector&lt;int&gt;&amp; a, const vector&lt;int&gt;&amp; b) &#123;</span></span><br><span class="line">    <span class="comment">//     if (a[0] &lt; b[0])</span></span><br><span class="line">    <span class="comment">//         return true;</span></span><br><span class="line">    <span class="comment">//     else</span></span><br><span class="line">    <span class="comment">//         return false;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">merge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; intervals)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = intervals.size();</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> intervals;</span><br><span class="line">        <span class="comment">// sort(intervals.begin(), intervals.end(), cmp);</span></span><br><span class="line">        sort(intervals.begin(), intervals.end());   <span class="comment">// vector有比较操作符</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; ans;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">cur</span><span class="params">(intervals[<span class="number">0</span>])</span></span>;</span><br><span class="line">        <span class="keyword">int</span> left = cur[<span class="number">0</span>], right = cur[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (intervals[i][<span class="number">0</span>] &lt;= right)</span><br><span class="line">                right = right &gt;= intervals[i][<span class="number">1</span>] ? right : intervals[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                ans.push_back(&#123;left, right&#125;);</span><br><span class="line">                left = intervals[i][<span class="number">0</span>];</span><br><span class="line">                right = intervals[i][<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans.push_back(&#123;left, right&#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>542. 01矩阵</title>
    <url>/01-matrix/</url>
    <content><![CDATA[<h2 id="1-超级源点-BFS"><a href="#1-超级源点-BFS" class="headerlink" title="1. 超级源点+BFS"></a>1. 超级源点+BFS</h2><p>建一个超级源点0，BFS计算从0到1的距离。<br>时间复杂度<code>O(mn)</code>，空间复杂度<code>O(mn)</code>。  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">updateMatrix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = matrix.size(), n = matrix[<span class="number">0</span>].size();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dis</span><span class="params">(m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n, <span class="number">0</span>))</span></span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; <span class="title">visited</span><span class="params">(m, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(n, <span class="literal">false</span>))</span></span>;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; q;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                    q.push(<span class="built_in">make_pair</span>(i, j));</span><br><span class="line">                    visited[i][j] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> mi[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> mj[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            <span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; loc = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; k++) &#123;</span><br><span class="line">                <span class="keyword">int</span> i = loc.first + mi[k], j = loc.second + mj[k];</span><br><span class="line">                <span class="keyword">if</span> (i &gt;= <span class="number">0</span> &amp;&amp; i &lt; m &amp;&amp; j &gt;= <span class="number">0</span> &amp;&amp; j &lt; n &amp;&amp; !visited[i][j]) &#123;</span><br><span class="line">                    dis[i][j] = dis[loc.first][loc.second] + <span class="number">1</span>;</span><br><span class="line">                    q.push(<span class="built_in">make_pair</span>(i, j));</span><br><span class="line">                    visited[i][j] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dis;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2-dp"><a href="#2-dp" class="headerlink" title="2. dp"></a>2. dp</h2><p><code>dp[i][j]</code>代表<code>matrix[i][j]</code>到最近的0的距离。<br>转移方程（仅针对1）为，遍历上下左右四个位置(ni, nj)：<br>dp[i][j] = min(dp[i][j], dp[ni][nj] + 1), 当matrix[ni][nj] == 1时；<br>dp[i][j] = 1, 当matrix[ni][nj] == 0时。  </p>
<p>由于遍历的是上下左右四个位置，而dp[i][j]的计算是逐行逐列进行的，所以左、上的dp[ni][nj]已经计算得到了，而右、下的dp[ni][nj]还没有计算。<br>可以选择更新两次，第一次只依赖左上部分元素转移，第二次只依赖右下部份元素转移。  </p>
<p>时间复杂度<code>O(mn)</code>，空间复杂度<code>O(mn)</code>。  </p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>bfs</tag>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>887.Super Egg Drop</title>
    <url>/super-egg-drop/</url>
    <content><![CDATA[<h2 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">superEggDrop</span><span class="params">(<span class="keyword">int</span> K, <span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1-动态规划-二分"><a href="#1-动态规划-二分" class="headerlink" title="1. 动态规划+二分"></a>1. 动态规划+二分</h2><p>设计<code>dp[i][j]</code>代表i层楼j个蛋，最少需要多少次一定能测出分界楼层。<br>想象在任意楼层，扔下一个鸡蛋，可能有碎和不碎两种结果。碎则说明分界楼层在下部分，不碎则说明在上部分。<br>由于我们不知道分界楼层到底在哪里，而是要求<code>dp[i][j]</code>次一定能找出该楼层，所以得到状态转移方程：  </p>
<p><code>dp[i][j] = min_x(max(dp[x-1][j-1], dp[i-x][j])) + 1</code><br>i层楼j个蛋能够测出分界楼层需要的最少次数 = 遍历中间任意一层楼x在此处扔鸡蛋找一个最小值（max(在x楼扔碎了去下半部分再找需要的次数, 在x楼扔没碎去上半部分再找需要的次数)）+1  </p>
<p><em>为什么取上部分和下部分的最大值？</em><br>因为不知道具体是碎没碎，所以需要一个最大值保证不管是碎不碎都可以找到分界楼层。<br><em>为什么遍历所有楼层x，在x楼扔鸡蛋？</em><br>因为不知道分界楼层在哪，还要得到一定能测出分界楼层的最小次数，那就遍历x在x楼扔，找一个得到的次数最小的x楼。  </p>
<p>时间复杂度<code>O(kn^2)</code>，k个蛋，n层楼。空间复杂度<code>O(kn)</code>。<br>以上时间复杂度对这个题目是超时的，所以需要优化。  </p>
<p>考虑在找x楼的时候，是遍历当前的所有楼层，得到一个<code>min_x(max(dp[x-1][j-1], dp[i-x][j]))</code>。<br>随着x的增大，<code>dp[x-1][j-1]</code>增大（楼层多了），<code>dp[i-x][j]</code>减小（楼层少了）。<br>根据下图，要得到的<code>min_x(...)</code>即当<code>dp[x-1][j-1] == dp[i-x][j]</code>相等时的值。<br><img src="min_max.png" alt="draft"><br>直接找<code>dp[x-1][j-1] == dp[i-x][j]</code>的<code>x</code>是不方便的，所以可以找使得<code>dp[x-1][j-1] &lt;= dp[i-x][j]</code>成立的最大值<code>x</code>，这里就可以二分了。  </p>
<p>由于将原本<code>O(n)</code>的遍历楼层的过程改为了二分，所以时间复杂度降低为<code>O(knlogn)</code>。  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">superEggDrop</span><span class="params">(<span class="keyword">int</span> K, <span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>** dp = <span class="keyword">new</span> <span class="keyword">int</span>* [N + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= N; i++)</span><br><span class="line">            dp[i] = <span class="keyword">new</span> <span class="keyword">int</span>[K + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= N; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= K; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span> || j == <span class="number">0</span>)   <span class="comment">// 0层楼或0个蛋</span></span><br><span class="line">                    dp[i][j] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">1</span>)        <span class="comment">// 1层楼试一下</span></span><br><span class="line">                    dp[i][j] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span>                    <span class="comment">// 最多试i下</span></span><br><span class="line">                    dp[i][j] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= K; j++) &#123;</span><br><span class="line">                <span class="keyword">int</span> left = <span class="number">1</span>, right = i;</span><br><span class="line">                <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">                    <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">                    <span class="keyword">if</span> (dp[mid - <span class="number">1</span>][j - <span class="number">1</span>] &lt;= dp[i - mid][j]) &#123;</span><br><span class="line">                        dp[i][j] = min(dp[i][j], dp[i - mid][j] + <span class="number">1</span>);</span><br><span class="line">                        left = mid + <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        dp[i][j] = min(dp[i][j], dp[mid - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">                        right = mid - <span class="number">1</span>;</span><br><span class="line">                    &#125; </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ans = dp[N][K];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= N; i++)</span><br><span class="line">            <span class="keyword">delete</span> []dp[i];</span><br><span class="line">        <span class="keyword">delete</span> []dp;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title>445. 两数相加II</title>
    <url>/add-two-numbers-ii/</url>
    <content><![CDATA[<h2 id="1-利用栈使链表逆序"><a href="#1-利用栈使链表逆序" class="headerlink" title="1. 利用栈使链表逆序"></a>1. 利用栈使链表逆序</h2><p>这道题可以是把链表逆序，变成低位到高位，也可以通过栈存储每一个节点，从而通过后入先出将链表逆序。<br>对于逆序处理的问题，可以优先考虑栈。  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; v1, v2;</span><br><span class="line">        <span class="keyword">while</span> (l1 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            v1.push(l1-&gt;val);</span><br><span class="line">            l1 = l1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (l2 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            v2.push(l2-&gt;val);</span><br><span class="line">            l2 = l2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode* ans = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">int</span> c = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!v1.empty() || !v2.empty() || c != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (!v1.empty()) &#123;</span><br><span class="line">                a = v1.top();</span><br><span class="line">                v1.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!v2.empty()) &#123;</span><br><span class="line">                b = v2.top();</span><br><span class="line">                v2.pop();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> d = a + b + c;</span><br><span class="line">            ListNode* new_node = <span class="keyword">new</span> ListNode(d % <span class="number">10</span>);</span><br><span class="line">            c = d / <span class="number">10</span>;</span><br><span class="line">            new_node-&gt;next = ans;</span><br><span class="line">            ans = new_node;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>355. 设计推特</title>
    <url>/design-twitter/</url>
    <content><![CDATA[<h2 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Twitter</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    Twitter() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Compose a new tweet. */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">postTweet</span><span class="params">(<span class="keyword">int</span> userId, <span class="keyword">int</span> tweetId)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Retrieve the 10 most recent tweet ids in the user&#x27;s news feed. Each item in the news feed must be posted by users who the user followed or by the user herself. Tweets must be ordered from most recent to least recent. */</span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">getNewsFeed</span><span class="params">(<span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Follower follows a followee. If the operation is invalid, it should be a no-op. */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">follow</span><span class="params">(<span class="keyword">int</span> followerId, <span class="keyword">int</span> followeeId)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Follower unfollows a followee. If the operation is invalid, it should be a no-op. */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unfollow</span><span class="params">(<span class="keyword">int</span> followerId, <span class="keyword">int</span> followeeId)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your Twitter object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * Twitter* obj = new Twitter();</span></span><br><span class="line"><span class="comment"> * obj-&gt;postTweet(userId,tweetId);</span></span><br><span class="line"><span class="comment"> * vector&lt;int&gt; param_2 = obj-&gt;getNewsFeed(userId);</span></span><br><span class="line"><span class="comment"> * obj-&gt;follow(followerId,followeeId);</span></span><br><span class="line"><span class="comment"> * obj-&gt;unfollow(followerId,followeeId);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h2 id="1-模拟"><a href="#1-模拟" class="headerlink" title="1. 模拟"></a>1. 模拟</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tweet</span> &#123;</span></span><br><span class="line">    tweet(<span class="keyword">int</span> i = <span class="number">0</span>, <span class="keyword">int</span> t = <span class="number">0</span>) &#123; id = i; time = t; &#125;</span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">int</span> time;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">user</span> &#123;</span></span><br><span class="line">    <span class="comment">// int id;</span></span><br><span class="line">    <span class="built_in">list</span>&lt;tweet&gt; tweets;</span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; following;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Twitter</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    Twitter() &#123;</span><br><span class="line">        user_table.clear();</span><br><span class="line">        cur_time = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Compose a new tweet. */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">postTweet</span><span class="params">(<span class="keyword">int</span> userId, <span class="keyword">int</span> tweetId)</span> </span>&#123;</span><br><span class="line">        user_table[userId].tweets.push_front(tweet(tweetId, cur_time++));</span><br><span class="line">        <span class="keyword">if</span> (user_table[userId].tweets.size() &gt; <span class="number">10</span>)</span><br><span class="line">            user_table[userId].tweets.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Retrieve the 10 most recent tweet ids in the user&#x27;s news feed. Each item in the news feed must be posted by users who the user followed or by the user herself. Tweets must be ordered from most recent to least recent. */</span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">getNewsFeed</span><span class="params">(<span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;tweet&gt; <span class="title">temp_ans</span><span class="params">(user_table[userId].tweets.begin(), user_table[userId].tweets.end())</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator iter = user_table[userId].following.begin(); iter != user_table[userId].following.end(); ++iter) &#123;</span><br><span class="line">            <span class="keyword">if</span> (*iter == userId)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="built_in">vector</span>&lt;tweet&gt; <span class="title">temp</span><span class="params">(temp_ans)</span></span>;</span><br><span class="line">            temp_ans.clear();</span><br><span class="line">            <span class="built_in">vector</span>&lt;tweet&gt;::iterator temp_it = temp.begin();</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">list</span>&lt;tweet&gt;::iterator jter = user_table[*iter].tweets.begin(); jter != user_table[*iter].tweets.end(); ++jter) &#123;</span><br><span class="line">                <span class="keyword">if</span> (temp_it != temp.end()) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (temp_it-&gt;time &lt; jter-&gt;time) &#123;</span><br><span class="line">                        temp_ans.push_back(*jter);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        temp_ans.push_back(*temp_it);</span><br><span class="line">                        ++temp_it;</span><br><span class="line">                        --jter;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    temp_ans.push_back(*jter);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (temp_ans.size() == <span class="number">10</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (temp_it != temp.end()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (temp_ans.size() == <span class="number">10</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                temp_ans.push_back(*temp_it);</span><br><span class="line">                ++temp_it;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">vector</span>&lt;tweet&gt;::iterator it = temp_ans.begin(); it != temp_ans.end(); ++it)</span><br><span class="line">            ans.push_back(it-&gt;id);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Follower follows a followee. If the operation is invalid, it should be a no-op. */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">follow</span><span class="params">(<span class="keyword">int</span> followerId, <span class="keyword">int</span> followeeId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator it = user_table[followerId].following.begin(); it != user_table[followerId].following.end(); ++it)</span><br><span class="line">            <span class="keyword">if</span> (*it == followeeId)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">        user_table[followerId].following.push_back(followeeId);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Follower unfollows a followee. If the operation is invalid, it should be a no-op. */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unfollow</span><span class="params">(<span class="keyword">int</span> followerId, <span class="keyword">int</span> followeeId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator it = user_table[followerId].following.begin(); it != user_table[followerId].following.end(); ++it)</span><br><span class="line">            <span class="keyword">if</span> (*it == followeeId) &#123;</span><br><span class="line">                user_table[followerId].following.erase(it);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, user&gt; user_table;</span><br><span class="line">    <span class="keyword">int</span> cur_time;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your Twitter object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * Twitter* obj = new Twitter();</span></span><br><span class="line"><span class="comment"> * obj-&gt;postTweet(userId,tweetId);</span></span><br><span class="line"><span class="comment"> * vector&lt;int&gt; param_2 = obj-&gt;getNewsFeed(userId);</span></span><br><span class="line"><span class="comment"> * obj-&gt;follow(followerId,followeeId);</span></span><br><span class="line"><span class="comment"> * obj-&gt;unfollow(followerId,followeeId);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>151.Reverse Words in a String</title>
    <url>/reverse-words-in-a-string/</url>
    <content><![CDATA[<h2 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">reverseWords</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1-借助额外空间"><a href="#1-借助额外空间" class="headerlink" title="1. 借助额外空间"></a>1. 借助额外空间</h2><p>主要学会string的<code>find_first(last)_of()</code>函数和<code>find_first(last)_not_of()</code>函数的使用。<br>分别是找到第一个（最后一个）参数的位置和找到第一个（最后一个）不是参数的位置。<br>而<code>find()</code>和<code>find_first_of()</code>的区别是：<br><code>s.find(&quot;abc&quot;)</code>必须找到<code>s</code>中子串<code>abc</code>的位置，而<code>s.find_first_of(&quot;abc&quot;)</code>只需要找到<code>s</code>中a或b或c中任意一个字符的第一个位置。<br><code>s.substr(起始位置, 截取长度（默认到结尾）)</code><br><code>s.erase(迭代器开始, 迭代器结束（不含）（默认到结尾）)</code><br><code>s.erase(起始位置, 删除长度（默认到结尾）)</code>  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">reverseWords</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        s.erase(<span class="number">0</span>, s.find_first_not_of(<span class="string">&#x27; &#x27;</span>));   <span class="comment">// 删除左侧空格</span></span><br><span class="line">        s.erase(s.find_last_not_of(<span class="string">&#x27; &#x27;</span>) + <span class="number">1</span>);   <span class="comment">// 删除右侧空格</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">string</span> rev = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">while</span> (!s.empty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> loc = s.find_last_of(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">            rev += s.substr(loc + <span class="number">1</span>) + <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (loc != <span class="number">-1</span>) &#123;</span><br><span class="line">                s = s.substr(<span class="number">0</span>, loc);</span><br><span class="line">                <span class="keyword">int</span> space_loc = s.find_last_not_of(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">                <span class="keyword">if</span> (space_loc == <span class="number">-1</span>)</span><br><span class="line">                    s = <span class="string">&quot;&quot;</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    s = s.substr(<span class="number">0</span>, space_loc + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                s = <span class="string">&quot;&quot;</span>;</span><br><span class="line">                rev.erase(rev.length() - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> rev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2-原地重排"><a href="#2-原地重排" class="headerlink" title="2. 原地重排"></a>2. 原地重排</h2><p>先把字符串整体反转，然后把字符串中每个单词反转。  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">reverseWords</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        s.erase(<span class="number">0</span>, s.find_first_not_of(<span class="string">&#x27; &#x27;</span>));</span><br><span class="line">        s.erase(s.find_last_not_of(<span class="string">&#x27; &#x27;</span>) + <span class="number">1</span>);</span><br><span class="line">        reverse(s.begin(), s.end());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> cur = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!s.empty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> loc = s.find_first_of(<span class="string">&#x27; &#x27;</span>, cur);</span><br><span class="line">            <span class="keyword">if</span> (loc == <span class="number">-1</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> len = s.length();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= (len - <span class="number">1</span> - cur) / <span class="number">2</span>; i++)</span><br><span class="line">                    swap(s[cur + i], s[len - <span class="number">1</span> - i]);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= (loc - <span class="number">1</span> - cur) / <span class="number">2</span>; i++) </span><br><span class="line">                swap(s[cur + i], s[loc - <span class="number">1</span> - i]);</span><br><span class="line">            cur = loc + <span class="number">1</span>;</span><br><span class="line">            s = s.erase(cur, s.find_first_not_of(<span class="string">&#x27; &#x27;</span>, cur) - cur);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>322.Coin Change</title>
    <url>/coin-change/</url>
    <content><![CDATA[<h2 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1-完全背包"><a href="#1-完全背包" class="headerlink" title="1. 完全背包"></a>1. 完全背包</h2><p>背包容量：<code>amount</code><br>物品价值：<code>coins</code><br>物品体积：<code>coins</code><br>恰好达到价值<code>amount</code><br><code>dp[i][j]</code>原本记录前i种物品装入容量为j的背包能达到的最大价值。但是此处由于容量就代表了价值，所以<code>dp[i][j]</code>此处可以记录前i种金额装入容量为j的背包（达到j的价值）需要的最少的钱的张数。  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxVal = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">        <span class="keyword">int</span> n = coins.size();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(amount + <span class="number">1</span>, maxVal)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = coins[i]; j &lt;= amount; j++) &#123;</span><br><span class="line">                dp[j] = min(dp[j], dp[j - coins[i]] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (dp[amount] &gt;= maxVal)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>背包</tag>
      </tags>
  </entry>
  <entry>
    <title>22.Generate Parentheses</title>
    <url>/generate-parentheses/</url>
    <content><![CDATA[<h2 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1-递归"><a href="#1-递归" class="headerlink" title="1. 递归"></a>1. 递归</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">recursion</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> total, <span class="keyword">int</span> cur)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (total == n) &#123;</span><br><span class="line">            <span class="keyword">while</span> (cur &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                s += <span class="string">&#x27;)&#x27;</span>;</span><br><span class="line">                cur--;</span><br><span class="line">            &#125;</span><br><span class="line">            vec.push_back(s);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        recursion(vec, s + <span class="string">&#x27;(&#x27;</span>, total + <span class="number">1</span>, cur + <span class="number">1</span>, n);</span><br><span class="line">        <span class="keyword">if</span> (cur &gt; <span class="number">0</span>)</span><br><span class="line">            recursion(vec, s + <span class="string">&#x27;)&#x27;</span>, total, cur - <span class="number">1</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        vec.clear();</span><br><span class="line">        <span class="keyword">this</span>-&gt;n = n;</span><br><span class="line"></span><br><span class="line">        recursion(ans, <span class="string">&quot;(&quot;</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; vec;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>面试题13. 机器人的运动范围</title>
    <url>/ji-qi-ren-de-yun-dong-fan-wei-lcof/</url>
    <content><![CDATA[<h2 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">movingCount</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1-BFS"><a href="#1-BFS" class="headerlink" title="1. BFS"></a>1. BFS</h2><p>BFS到相邻节点，判断要求是否超过k。<br>时间<code>O(mn)</code>，空间由于需要一个网格记录是否访问过，也是<code>O(mn)</code>.  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">movingCount</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> id[<span class="number">2</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> jd[<span class="number">2</span>] = &#123;<span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; <span class="title">visited</span><span class="params">(m, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(n, <span class="literal">false</span>))</span></span>;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">        q.push(<span class="built_in">make_pair</span>(<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">        visited[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            <span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; cur = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="keyword">int</span> i = cur.first, j = cur.second;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> mv = <span class="number">0</span>; mv &lt; <span class="number">2</span>; mv++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i + id[mv] &lt; m &amp;&amp; j + jd[mv] &lt; n &amp;&amp; !visited[i + id[mv]][j + jd[mv]]) &#123;</span><br><span class="line">                    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">int</span> loci = i + id[mv], locj = j + jd[mv];</span><br><span class="line">                    <span class="keyword">while</span> (loci &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        sum += loci % <span class="number">10</span>;</span><br><span class="line">                        loci /= <span class="number">10</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">while</span> (locj &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        sum += locj % <span class="number">10</span>;</span><br><span class="line">                        locj /= <span class="number">10</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (sum &lt;= k) &#123;</span><br><span class="line">                        q.push(<span class="built_in">make_pair</span>(i + id[mv], j + jd[mv]));</span><br><span class="line">                        ans++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    visited[i + id[mv]][j + jd[mv]] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title>42.接雨水</title>
    <url>/trapping-rain-water/</url>
    <content><![CDATA[<h2 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1-按列计算-dp"><a href="#1-按列计算-dp" class="headerlink" title="1. 按列计算+dp"></a>1. 按列计算+dp</h2><p>首先想到的是计算出一个“坑”，然后算这个坑可以储存多少水。<br>但实际上也可以按列计算，计算每一列可以储存多少水，然后求和。<br>算每一列存水的数量的方法就是找到该位置左侧的最大值和右侧的最大值，从而围成一个“坑”。<br>所以：遍历每一个柱子，然后查找其左侧的最大值和右侧的最大值，时间复杂度是<code>O(n^2)</code>。<br>可以使用记忆化搜索，<code>leftIndex[i]</code>和<code>rightIndex[i]</code>分别记录第i个元素左侧的最大高度的索引和右侧最大高度的索引。<br>转移方程为<code>leftIndex[i] = i-1 || leftHeight[i-1]</code><br>这样，时间复杂度就降低为<code>O(n)</code>，而空间复杂度升高为<code>O(n)</code>。  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = height.size();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        vector&lt;int&gt; leftIndex(n, 0), rightIndex(n, n - 1);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            leftIndex[i] = height[leftIndex[i - <span class="number">1</span>]] &gt;= height[i - <span class="number">1</span>] ? leftIndex[i - <span class="number">1</span>] : i - <span class="number">1</span>;</span><br><span class="line">            rightIndex[n - i - <span class="number">1</span>] = height[rightIndex[n - i]] &gt;= height[n - i] ? rightIndex[n - i] : n - i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> minHeight = min(height[leftIndex[i]], height[rightIndex[i]]);</span><br><span class="line">            <span class="keyword">if</span> (minHeight &gt; height[i])</span><br><span class="line">                ans += minHeight - height[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2-单调栈"><a href="#2-单调栈" class="headerlink" title="2. 单调栈"></a>2. 单调栈</h2><p>要形成一个坑，则高度要先降低后升高。<br>之前的想法是先降低后升高，再降低的时候说明右边界已经达到了，取左右边界的最小值，重新遍历中间的部分，进行积水。然后以右边界为新的左边界，继续上述操作。<br>然而这样的问题是，坑可能是<code>W</code>型的，中间有较低的突起，却以它为边界了，这样积水操作就算错了。  </p>
<p><strong>为什么使用单调栈？</strong><br>上述操作的弊端是，只能够根据升高后再降低确定到一个右边界，却无法对应地处理这个右边界高度可以积累的雨水。<br>如果使用一个容器，记录下从左边界到右边界的柱子高度值，则可以只弹出右侧部分柱子，与当前右边界组合进行积水，而后续遇到更高的右边界可能继续弹出并积水。<br>如果容器种记录的是<code>3,5</code>，则这个<code>3</code>是无效的，因为和左边界组合积水，5比3大，所以不可能取3了。<br>因此这里就可以选用<em>单调递减栈</em>。  </p>
<p>当遇到的元素&lt;=栈顶元素时，入栈，保持栈的非递增性。<br>当遇到的元素&gt;栈顶元素时，出栈，计算出栈的元素和右侧当前元素组成的坑可以储存的水。重复操作直到栈顶元素&lt;=当前元素。<br>为了便于获取宽度，栈中储存的是索引。  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = height.size();</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; index;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (index.empty())</span><br><span class="line">                index.push(i);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (height[i] &lt;= height[index.top()])</span><br><span class="line">                    index.push(i);</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">while</span> (height[i] &gt; height[index.top()]) &#123;</span><br><span class="line">                        <span class="keyword">int</span> left = index.top();</span><br><span class="line">                        index.pop();</span><br><span class="line">                        <span class="keyword">if</span> (index.empty())</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        ans += (min(height[index.top()], height[i]) - height[left]) * (i - index.top() - <span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    index.push(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>面试题 01.07. Rotate Matrix LCCI</title>
    <url>/rotate-matrix-lcci/</url>
    <content><![CDATA[<h2 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1-先转置后对称"><a href="#1-先转置后对称" class="headerlink" title="1. 先转置后对称"></a>1. 先转置后对称</h2><p><img src="draft.png" alt="draft">  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = matrix.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++)</span><br><span class="line">                swap(matrix[i][j], matrix[j][i]);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= (n - <span class="number">1</span>) / <span class="number">2</span>; j++)</span><br><span class="line">                swap(matrix[i][j], matrix[i][n - <span class="number">1</span> - j]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>72.Edit Distance</title>
    <url>/edit-distance/</url>
    <content><![CDATA[<h2 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(<span class="built_in">string</span> word1, <span class="built_in">string</span> word2)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1-dp"><a href="#1-dp" class="headerlink" title="1. dp"></a>1. dp</h2><p><del>设<code>dp[i][j]</code>代表`word1[0</del>i]与word2[0<del>j]`部分需要的最少的操作数。</del><br>设<code>dp[i][j]</code>代表<code>word1</code>的前i个字符和<code>word2</code>的前j个字符部分需要的最少操作数。（这样要简单得多）<br>状态转移方程为：<br><code>dp[i][j] = dp[i - 1][j - 1]</code>, 当<code>word1[i - 1] == word2[j - 1]</code>时。<br><code>dp[i][j] = min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]) + 1</code>, 当<code>word1[i - 1] != word2[j - 1]</code>时。<br>上述情况需要由三种状态转移而来，分别是：修改，删除word1[i-1]，添加word2[j-1]。  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(<span class="built_in">string</span> word1, <span class="built_in">string</span> word2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n1 = word1.length(), n2 = word2.length();</span><br><span class="line">        <span class="keyword">if</span> (n1 == <span class="number">0</span> || n2 == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> n1 + n2;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> **dp = <span class="keyword">new</span> <span class="keyword">int</span>*[n1 + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n1 + <span class="number">1</span>; i++)</span><br><span class="line">            dp[i] = <span class="keyword">new</span> <span class="keyword">int</span>[n2 + <span class="number">1</span>]&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n1; i++)</span><br><span class="line">            dp[i][<span class="number">0</span>] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n2; i++)</span><br><span class="line">            dp[<span class="number">0</span>][i] = i;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n1; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n2; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (word1[i - <span class="number">1</span>] == word2[j - <span class="number">1</span>])</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">int</span> temp = min(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">                    dp[i][j] = min(temp, dp[i - <span class="number">1</span>][j - <span class="number">1</span>]) + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ans = dp[n1][n2];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n1 + <span class="number">1</span>; i++)</span><br><span class="line">            <span class="keyword">delete</span> []dp[i];</span><br><span class="line">        <span class="keyword">delete</span> []dp;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>460.LFU Cache</title>
    <url>/lfu-cache/</url>
    <content><![CDATA[<h2 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LFUCache</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    LFUCache(<span class="keyword">int</span> capacity) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your LFUCache object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * LFUCache* obj = new LFUCache(capacity);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;get(key);</span></span><br><span class="line"><span class="comment"> * obj-&gt;put(key,value);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h2 id="1-模拟"><a href="#1-模拟" class="headerlink" title="1. 模拟"></a>1. 模拟</h2><p><img src="draft.png" alt="draft">  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    node (<span class="keyword">int</span> k = <span class="number">0</span>, <span class="keyword">int</span> v = <span class="number">0</span>, <span class="keyword">int</span> f = <span class="number">0</span>) &#123;</span><br><span class="line">        key = k;</span><br><span class="line">        value = v;</span><br><span class="line">        freq = f;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> key;</span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    <span class="keyword">int</span> freq;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LFUCache</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    LFUCache(<span class="keyword">int</span> capacity) &#123;</span><br><span class="line">        key_table.clear();</span><br><span class="line">        freq_table.clear();</span><br><span class="line">        <span class="keyword">this</span>-&gt;capacity = capacity;</span><br><span class="line">        minFreq = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (key_table.count(key) == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> val = key_table[key]-&gt;value, freq = ++(key_table[key]-&gt;freq);</span><br><span class="line">        freq_table[freq].push_front(*(key_table[key]));</span><br><span class="line">        freq_table[freq - <span class="number">1</span>].erase(key_table[key]);</span><br><span class="line">        <span class="keyword">if</span> (freq_table[freq - <span class="number">1</span>].empty()) &#123;</span><br><span class="line">            <span class="comment">// freq_table.erase(freq - 1);</span></span><br><span class="line">            <span class="keyword">if</span> (minFreq == freq - <span class="number">1</span>)</span><br><span class="line">                minFreq = freq;</span><br><span class="line">        &#125;</span><br><span class="line">        key_table[key] = freq_table[freq].begin();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (capacity == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (key_table.count(key) == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (get(key) != value)</span><br><span class="line">                key_table[key]-&gt;value = value;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (key_table.size() == capacity) &#123;</span><br><span class="line">                key_table.erase(freq_table[minFreq].back().key);</span><br><span class="line">                freq_table[minFreq].pop_back();</span><br><span class="line">                <span class="comment">// if (freq_table[minFreq].empty())</span></span><br><span class="line">                    <span class="comment">// freq_table.erase(minFreq);</span></span><br><span class="line">            &#125;</span><br><span class="line">            freq_table[<span class="number">1</span>].push_front(node(key, value, <span class="number">1</span>));</span><br><span class="line">            key_table[key] = freq_table[<span class="number">1</span>].begin();</span><br><span class="line">            minFreq = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="built_in">list</span>&lt;node&gt;::iterator&gt; key_table;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="built_in">list</span>&lt;node&gt; &gt; freq_table;</span><br><span class="line">    <span class="keyword">int</span> minFreq;</span><br><span class="line">    <span class="keyword">int</span> capacity;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your LFUCache object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * LFUCache* obj = new LFUCache(capacity);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;get(key);</span></span><br><span class="line"><span class="comment"> * obj-&gt;put(key,value);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>8.字符串转换整数 (atoi)</title>
    <url>/string-to-integer-atoi/</url>
    <content><![CDATA[<h2 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">myAtoi</span><span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1-直接模拟"><a href="#1-直接模拟" class="headerlink" title="1. 直接模拟"></a>1. 直接模拟</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">myAtoi</span><span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = str.length();</span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//判断是否溢出的时候可以比较int ans和INT_MAX / 10的关系，这样就不会ans * 10溢出了。</span></span><br><span class="line">        <span class="keyword">bool</span> hasNumber = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (str[i] != <span class="string">&#x27; &#x27;</span> &amp;&amp; str[i] != <span class="string">&#x27;+&#x27;</span> &amp;&amp; str[i] != <span class="string">&#x27;-&#x27;</span> &amp;&amp; !(str[i] &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; str[i] &lt;= <span class="string">&#x27;9&#x27;</span>) &amp;&amp; !hasNumber)    <span class="comment">//数字前有其他字符</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!(str[i] &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; str[i] &lt;= <span class="string">&#x27;9&#x27;</span>) &amp;&amp; hasNumber)    <span class="comment">//数字后有其他字符</span></span><br><span class="line">                <span class="keyword">return</span> flag * ans;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (str[i] == <span class="string">&#x27;-&#x27;</span> || str[i] == <span class="string">&#x27;+&#x27;</span>) &#123;   <span class="comment">//数字符号</span></span><br><span class="line">                <span class="keyword">if</span> (i + <span class="number">1</span> &lt; n &amp;&amp; (str[i + <span class="number">1</span>] &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; str[i + <span class="number">1</span>] &lt;= <span class="string">&#x27;9&#x27;</span>)) &#123;</span><br><span class="line">                    hasNumber = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">if</span> (str[i] == <span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">                        flag = <span class="number">-1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (str[i] &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; str[i] &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;      <span class="comment">//是数字</span></span><br><span class="line">                hasNumber = <span class="literal">true</span>;</span><br><span class="line">                ans = ans * <span class="number">10</span> + (str[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">                <span class="keyword">if</span> (flag == <span class="number">1</span> &amp;&amp; ans &gt;= <span class="built_in">pow</span>(<span class="number">2</span>, <span class="number">31</span>) - <span class="number">1</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="built_in">pow</span>(<span class="number">2</span>, <span class="number">31</span>) - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (flag == <span class="number">-1</span> &amp;&amp; ans &gt;= <span class="built_in">pow</span>(<span class="number">2</span>, <span class="number">31</span>))</span><br><span class="line">                    <span class="keyword">return</span> -<span class="built_in">pow</span>(<span class="number">2</span>, <span class="number">31</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> flag * ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2-自动机"><a href="#2-自动机" class="headerlink" title="2. 自动机"></a>2. 自动机</h2><p>我看到这个题解直接傻了，太nb了。<br>没想到自动机还可以用来解题啊……<br><a href="https://leetcode-cn.com/problems/string-to-integer-atoi/solution/zi-fu-chuan-zhuan-huan-zheng-shu-atoi-by-leetcode-/">https://leetcode-cn.com/problems/string-to-integer-atoi/solution/zi-fu-chuan-zhuan-huan-zheng-shu-atoi-by-leetcode-/</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>289.Game of Life</title>
    <url>/game-of-life/</url>
    <content><![CDATA[<h2 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">gameOfLife</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1-额外空间直接遍历"><a href="#1-额外空间直接遍历" class="headerlink" title="1. 额外空间直接遍历"></a>1. 额外空间直接遍历</h2><p>时间<code>O(mn)</code>，空间<code>O(mn)</code>。  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">gameOfLife</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">ans</span><span class="params">(board)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> m = board.size(), n = board[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">int</span> dx[<span class="number">8</span>] = &#123;<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> dy[<span class="number">8</span>] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">int</span> live = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">8</span>; k++) &#123;</span><br><span class="line">                    <span class="keyword">int</span> x = i + dx[k], y = j + dy[k];</span><br><span class="line">                    <span class="keyword">if</span> (x &gt;= <span class="number">0</span> &amp;&amp; x &lt; m &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; n &amp;&amp; board[x][y] == <span class="number">1</span>)</span><br><span class="line">                        live++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (live &lt; <span class="number">2</span>)</span><br><span class="line">                        ans[i][j] = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (live == <span class="number">2</span> || live == <span class="number">3</span>)</span><br><span class="line">                        ans[i][j] = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (live &gt; <span class="number">3</span>)</span><br><span class="line">                        ans[i][j] = <span class="number">0</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (board[i][j] == <span class="number">0</span> &amp;&amp; live == <span class="number">3</span>)</span><br><span class="line">                    ans[i][j] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        board = ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2-Follow-up"><a href="#2-Follow-up" class="headerlink" title="2. Follow up"></a>2. Follow up</h2><h4 id="1-Could-you-solve-it-in-place"><a href="#1-Could-you-solve-it-in-place" class="headerlink" title="1. Could you solve it in-place?"></a>1. Could you solve it in-place?</h4><p>由于要求同时修改，直接每次顺序遍历时修改<code>board[i][j]</code>会导致非同时修改，因为<code>board[i][j]</code>依赖的<code>board[i-1][j-1],board[i-1][j],board[i-1][j+1],board[i][j-1]</code>已经被修改了。<br>就算是改成逆序遍历，<code>board[i][j]</code>右下角部分的元素也会提前修改了。<br>既然不能通过调整遍历的顺序实现原地修改，那么考虑设置新的变量，储存额外的信息。<br>可以想到，题目中的数据取值为01，而数据类型为<code>int</code>，因此我们可以考虑<code>board[i][j]</code>同时存储修改前和修改后的值。<br>因此对状态重新编码，<code>xy</code>代表修改之后状态是<code>x</code>，之前状态是<code>y</code>。<br><em>本来是打算<code>x</code>代表修改之前的状态，<code>y</code>代表修改之后的状态，但这样每次要取之前的状态还要判断一下是取倒数第二位还是取最后一位，所以还是改为以上的编码方式。</em><br>由于<code>01, 00</code>是无法用int直接表示为十位数据的，因此可以考虑位运算，左侧高位为修改后状态，右侧低位为之前状态。  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">gameOfLife</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = board.size(), n = board[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">int</span> dx[<span class="number">8</span>] = &#123;<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> dy[<span class="number">8</span>] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">int</span> live = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">8</span>; k++) &#123;</span><br><span class="line">                    <span class="keyword">int</span> x = i + dx[k], y = j + dy[k];</span><br><span class="line">                    <span class="keyword">if</span> (x &gt;= <span class="number">0</span> &amp;&amp; x &lt; m &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; n &amp;&amp; board[x][y] &amp; <span class="number">1</span>)</span><br><span class="line">                        live++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] &amp; <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (live == <span class="number">2</span> || live == <span class="number">3</span>) </span><br><span class="line">                        board[i][j] |= <span class="number">2</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (live == <span class="number">3</span>)</span><br><span class="line">                        board[i][j] |= <span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">                board[i][j] &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="2-In-this-question-we-represent-the-board-using-a-2D-array-In-principle-the-board-is-infinite-which-would-cause-problems-when-the-active-area-encroaches-the-border-of-the-array-How-would-you-address-these-problems"><a href="#2-In-this-question-we-represent-the-board-using-a-2D-array-In-principle-the-board-is-infinite-which-would-cause-problems-when-the-active-area-encroaches-the-border-of-the-array-How-would-you-address-these-problems" class="headerlink" title="2. In this question, we represent the board using a 2D array. In principle, the board is infinite, which would cause problems when the active area encroaches the border of the array. How would you address these problems?"></a>2. In this question, we represent the board using a 2D array. In principle, the board is infinite, which would cause problems when the active area encroaches the border of the array. How would you address these problems?</h4><p>数据总归是存在外存上的，如果不能一下全读到内存中，那么可以分块读入，通过上述编码的方式进行处理，同时保存之前和之后的状态，重新存储到外存上。  </p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>1111. 有效括号的嵌套深度</title>
    <url>/maximum-nesting-depth-of-two-valid-parentheses-strings/</url>
    <content><![CDATA[<h2 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">maxDepthAfterSplit</span><span class="params">(<span class="built_in">string</span> seq)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1-直接模拟"><a href="#1-直接模拟" class="headerlink" title="1. 直接模拟"></a>1. 直接模拟</h2><p>首先遍历一遍获得最大深度<code>maxDepth</code>，若想令<code>max(depth(A), depth(B))</code>的可能取值最小，则结果必为<code>(maxDepth+1)/2</code>。<br>因此再次遍历序列，将深度小于最大深度一半的括号都分到A类中，之后的括号除去与A左括号匹配的右括号之外，其余全部放入B类中。<br>时间复杂度<code>O(n)</code>。  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">maxDepthAfterSplit</span><span class="params">(<span class="built_in">string</span> seq)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = seq.length();</span><br><span class="line">        <span class="keyword">int</span> maxDepth = <span class="number">0</span>, curDepth = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (seq[i] == <span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">                curDepth++;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                maxDepth = maxDepth &gt;= curDepth ? maxDepth : curDepth;</span><br><span class="line">                curDepth--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> halfDepth = (maxDepth + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">ans</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (seq[i] == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                curDepth++;</span><br><span class="line">                <span class="keyword">if</span> (curDepth &lt;= halfDepth)</span><br><span class="line">                    ans[i] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">else</span> </span><br><span class="line">                    ans[i] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (curDepth &lt;= halfDepth)</span><br><span class="line">                    ans[i] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    ans[i] = <span class="number">1</span>;</span><br><span class="line">                curDepth--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>面试题62. 圆圈中最后剩下的数字</title>
    <url>/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/</url>
    <content><![CDATA[<h2 id="约瑟夫环"><a href="#约瑟夫环" class="headerlink" title="约瑟夫环"></a>约瑟夫环</h2><ol>
<li>n个人编号0,1,2,…,n-1，每数m次删掉一个人  </li>
<li>假设有函数f(n)表示n个人最终剩下人的编号  </li>
<li>n个人删掉1个人后可以看做n-1的状态，不过有自己的编号。  </li>
<li>n个人删掉的第一个人的编号是(m-1)%n，那么n个人时删掉第一个人的后面那个人(m-1+1)%n一定是n-1个人时候编号为0的那个人，即n个人时的编号m%n（这个编号是对于n个人来考虑的）。  </li>
<li>n-1个人时编号为i的人就是n个人时(m+i)%n  </li>
<li>所以f(n)=(m+f(n-1))%n  </li>
<li>f(1)=0，因为1个人时只有一个编号0。  </li>
<li>从人数为1个时逆推即可。  </li>
</ol>
<p>作者：fu-sang-shu-xie<br>链接：<a href="https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/solution/li-jie-gui-lu-hen-jian-dan-javascriptjie-fa-by-fu-/">https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/solution/li-jie-gui-lu-hen-jian-dan-javascriptjie-fa-by-fu-/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<hr>
<p><img src="draft.png" alt="draft">  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lastRemaining</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">            ans = (ans + m) % (i + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>面试题59 - II. 队列的最大值</title>
    <url>/dui-lie-de-zui-da-zhi-lcof/</url>
    <content><![CDATA[<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">listNode</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    listNode() &#123;val = <span class="number">0</span>; next = <span class="literal">NULL</span>;&#125;</span><br><span class="line">    listNode(<span class="keyword">int</span> v) &#123;val = v; next = <span class="literal">NULL</span>;&#125;</span><br><span class="line">    listNode(<span class="keyword">int</span> v, listNode *n) &#123;val = v; next = n;&#125;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    listNode *next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MaxQueue</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    MaxQueue() &#123;</span><br><span class="line">        head = <span class="literal">NULL</span>;</span><br><span class="line">        tail = <span class="literal">NULL</span>;</span><br><span class="line">        maxVal = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">max_value</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (maxVal == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> maxVal-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        listNode *newNode = <span class="keyword">new</span> listNode(value, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            head = newNode;</span><br><span class="line">            tail = newNode;</span><br><span class="line">            maxVal = newNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            tail-&gt;next = newNode;</span><br><span class="line">            tail = newNode;</span><br><span class="line">            <span class="keyword">if</span> (value &gt;= maxVal-&gt;val)</span><br><span class="line">                maxVal = newNode;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pop_front</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> res;</span><br><span class="line">            <span class="keyword">if</span> (head == tail) &#123;</span><br><span class="line">                res = head-&gt;val;</span><br><span class="line">                <span class="keyword">delete</span> head;</span><br><span class="line">                head = <span class="literal">NULL</span>;</span><br><span class="line">                tail = <span class="literal">NULL</span>;</span><br><span class="line">                maxVal = <span class="literal">NULL</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                listNode *temp = head-&gt;next;</span><br><span class="line">                res = head-&gt;val;</span><br><span class="line">                <span class="keyword">if</span> (head == maxVal) &#123;</span><br><span class="line">                    maxVal = head-&gt;next;</span><br><span class="line">                    listNode *p = maxVal-&gt;next;</span><br><span class="line">                    <span class="keyword">while</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (p-&gt;val &gt;= maxVal-&gt;val)</span><br><span class="line">                            maxVal = p;</span><br><span class="line">                        p = p-&gt;next;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">delete</span> head;</span><br><span class="line">                head = temp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    listNode *head;</span><br><span class="line">    listNode *tail;</span><br><span class="line">    listNode *maxVal;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MaxQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MaxQueue* obj = new MaxQueue();</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;max_value();</span></span><br><span class="line"><span class="comment"> * obj-&gt;push_back(value);</span></span><br><span class="line"><span class="comment"> * int param_3 = obj-&gt;pop_front();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>1162. As Far from Land as Possible</title>
    <url>/as-far-from-land-as-possible/</url>
    <content><![CDATA[<h2 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDistance</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1-朴素"><a href="#1-朴素" class="headerlink" title="1. 朴素"></a>1. 朴素</h2><p>统计每个0和1的位置，储存到vector中，对每个0直接求到所有1的曼哈顿距离的最小值。<br>时间<code>O(n^2logn)</code>，空间<code>O(n)</code>.<br><em>超时了</em>  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDistance</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = grid.size();</span><br><span class="line">        <span class="keyword">bool</span> hasZero = <span class="literal">false</span>, hasOne = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (hasZero &amp;&amp; hasOne)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="number">0</span> &amp;&amp; !hasZero)</span><br><span class="line">                    hasZero = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span> &amp;&amp; !hasOne)</span><br><span class="line">                    hasOne = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!hasZero || !hasOne)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; zeros;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; ones;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="number">0</span>)</span><br><span class="line">                    zeros.push_back(<span class="built_in">make_pair</span>(i, j));</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    ones.push_back(<span class="built_in">make_pair</span>(i, j));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; zeros.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> curAns = <span class="number">2</span> * n;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; ones.size(); j++) &#123;</span><br><span class="line">                <span class="keyword">int</span> dis = <span class="built_in">abs</span>(zeros[i].first - ones[j].first) + <span class="built_in">abs</span>(zeros[i].second - ones[j].second);</span><br><span class="line">                curAns = curAns &lt;= dis ? curAns : dis;</span><br><span class="line">                <span class="keyword">if</span> (curAns == <span class="number">1</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = ans &gt;= curAns ? ans : curAns;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2-超级源点-BFS"><a href="#2-超级源点-BFS" class="headerlink" title="2. 超级源点+BFS"></a>2. 超级源点+BFS</h2><p>题目要求找每块海洋0到最近陆地1的距离最大，可以反过来找每块陆地1到所有海洋0的距离。<br>通过超级源点可以把所有陆地都加到queue中，每次把每层的所有陆地1取出来向外扩展一圈。<br>当海洋0被第一次访问时，得到的一定是该块海洋到最近陆地1的距离，之后的再次访问都不会对结果造成影响。<br>可以新建一个grid记录每个海洋到最近陆地的距离，不过更省空间的方法是：每轮向外扩展是将该层的所有节点都向外扩展一次，这样只需要一个distance记录当前扩展的宽度就可以了。<br>时间复杂度因为要访问到所有的节点，因此是<code>O(n^2)</code>，空间由于需要queue暂存节点，最坏也是<code>O(n^2)</code>。  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDistance</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = grid.size();</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; q;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) </span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>) </span><br><span class="line">                    q.push(<span class="built_in">make_pair</span>(i, j));</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">if</span> (q.size() == <span class="number">0</span> || q.size() == n * n)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> distance = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> di[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> dj[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            distance++;</span><br><span class="line">            <span class="keyword">int</span> qsize = q.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; qsize; k++) &#123;</span><br><span class="line">                <span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; cur = q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> mv = <span class="number">0</span>; mv &lt; <span class="number">4</span>; mv++) &#123;</span><br><span class="line">                    <span class="keyword">int</span> i = cur.first + di[mv];</span><br><span class="line">                    <span class="keyword">int</span> j = cur.second + dj[mv];</span><br><span class="line">                    <span class="keyword">if</span> (i &gt;= <span class="number">0</span> &amp;&amp; i &lt; n &amp;&amp; j &gt;= <span class="number">0</span> &amp;&amp; j &lt; n &amp;&amp; grid[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                        q.push(<span class="built_in">make_pair</span>(i, j));</span><br><span class="line">                        grid[i][j] = <span class="number">-1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> distance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>bfs</tag>
      </tags>
  </entry>
  <entry>
    <title>820.Short Encoding of Words</title>
    <url>/short-encoding-of-words/</url>
    <content><![CDATA[<p>Given a list of words, we may encode it by writing a reference string S and a list of indexes A.</p>
<p>For example, if the list of words is [“time”, “me”, “bell”], we can write it as S = “time#bell#” and indexes = [0, 2, 5].</p>
<p>Then for each index, we will recover the word by reading from the reference string from that index until we reach a “#” character.</p>
<p>What is the length of the shortest reference string S possible that encodes the given words?</p>
<p>Example:</p>
<p>Input: words = [“time”, “me”, “bell”]<br>Output: 10<br>Explanation: S = “time#bell#” and indexes = [0, 2, 5].</p>
<p>Note:</p>
<p>1 &lt;= words.length &lt;= 2000.<br>1 &lt;= words[i].length &lt;= 7.<br>Each word has only lowercase letters.</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/short-encoding-of-words">https://leetcode-cn.com/problems/short-encoding-of-words</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<hr>
<h2 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minimumLengthEncoding</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1-朴素"><a href="#1-朴素" class="headerlink" title="1. 朴素"></a>1. 朴素</h2><p>分析可知，如果A和B能够被简化表示，则A或B一定是完全地是对方的结尾部分。<br>即time和me，而不能是time和mesh。所以可以从它们的结尾逆序进行比较。<br>遍历每两个单词，从结尾比较看能否完全被包含。<br>时间<code>O(n^2 * wordLen)</code>，空间记录一下是不是已经被包含了，<code>O(n)</code><br><em>超时了</em>  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minimumLengthEncoding</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = words.size();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">contained</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">encoded</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            contained[i] = <span class="literal">false</span>;</span><br><span class="line">            encoded[i] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (contained[i])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i != j &amp;&amp; !contained[j]) &#123;</span><br><span class="line">                    <span class="keyword">int</span> ilen = words[i].length(), jlen = words[j].length();</span><br><span class="line">                    <span class="keyword">if</span> (jlen &gt; ilen)</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    </span><br><span class="line">                    <span class="keyword">bool</span> isContained = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">while</span> (jlen &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (words[i][--ilen] != words[j][--jlen]) &#123;</span><br><span class="line">                            isContained = <span class="literal">false</span>;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                   </span><br><span class="line">                    <span class="keyword">if</span> (isContained) &#123;</span><br><span class="line">                        contained[j] = <span class="literal">true</span>;</span><br><span class="line">                        <span class="keyword">if</span> (encoded[i] &amp;&amp; encoded[j])</span><br><span class="line">                            ans--;</span><br><span class="line">                        <span class="keyword">if</span> (!encoded[i] &amp;&amp; !encoded[j]) &#123;</span><br><span class="line">                            encoded[i] = <span class="literal">true</span>;</span><br><span class="line">                            ans++;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (encoded[i] &amp;&amp; !contained[i])</span><br><span class="line">                ans += words[i].length();</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!encoded[i] &amp;&amp; !contained[i])</span><br><span class="line">                ans += words[i].length() + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2-排序"><a href="#2-排序" class="headerlink" title="2. 排序"></a>2. 排序</h2><p>如果把每个字符串都反转，再从小到大排序，就可以发现如果二者是包含关系的话，则二者一定相邻并且左侧的被右侧的包含。<br>不过以下代码不反转字符串，而是重新写sort的compare函数。<br>时间<code>O(nlogn)</code>，空间<code>O(1)</code>.  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//这里需要用static，因为非静态成员函数的参数中会隐含地让this指针作为第一个参数</span></span><br><span class="line">    <span class="comment">//而sort的compare函数的参数要求是两个参数，所以加static避免它隐含加上第一个参数this。</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">cmp</span> <span class="params">(<span class="built_in">string</span>&amp; a, <span class="built_in">string</span>&amp; b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> aLen = a.length(), bLen = b.length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= min(aLen, bLen); i++) </span><br><span class="line">            <span class="keyword">if</span> (a[aLen - i] != b[bLen - i])</span><br><span class="line">                <span class="keyword">return</span> a[aLen - i] &lt; b[bLen - i];</span><br><span class="line">        <span class="keyword">return</span> aLen &lt;= bLen;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minimumLengthEncoding</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = words.size();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        sort (words.begin(), words.end(), cmp);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> iLen = words[i].length(), jLen = words[i + <span class="number">1</span>].length();</span><br><span class="line">            <span class="keyword">if</span> (iLen &gt; jLen) &#123;</span><br><span class="line">                ans += iLen + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= iLen; k++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (words[i][iLen - k] != words[i + <span class="number">1</span>][jLen - k]) &#123;</span><br><span class="line">                    ans += iLen + <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans += words[n - <span class="number">1</span>].length() + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="3-字典树Trie"><a href="#3-字典树Trie" class="headerlink" title="3. 字典树Trie"></a>3. 字典树Trie</h2><p>为了方便管理子节点，字典树（如果是全小写字母）会开一个26的数组记录子节点。<br>可以有两个方法统计长度：  </p>
<ol>
<li>用hash表记录每个单词的结尾在Trie中的位置和在数组中位置的映射关系，当该Trie结点没有子节点时可以根据映射关系获取该单词的长度，加到结果中。  </li>
<li>插入的时候先插长的，这样如果后续插入中需要开辟新的结点，则说明该单词是新的而不是后缀，直接加上它的长度。不过这种方法需要先根据单词长度由长到短进行排序。  </li>
</ol>
<p><a href="https://leetcode-cn.com/problems/short-encoding-of-words/solution/99-java-trie-tu-xie-gong-lue-bao-jiao-bao-hui-by-s/">https://leetcode-cn.com/problems/short-encoding-of-words/solution/99-java-trie-tu-xie-gong-lue-bao-jiao-bao-hui-by-s/</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>914.X of a Kind in a Deck of Cards</title>
    <url>/x-of-a-kind-in-a-deck-of-cards/</url>
    <content><![CDATA[<p>In a deck of cards, each card has an integer written on it.</p>
<p>Return true if and only if you can choose X &gt;= 2 such that it is possible to split the entire deck into 1 or more groups of cards, where:</p>
<p>Each group has exactly X cards.<br>All the cards in each group have the same integer.</p>
<p>Example 1:</p>
<p>Input: deck = [1,2,3,4,4,3,2,1]<br>Output: true<br>Explanation: Possible partition [1,1],[2,2],[3,3],[4,4].<br>Example 2:</p>
<p>Input: deck = [1,1,1,2,2,2,3,3]<br>Output: false´<br>Explanation: No possible partition.<br>Example 3:</p>
<p>Input: deck = [1]<br>Output: false<br>Explanation: No possible partition.<br>Example 4:</p>
<p>Input: deck = [1,1]<br>Output: true<br>Explanation: Possible partition [1,1].<br>Example 5:</p>
<p>Input: deck = [1,1,2,2,2,2]<br>Output: true<br>Explanation: Possible partition [1,1],[2,2],[2,2].</p>
<p>Constraints:</p>
<p>1 &lt;= deck.length &lt;= 10^4<br>0 &lt;= deck[i] &lt; 10^4</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/x-of-a-kind-in-a-deck-of-cards">https://leetcode-cn.com/problems/x-of-a-kind-in-a-deck-of-cards</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<hr>
<h2 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasGroupsSizeX</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; deck)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1-hash表-最大公约数"><a href="#1-hash表-最大公约数" class="headerlink" title="1. hash表+最大公约数"></a>1. hash表+最大公约数</h2><p>首先hash表统计每个值出现的次数，排除特殊情况，然后求最大公约数判断是否&gt;=2.<br>时间<code>O(nlogC)</code>(C是数据范围。应该是，因为求gcd是对数级别的复杂度)，空间<code>O(n)</code>.  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (a &lt; b) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = a;</span><br><span class="line">            a = b;</span><br><span class="line">            b = temp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (b != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = b;</span><br><span class="line">            b = a % b;</span><br><span class="line">            a = temp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasGroupsSizeX</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; deck)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; counter;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; deck.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (counter.count(deck[i]) == <span class="number">0</span>)</span><br><span class="line">                counter[deck[i]] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                counter[deck[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (counter.size() == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::iterator iter = counter.begin();</span><br><span class="line">            <span class="keyword">if</span> (iter-&gt;second == <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::iterator iter = counter.begin();</span><br><span class="line">        <span class="keyword">int</span> ans = gcd(iter-&gt;second, (++iter)-&gt;second);</span><br><span class="line">        <span class="keyword">while</span> (iter != counter.end()) &#123;</span><br><span class="line">            ans = gcd(ans, iter-&gt;second);</span><br><span class="line">            <span class="keyword">if</span> (ans == <span class="number">1</span>)   <span class="comment">//剪枝</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            ++iter;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans != <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>999. Available Captures for Rook</title>
    <url>/available-captures-for-rook/</url>
    <content><![CDATA[<p>On an 8 x 8 chessboard, there is one white rook.  There also may be empty squares, white bishops, and black pawns.  These are given as characters ‘R’, ‘.’, ‘B’, and ‘p’ respectively. Uppercase characters represent white pieces, and lowercase characters represent black pieces.</p>
<p>The rook moves as in the rules of Chess: it chooses one of four cardinal directions (north, east, west, and south), then moves in that direction until it chooses to stop, reaches the edge of the board, or captures an opposite colored pawn by moving to the same square it occupies.  Also, rooks cannot move into the same square as other friendly bishops.</p>
<p>Return the number of pawns the rook can capture in one move.</p>
<p> </p>
<p>Example 1:</p>
<p>Input: [[“.”,”.”,”.”,”.”,”.”,”.”,”.”,”.”],[“.”,”.”,”.”,”p”,”.”,”.”,”.”,”.”],[“.”,”.”,”.”,”R”,”.”,”.”,”.”,”p”],[“.”,”.”,”.”,”.”,”.”,”.”,”.”,”.”],[“.”,”.”,”.”,”.”,”.”,”.”,”.”,”.”],[“.”,”.”,”.”,”p”,”.”,”.”,”.”,”.”],[“.”,”.”,”.”,”.”,”.”,”.”,”.”,”.”],[“.”,”.”,”.”,”.”,”.”,”.”,”.”,”.”]]<br>Output: 3<br>Explanation:<br>In this example the rook is able to capture all the pawns.<br>Example 2:</p>
<p>Input: [[“.”,”.”,”.”,”.”,”.”,”.”,”.”,”.”],[“.”,”p”,”p”,”p”,”p”,”p”,”.”,”.”],[“.”,”p”,”p”,”B”,”p”,”p”,”.”,”.”],[“.”,”p”,”B”,”R”,”B”,”p”,”.”,”.”],[“.”,”p”,”p”,”B”,”p”,”p”,”.”,”.”],[“.”,”p”,”p”,”p”,”p”,”p”,”.”,”.”],[“.”,”.”,”.”,”.”,”.”,”.”,”.”,”.”],[“.”,”.”,”.”,”.”,”.”,”.”,”.”,”.”]]<br>Output: 0<br>Explanation:<br>Bishops are blocking the rook to capture any pawn.<br>Example 3:</p>
<p>Input: [[“.”,”.”,”.”,”.”,”.”,”.”,”.”,”.”],[“.”,”.”,”.”,”p”,”.”,”.”,”.”,”.”],[“.”,”.”,”.”,”p”,”.”,”.”,”.”,”.”],[“p”,”p”,”.”,”R”,”.”,”p”,”B”,”.”],[“.”,”.”,”.”,”.”,”.”,”.”,”.”,”.”],[“.”,”.”,”.”,”B”,”.”,”.”,”.”,”.”],[“.”,”.”,”.”,”p”,”.”,”.”,”.”,”.”],[“.”,”.”,”.”,”.”,”.”,”.”,”.”,”.”]]<br>Output: 3<br>Explanation:<br>The rook can capture the pawns at positions b5, d6 and f5.</p>
<p>Note:</p>
<p>board.length == board[i].length == 8<br>board[i][j] is either ‘R’, ‘.’, ‘B’, or ‘p’<br>There is exactly one cell with board[i][j] == ‘R’</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/available-captures-for-rook">https://leetcode-cn.com/problems/available-captures-for-rook</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<hr>
<h2 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numRookCaptures</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1-直接模拟"><a href="#1-直接模拟" class="headerlink" title="1. 直接模拟"></a>1. 直接模拟</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numRookCaptures</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> rooki, rookj;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">8</span>; j++)</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] == <span class="string">&#x27;R&#x27;</span>) &#123;</span><br><span class="line">                    rooki = i;</span><br><span class="line">                    rookj = j;</span><br><span class="line">                &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> movi[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> movj[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; k++) &#123;</span><br><span class="line">            <span class="keyword">int</span> curi = rooki, curj = rookj;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                curi += movi[k];</span><br><span class="line">                curj += movj[k];</span><br><span class="line">                <span class="keyword">if</span> (curi &lt; <span class="number">0</span> || curi &gt;= <span class="number">8</span> || curj &lt; <span class="number">0</span> || curj &gt;= <span class="number">8</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (board[curi][curj] == <span class="string">&#x27;B&#x27;</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (board[curi][curj] == <span class="string">&#x27;p&#x27;</span>) &#123;</span><br><span class="line">                    ans++;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>892.Surface Area of 3D Shapes</title>
    <url>/surface-area-of-3d-shapes/</url>
    <content><![CDATA[<p>On a N * N grid, we place some 1 * 1 * 1 cubes.</p>
<p>Each value v = grid[i][j] represents a tower of v cubes placed on top of grid cell (i, j).</p>
<p>Return the total surface area of the resulting shapes.</p>
<p> </p>
<p>Example 1:</p>
<p>Input: [[2]]<br>Output: 10<br>Example 2:</p>
<p>Input: [[1,2],[3,4]]<br>Output: 34<br>Example 3:</p>
<p>Input: [[1,0],[0,2]]<br>Output: 16<br>Example 4:</p>
<p>Input: [[1,1,1],[1,0,1],[1,1,1]]<br>Output: 32<br>Example 5:</p>
<p>Input: [[2,2,2],[2,1,2],[2,2,2]]<br>Output: 46</p>
<p>Note:</p>
<p>1 &lt;= N &lt;= 50<br>0 &lt;= grid[i][j] &lt;= 50</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/surface-area-of-3d-shapes">https://leetcode-cn.com/problems/surface-area-of-3d-shapes</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<hr>
<h2 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">surfaceArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1-遍历前后左右四个位置"><a href="#1-遍历前后左右四个位置" class="headerlink" title="1. 遍历前后左右四个位置"></a>1. 遍历前后左右四个位置</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">surfaceArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = grid.size();</span><br><span class="line">        <span class="keyword">int</span> movi[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> movj[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                </span><br><span class="line">                ans += <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; k++) &#123;</span><br><span class="line">                    <span class="keyword">int</span> curi = i + movi[k];</span><br><span class="line">                    <span class="keyword">int</span> curj = j + movj[k];</span><br><span class="line">                    <span class="keyword">if</span> (curi &lt; <span class="number">0</span> || curi &gt;= n || curj &lt; <span class="number">0</span> || curj &gt;= n)</span><br><span class="line">                        ans += grid[i][j];</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (grid[i][j] &gt; grid[curi][curj])</span><br><span class="line">                            ans += grid[i][j] - grid[curi][curj];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>面试题 17.16. 按摩师</title>
    <url>/the-masseuse-lcci/</url>
    <content><![CDATA[<p>A popular masseuse receives a sequence of back-to-back appointment requests and is debating which ones to accept. She needs a break between appointments and therefore she cannot accept any adjacent requests. Given a sequence of back-to-back appoint­ ment requests, find the optimal (highest total booked minutes) set the masseuse can honor. Return the number of minutes.</p>
<p>Note: This problem is slightly different from the original one in the book.</p>
<p> </p>
<p>Example 1:</p>
<p>Input:  [1,2,3,1]<br>Output:  4<br>Explanation:  Accept request 1 and 3, total minutes = 1 + 3 = 4<br>Example 2:</p>
<p>Input:  [2,7,9,3,1]<br>Output:  12<br>Explanation:  Accept request 1, 3 and 5, total minutes = 2 + 9 + 1 = 12<br>Example 3:</p>
<p>Input:  [2,1,4,5,3,1,1,3]<br>Output:  12<br>Explanation:  Accept request 1, 3, 5 and 8, total minutes = 2 + 4 + 3 + 3 = 12</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/the-masseuse-lcci">https://leetcode-cn.com/problems/the-masseuse-lcci</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<hr>
<h2 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">massage</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1-动态规划"><a href="#1-动态规划" class="headerlink" title="1. 动态规划"></a>1. 动态规划</h2><p>设<code>dp[i]</code>代表从头到<code>nums[i]</code>服务的最大值，则<code>dp[i] = max(dp[i-1], dp[i-2]+nums[i])</code>.<br>初始化<code>dp[0] = nums[0]; dp[1] = max(dp[0], dp[1])</code>.<br>遍历一次后<code>dp[nums.size()-1]</code>即为结果，时间<code>O(n)</code>，空间<code>O(n)</code>。  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">massage</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.size();</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (len == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> *dp = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = max(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; len; i++)</span><br><span class="line">            dp[i] = max(dp[i - <span class="number">1</span>], dp[i - <span class="number">2</span>] + nums[i]);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> ans = dp[len - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">delete</span> []dp;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>实际上，由于<code>dp[i]</code>只依赖于<code>dp[i-1]</code>与<code>dp[i-2]</code>，因此可以将数组换成变量，空间降为<code>O(1)</code>。  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">massage</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.size();</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> bbefore = <span class="number">0</span>, before = <span class="number">0</span>, cur = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            cur = max(bbefore + nums[i], before);</span><br><span class="line">            bbefore = before;</span><br><span class="line">            before = cur;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> before;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>面试题57 - II. 和为s的连续正数序列</title>
    <url>/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof/</url>
    <content><![CDATA[<p>输入一个正整数 target ，输出所有和为 target 的连续正整数序列（至少含有两个数）。</p>
<p>序列内的数字由小到大排列，不同序列按照首个数字从小到大排列。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：target = 9<br>输出：[[2,3,4],[4,5]]<br>示例 2：</p>
<p>输入：target = 15<br>输出：[[1,2,3,4,5],[4,5,6],[7,8]]</p>
<p>限制：</p>
<p>1 &lt;= target &lt;= 10^5</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof">https://leetcode-cn.com/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<hr>
<h2 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">findContinuousSequence</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1-双指针"><a href="#1-双指针" class="headerlink" title="1. 双指针"></a>1. 双指针</h2><p>小了r++，大了l++</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">findContinuousSequence</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">1</span>, right = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; ans;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sum &lt; target) &#123;</span><br><span class="line">                right++;</span><br><span class="line">                sum += right;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &gt; target) &#123;</span><br><span class="line">                sum -= left;</span><br><span class="line">                left++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; group;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = left; i &lt;= right; i++)</span><br><span class="line">                    group.push_back(i);</span><br><span class="line">                ans.push_back(group);</span><br><span class="line">                left++;</span><br><span class="line">                right++;</span><br><span class="line">                sum = sum - left + right + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (left &gt; target / <span class="number">2</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>876.Middle of the Linked List</title>
    <url>/middle-of-the-linked-list/</url>
    <content><![CDATA[<p>Given a non-empty, singly linked list with head node head, return a middle node of linked list.</p>
<p>If there are two middle nodes, return the second middle node.</p>
<p> </p>
<p>Example 1:</p>
<p>Input: [1,2,3,4,5]<br>Output: Node 3 from this list (Serialization: [3,4,5])<br>The returned node has value 3.  (The judge’s serialization of this node is [3,4,5]).<br>Note that we returned a ListNode object ans, such that:<br>ans.val = 3, ans.next.val = 4, ans.next.next.val = 5, and ans.next.next.next = NULL.<br>Example 2:</p>
<p>Input: [1,2,3,4,5,6]<br>Output: Node 4 from this list (Serialization: [4,5,6])<br>Since the list has two middle nodes with values 3 and 4, we return the second one.</p>
<p>Note:</p>
<p>The number of nodes in the given list will be between 1 and 100.</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/middle-of-the-linked-list">https://leetcode-cn.com/problems/middle-of-the-linked-list</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<hr>
<h2 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">middleNode</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1-遍历"><a href="#1-遍历" class="headerlink" title="1. 遍历"></a>1. 遍历</h2><p>先遍历一次获取长度，然后遍历到中间位置。时间<code>O(n)</code>，空间<code>O(1)</code>。  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">middleNode</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        ListNode *ans = head;</span><br><span class="line">        <span class="keyword">while</span> (ans != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            len++;</span><br><span class="line">            ans = ans-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ans = head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len / <span class="number">2</span>; i++)</span><br><span class="line">            ans = ans-&gt;next;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2-快慢指针"><a href="#2-快慢指针" class="headerlink" title="2. 快慢指针"></a>2. 快慢指针</h2><p>新学的。快慢指针还可以用来判断一个链表中是否有环（根据快慢指针能否相遇来判断）<br>快指针走2步，慢指针走1步，这样的话慢指针停止的时候指向的就是链表中点。时间<code>O(n)</code>，空间<code>O(1)</code>。  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">middleNode</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode *fast = head, *slow = head;</span><br><span class="line">        <span class="comment">//星花还是跟变量呆在一起吧，表示*fast是ListNode类型。连续定义指针的话*得在变量上。</span></span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="literal">NULL</span> &amp;&amp; fast-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>365.Water and Jug Problem</title>
    <url>/water-and-jug-problem/</url>
    <content><![CDATA[<p>You are given two jugs with capacities x and y litres. There is an infinite amount of water supply available. You need to determine whether it is possible to measure exactly z litres using these two jugs.</p>
<p>If z liters of water is measurable, you must have z liters of water contained within one or both buckets by the end.</p>
<p>Operations allowed:</p>
<p>Fill any of the jugs completely with water.<br>Empty any of the jugs.<br>Pour water from one jug into another till the other jug is completely full or the first jug itself is empty.<br>Example 1: (From the famous “Die Hard” example)</p>
<p>Input: x = 3, y = 5, z = 4<br>Output: True<br>Example 2:</p>
<p>Input: x = 2, y = 6, z = 5<br>Output: False</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/water-and-jug-problem">https://leetcode-cn.com/problems/water-and-jug-problem</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<hr>
<h2 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canMeasureWater</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1-数学方法"><a href="#1-数学方法" class="headerlink" title="1. 数学方法"></a>1. 数学方法</h2><p>已知：  </p>
<ul>
<li>不可能两个桶中都有水且不满。  </li>
<li>灌入水只能对空桶做。  </li>
<li>倒出水只能对满桶做。  </li>
</ul>
<p><strong>因此，水的总量每次变化是<code>+-x</code>或<code>+-y</code></strong><br>所以，可得出方程<code>ax+by=z</code>，并要求<code>a, b</code>是整数解。  </p>
<p><strong>根据贝祖定理，<code>ax+by=z</code>有整数解<code>a, b</code>的条件是：<code>z</code>是<code>x</code>和<code>y</code>的最大公约数gcd的倍数。</strong><br>求gcd可以用：  </p>
<ol>
<li>辗转相除法<br>$$<br>gcd(a, 0) = a\<br>gcd(a, b) = gcd(b, a mod b)<br>$$</li>
<li>更相减损法<br>$$<br>gcd(a, a) = a\<br>gcd(a, b) = gcd(a, b - a), if b &gt; a\<br>gcd(a, b) = gcd(a - b, b), if a &gt; b<br>$$<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canMeasureWater</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (z &gt; x + y)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (x == <span class="number">0</span> &amp;&amp; y == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> z == <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> z % gcd(x, y) == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="2-状态节点-BFS"><a href="#2-状态节点-BFS" class="headerlink" title="2. 状态节点+BFS"></a>2. 状态节点+BFS</h2><p>由于</p>
<ol>
<li>倒空只能对满壶操作</li>
<li>装满只能对空壶操作</li>
<li>不可能同时两个桶都有水且不满</li>
</ol>
<p>把<code>(x, y)</code>看作是代表一个状态的结点，则可能有以下情况：  </p>
<ol>
<li><code>(0, cury)</code>：x倒空（当<code>curx == x</code>时）</li>
<li><code>(x, cury)</code>：x装满（当<code>curx == 0</code>时）</li>
<li><code>(curx, 0)</code>：y倒空（当<code>cury == y</code>时）</li>
<li><code>(curx, y)</code>：y倒满（当<code>cury == 0</code>时）</li>
<li>x倒到y中：<ul>
<li><code>if (y - cury &gt;= curx) &#123;(0, cury + curx)&#125;</code></li>
<li><code>(else) if (y - cury &lt; curx) &#123;curx - y + cury, y&#125;</code></li>
</ul>
</li>
<li>y倒到x中：<ul>
<li><code>if (x - curx &gt;= cury) &#123;(curx + cury, 0)&#125;</code></li>
<li><code>(else) if (x - curx &lt; cury) &#123;(x, cury - x + curx)&#125;</code></li>
</ul>
</li>
</ol>
<p>所以问题就变成了，从点<code>(0, 0)</code>出发，通过BFS看能否到达<code>(z, 0)||(0, z)||(x, z - x)||(z - y, y)</code><br>时间复杂度<code>O(xy)</code>，空间复杂度<code>O(xy)</code>，因为内部有判断，所以也不至于这么复杂，但是也只是勉强通过  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canMeasureWater</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (z &gt; x + y)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (x == <span class="number">0</span> || y == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> z == x || z == y;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//unordered_map&lt;pair&lt;int, int&gt;, bool&gt; rec;</span></span><br><span class="line">        <span class="comment">// unordered_map没有pair的hash函数，需要自己提供。</span></span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;, <span class="keyword">bool</span>&gt; rec;</span><br><span class="line">        rec[<span class="built_in">make_pair</span>(<span class="number">0</span>, <span class="number">0</span>)] = <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; q;</span><br><span class="line">        q.push(<span class="built_in">make_pair</span>(<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            <span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; temp = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="keyword">int</span> curx = temp.first;</span><br><span class="line">            <span class="keyword">int</span> cury = temp.second;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ((curx == z &amp;&amp; cury == <span class="number">0</span>) || (curx == <span class="number">0</span> &amp;&amp; cury == z) || (curx == x &amp;&amp; cury == z - x) || (curx == z - y &amp;&amp; cury == y))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//empty x</span></span><br><span class="line">            <span class="keyword">if</span> (curx == x &amp;&amp; rec.count(<span class="built_in">make_pair</span>(<span class="number">0</span>, cury)) == <span class="number">0</span>) &#123;</span><br><span class="line">                rec[<span class="built_in">make_pair</span>(<span class="number">0</span>, cury)] = <span class="literal">true</span>;</span><br><span class="line">                q.push(<span class="built_in">make_pair</span>(<span class="number">0</span>, cury));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//fill x</span></span><br><span class="line">            <span class="keyword">if</span> (curx == <span class="number">0</span> &amp;&amp; rec.count(<span class="built_in">make_pair</span>(x, cury)) == <span class="number">0</span>) &#123;</span><br><span class="line">                rec[<span class="built_in">make_pair</span>(x, cury)] = <span class="literal">true</span>;</span><br><span class="line">                q.push(<span class="built_in">make_pair</span>(x, cury));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//empty y</span></span><br><span class="line">            <span class="keyword">if</span> (cury == y &amp;&amp; rec.count(<span class="built_in">make_pair</span>(curx, <span class="number">0</span>)) == <span class="number">0</span>) &#123;</span><br><span class="line">                rec[<span class="built_in">make_pair</span>(curx, <span class="number">0</span>)] = <span class="literal">true</span>;</span><br><span class="line">                q.push(<span class="built_in">make_pair</span>(curx, <span class="number">0</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//fill y</span></span><br><span class="line">            <span class="keyword">if</span> (cury == <span class="number">0</span> &amp;&amp; rec.count(<span class="built_in">make_pair</span>(curx, y)) == <span class="number">0</span>) &#123;</span><br><span class="line">                rec[<span class="built_in">make_pair</span>(curx, y)] = <span class="literal">true</span>;</span><br><span class="line">                q.push(<span class="built_in">make_pair</span>(curx, y));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//x -&gt; y</span></span><br><span class="line">            <span class="keyword">if</span> (y - cury &gt;= curx &amp;&amp; rec.count(<span class="built_in">make_pair</span>(<span class="number">0</span>, cury + curx)) == <span class="number">0</span>) &#123;</span><br><span class="line">                rec[<span class="built_in">make_pair</span>(<span class="number">0</span>, cury + curx)] = <span class="literal">true</span>;</span><br><span class="line">                q.push(<span class="built_in">make_pair</span>(<span class="number">0</span>, cury + curx));</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (y - cury &lt; curx &amp;&amp; rec.count(<span class="built_in">make_pair</span>(curx - y + cury, y)) == <span class="number">0</span>) &#123;</span><br><span class="line">                rec[<span class="built_in">make_pair</span>(curx - y + cury, y)] = <span class="literal">true</span>;</span><br><span class="line">                q.push(<span class="built_in">make_pair</span>(curx - y + cury, y));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//y-&gt;x</span></span><br><span class="line">            <span class="keyword">if</span> (x - curx &gt;= cury &amp;&amp; rec.count(<span class="built_in">make_pair</span>(curx + cury, <span class="number">0</span>)) == <span class="number">0</span>) &#123;</span><br><span class="line">                rec[<span class="built_in">make_pair</span>(curx + cury, <span class="number">0</span>)] = <span class="literal">true</span>;</span><br><span class="line">                q.push(<span class="built_in">make_pair</span>(curx + cury, <span class="number">0</span>));</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x - curx &lt; cury &amp;&amp; rec.count(<span class="built_in">make_pair</span>(x, cury - x + curx)) == <span class="number">0</span>) &#123;</span><br><span class="line">                rec[<span class="built_in">make_pair</span>(x, cury - x + curx)] = <span class="literal">true</span>;</span><br><span class="line">                q.push(<span class="built_in">make_pair</span>(x, cury - x + curx));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> rec[<span class="built_in">make_pair</span>(z, <span class="number">0</span>)] || rec[<span class="built_in">make_pair</span>(<span class="number">0</span>, z)] || rec[<span class="built_in">make_pair</span>(x, z - x)] || rec[<span class="built_in">make_pair</span>(z - y, y)];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>bfs</tag>
      </tags>
  </entry>
  <entry>
    <title>945.Minimum Increment to Make Array Unique</title>
    <url>/minimum-increment-to-make-array-unique/</url>
    <content><![CDATA[<p>Given an array of integers A, a move consists of choosing any A[i], and incrementing it by 1.</p>
<p>Return the least number of moves to make every value in A unique.</p>
<p> </p>
<p>Example 1:</p>
<p>Input: [1,2,2]<br>Output: 1<br>Explanation:  After 1 move, the array could be [1, 2, 3].<br>Example 2:</p>
<p>Input: [3,2,1,2,1,7]<br>Output: 6<br>Explanation:  After 6 moves, the array could be [3, 4, 1, 2, 5, 7].<br>It can be shown with 5 or less moves that it is impossible for the array to have all unique values.</p>
<p>Note:</p>
<p>0 &lt;= A.length &lt;= 40000<br>0 &lt;= A[i] &lt; 40000</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/minimum-increment-to-make-array-unique">https://leetcode-cn.com/problems/minimum-increment-to-make-array-unique</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<hr>
<h2 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minIncrementForUnique</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1-计数O-n-range"><a href="#1-计数O-n-range" class="headerlink" title="1. 计数O(n+range)"></a>1. 计数<code>O(n+range)</code></h2><p>数据是<code>[0, 40000)</code>，所以移动之后占的位置是<code>[0, 79998]</code>.<br>但是我们并不需要<code>80000</code>大的数组，<code>40001</code>就足够了，因为<code>39999</code>位置上的次数-1加到<code>40000</code>位置上，这些数就被均匀地分布到<code>40000~之后</code>了。<br>同理，我们可以记录<code>maxv</code>，到达<code>maxv</code>之后，后面的<code>maxv+1, maxv+2, ...</code>用公式算就好了。  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minIncrementForUnique</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count[<span class="number">40010</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">40010</span>; i++)</span><br><span class="line">            count[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> maxv = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.size(); i++) &#123;</span><br><span class="line">            count[A[i]]++;</span><br><span class="line">            maxv = maxv &gt;= A[i] ? maxv : A[i];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= maxv; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (count[i] &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                count[i + <span class="number">1</span>] += count[i] - <span class="number">1</span>;</span><br><span class="line">                ans += count[i] - <span class="number">1</span>;</span><br><span class="line">                count[i] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ans += count[maxv + <span class="number">1</span>] * (count[maxv + <span class="number">1</span>] - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>面试题40. 最小的k个数</title>
    <url>/zui-xiao-de-kge-shu-lcof/</url>
    <content><![CDATA[<p>输入整数数组 arr ，找出其中最小的 k 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。</p>
<p>示例 1：</p>
<p>输入：arr = [3,2,1], k = 2<br>输出：[1,2] 或者 [2,1]<br>示例 2：</p>
<p>输入：arr = [0,1,2,1], k = 1<br>输出：[0]</p>
<p>限制：</p>
<p>0 &lt;= k &lt;= arr.length &lt;= 10000<br>0 &lt;= arr[i] &lt;= 10000</p>
<hr>
<h2 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">getLeastNumbers</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1-sort-O-nlogn"><a href="#1-sort-O-nlogn" class="headerlink" title="1. sort, O(nlogn)"></a>1. sort, <code>O(nlogn)</code></h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">getLeastNumbers</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        sort(arr.begin(), arr.end());</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(arr.begin(), arr.begin() + k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2-大根堆priority-queue-时间O-nlogk-，空间O-k"><a href="#2-大根堆priority-queue-时间O-nlogk-，空间O-k" class="headerlink" title="2. 大根堆priority_queue, 时间O(nlogk)，空间O(k)"></a>2. 大根堆priority_queue, 时间<code>O(nlogk)</code>，空间<code>O(k)</code></h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">getLeastNumbers</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">priority_queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">        <span class="keyword">int</span> arrLen = arr.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arrLen; i++) &#123;</span><br><span class="line">            q.push(arr[i]);</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= k)</span><br><span class="line">                q.pop();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            res.push_back(q.top());</span><br><span class="line">            q.pop();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="3-计数排序"><a href="#3-计数排序" class="headerlink" title="3. 计数排序"></a>3. 计数排序</h2><p>已知数据范围0~10000，则<code>int count[10001]</code>，遍历数据并计数，取前k个就可以。<br>数组也需要初始化为0。时间<code>O(n+range)</code>，空间<code>O(range)</code>  </p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>堆</tag>
      </tags>
  </entry>
  <entry>
    <title>409.Longest Palindrome</title>
    <url>/longest-palindrome/</url>
    <content><![CDATA[<p>Given a string which consists of lowercase or uppercase letters, find the length of the longest palindromes that can be built with those letters.</p>
<p>This is case sensitive, for example “Aa” is not considered a palindrome here.</p>
<p>Note:<br>Assume the length of given string will not exceed 1,010.</p>
<p>Example:</p>
<p>Input:<br>“abccccdd”</p>
<p>Output:<br>7</p>
<p>Explanation:<br>One longest palindrome that can be built is “dccaccd”, whose length is 7.</p>
<hr>
<h2 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1-统计次数"><a href="#1-统计次数" class="headerlink" title="1. 统计次数"></a>1. 统计次数</h2><p>回文串中所有的同一类的字符必为偶数个，再加上可能有的最中间的那个字符。<br>每个字符遍历一次，<code>O(n)</code>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count[<span class="number">52</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">52</span>; i++)</span><br><span class="line">            count[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> lenS = s.length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lenS; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; s[i] &lt;= <span class="string">&#x27;z&#x27;</span>)</span><br><span class="line">                count[s[i] - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                count[s[i] - <span class="string">&#x27;A&#x27;</span> + <span class="number">26</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">52</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (count[i] % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">                ans += count[i];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                ans += count[i] - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ans &lt; lenS)</span><br><span class="line">            ans++;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>836.Rectangle Overlap</title>
    <url>/rectangle-overlap/</url>
    <content><![CDATA[<p>A rectangle is represented as a list [x1, y1, x2, y2], where (x1, y1) are the coordinates of its bottom-left corner, and (x2, y2) are the coordinates of its top-right corner.</p>
<p>Two rectangles overlap if the area of their intersection is positive.  To be clear, two rectangles that only touch at the corner or edges do not overlap.</p>
<p>Given two (axis-aligned) rectangles, return whether they overlap.</p>
<p>Example 1:</p>
<p>Input: rec1 = [0,0,2,2], rec2 = [1,1,3,3]<br>Output: true<br>Example 2:</p>
<p>Input: rec1 = [0,0,1,1], rec2 = [1,0,2,1]<br>Output: false<br>Notes:</p>
<p>Both rectangles rec1 and rec2 are lists of 4 integers.<br>All coordinates in rectangles will be between -10^9 and 10^9.</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/rectangle-overlap">https://leetcode-cn.com/problems/rectangle-overlap</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<hr>
<h2 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isRectangleOverlap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; rec1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; rec2)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1-画图分析"><a href="#1-画图分析" class="headerlink" title="1. 画图分析"></a>1. 画图分析</h2><p>两个矩形相交得到的小矩形的：<br>左边界是二者左边界中最大的，<br>右边界是二者右边界中最小的，<br>下边界是二者下边界中最大的，<br>上边界是二者上边界中最小的。  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isRectangleOverlap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; rec1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; rec2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (max(rec1[<span class="number">0</span>], rec2[<span class="number">0</span>]) &lt; min(rec1[<span class="number">2</span>], rec2[<span class="number">2</span>]) &amp;&amp; max(rec1[<span class="number">1</span>], rec2[<span class="number">1</span>]) &lt; min(rec1[<span class="number">3</span>], rec2[<span class="number">3</span>]))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2-投影取反"><a href="#2-投影取反" class="headerlink" title="2. 投影取反"></a>2. 投影取反</h2><p>这个是看题解知道的，妙啊。<br>把两个矩形投影到x, y轴，如果相交，那么它们在x, y轴的投影都是重叠的，就变成了判断线段是否重叠的问题。<br>不过实际上，重叠的情况很多，不重叠的更好判断，所以判断不重叠然后取反就可以了。<br><img src="projection.jpg" alt="projection"></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>5.最长回文子串</title>
    <url>/longest-palindromic-substring/</url>
    <content><![CDATA[<p>Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000.</p>
<p>Example 1:</p>
<p>Input: “babad”<br>Output: “bab”<br>Note: “aba” is also a valid answer.<br>Example 2:</p>
<p>Input: “cbbd”<br>Output: “bb”</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/longest-palindromic-substring">https://leetcode-cn.com/problems/longest-palindromic-substring</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<hr>
<h2 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1-朴素"><a href="#1-朴素" class="headerlink" title="1. 朴素"></a>1. 朴素</h2><p>遍历每个子串<code>O(n^2)</code>，判断子串是否回文<code>O(n)</code>，共<code>O(n^3)</code><br>提交错误，<em>超时</em>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindromic</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = s.size();</span><br><span class="line">        <span class="keyword">int</span> mid = length / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mid; i++)</span><br><span class="line">            <span class="keyword">if</span> (s[i] != s[length - i - <span class="number">1</span>])</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = s.size();</span><br><span class="line">        <span class="keyword">if</span> (length == <span class="number">1</span>)    <span class="comment">//exclusive</span></span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">string</span> ans = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length - <span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; length; j++) &#123;</span><br><span class="line">                <span class="built_in">string</span> subs = s.substr(i, j - i + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (isPalindromic(subs))</span><br><span class="line">                    ans = subs.size() &gt; ans.size() ? subs : ans;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2-最长公共子串"><a href="#2-最长公共子串" class="headerlink" title="2. 最长公共子串"></a>2. 最长公共子串</h2><p>回文字符串正反都是一样的，所以对于回文字符串，其在<code>s</code>和逆序的<code>s&#39;</code>中是一样的，因此可以转换为求<code>最长公共子串</code>的问题。<br>注意<code>最长公共子串</code>和<code>最长公共子序列</code>是不同的，参考<a href="https://blog.csdn.net/ggdhs/article/details/90713154">https://blog.csdn.net/ggdhs/article/details/90713154</a><br><strong>最长公共子串不一定是<code>s</code>的回文字符串，比如<code>abc123cba</code>得到的最长公共子串是<code>abc</code>但并不回文，因此还需要判断索引位置</strong>  </p>
<p><strong>最长公共子串</strong>：<br>其要求必须连续，所以dp时需要确定结尾元素相同，要不然接不上。<br>设<code>dp[i][j]</code>为数组<code>A</code>中前<code>i</code>个元素和数组<code>B</code>中前<code>j</code>个元素以<code>A[i-1]</code>和<code>B[j-1]</code>为结尾的最长公共子串的长度。<br>则递推公式为：  </p>
<ol>
<li><code>dp[i][j] = 0</code>, 当<code>i = 0 || j = 0</code>时（初始条件）</li>
<li><code>dp[i][j] = 0</code>, 当<code>A[i-1] != B[j-1]</code>时（结尾不同，不能往后接了）</li>
<li><code>dp[i][j] = dp[i-1][j-1] + 1</code>, 当<code>A[i-1] == B[j-1]</code>时（可以继续往后接，顺便带上前面部分的长度）  </li>
</ol>
<p>所以初始化<code>dp[m][n]</code>全为<code>0</code>，仅当满足<code>条件3</code>时更新值即可。此时的时间复杂度和空间复杂度均为<code>O(mn)</code>。<br>值得注意的是，由于每次更新<code>dp[i][j]</code>只需要<code>dp[i-1][j-1]</code>，所以可以优化空间复杂度为<code>O(n)</code>，不过此时需要记录最大值<code>maxLength</code>，否则会被后面的值覆盖掉。同时也需要<code>逆序</code>更新。  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="string">&quot;&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">string</span> revs = s;</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n / <span class="number">2</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">char</span> temp = revs[i];</span><br><span class="line">            revs[i] = revs[n - i - <span class="number">1</span>];</span><br><span class="line">            revs[n - i - <span class="number">1</span>] = temp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//int dp[n + 1];</span></span><br><span class="line">        <span class="keyword">int</span> *dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++)</span><br><span class="line">            dp[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> maxLength = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> maxEnd = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = n; j &gt; <span class="number">0</span>; j--)&#123;</span><br><span class="line">                <span class="keyword">if</span> (s[i - <span class="number">1</span>] == revs[j - <span class="number">1</span>])&#123;</span><br><span class="line">                    dp[j] = dp[j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span>(dp[j] &gt; maxLength &amp;&amp; i + j == n + dp[j])&#123;</span><br><span class="line">                        maxLength = dp[j];</span><br><span class="line">                        maxEnd = i - <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span></span><br><span class="line">                    dp[j] = <span class="number">0</span>;</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">delete</span> []dp;</span><br><span class="line">        <span class="keyword">return</span> s.substr(maxEnd - maxLength + <span class="number">1</span>, maxLength);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="3-dp优化的朴素算法"><a href="#3-dp优化的朴素算法" class="headerlink" title="3. dp优化的朴素算法"></a>3. dp优化的朴素算法</h2><p>遍历每个字符串是<code>O(n^2)</code>，判断每个子串是否回文是<code>O(n)</code>，因此朴素方法的复杂度是<code>O(n^3)</code>.<br>朴素方法复杂的原因是做了重复的判断。如果能够将判断每个子串的复杂度降低到<code>O(1)</code>，那么整体的复杂度就优化到了<code>O(n^2)</code>。<br>如果要避免重复判断，可以使用dp记录每个子串的是否回文情况，判断新的子串时只需要借助中间的旧子串的回文性就可以了。<br>设<code>bool dp[i][j]</code>，代表<code>s[i, ..., j]</code>是回文的，则<code>dp[i][j] = dp[i+1][j-1] &amp;&amp; s[i] == s[j]</code>，初始化<code>dp[i][i] = true</code>。<br>此外，长度为1或2的子串需要额外判断。并且需要逆序。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="string">&quot;&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="keyword">bool</span> **dp = <span class="keyword">new</span> <span class="keyword">bool</span> *[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            dp[i] = <span class="keyword">new</span> <span class="keyword">bool</span>[n];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (i == j)</span><br><span class="line">                    dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (j - i == <span class="number">1</span> &amp;&amp; s[i] == s[j])</span><br><span class="line">                    dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    dp[i][j] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">string</span> ans = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j - i &gt;= <span class="number">2</span>)</span><br><span class="line">                    dp[i][j] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>] &amp;&amp; s[i] == s[j];</span><br><span class="line">                <span class="keyword">if</span> (dp[i][j] &amp;&amp; j - i + <span class="number">1</span> &gt; ans.size())</span><br><span class="line">                    ans = s.substr(i, j - i + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="keyword">delete</span> []dp[i];</span><br><span class="line">        <span class="keyword">delete</span> []dp;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="4-中心扩展算法"><a href="#4-中心扩展算法" class="headerlink" title="4. 中心扩展算法"></a>4. 中心扩展算法</h2><p>回文实际上就是中心对称，所以可以找到中心点，然后向两边扩展即可。<br>中心点可以是字符，比如<code>aba</code>；也可以是空，比如<code>aa</code>，因此一共有<code>n + (n - 1) = 2n - 1</code>个中心点，<code>O(n)</code>。<br>每次向外扩展是<code>O(n)</code>的，因此总的复杂度是<code>O(n^2)</code>。由于不需要额外的空间，所以空间复杂度是<code>O(1)</code>，还优于前面的算法……</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="string">&quot;&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="keyword">int</span> cmid = <span class="number">0</span>, gmid = <span class="number">0</span>;     <span class="comment">//character &amp; gap</span></span><br><span class="line">        <span class="built_in">string</span> ans = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(cmid &lt; n)&#123;</span><br><span class="line">            <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(cmid - len &gt;= <span class="number">0</span> &amp;&amp; cmid + len &lt; n &amp;&amp; s[cmid - len] == s[cmid + len])</span><br><span class="line">                len++;</span><br><span class="line">            len--;</span><br><span class="line">            ans = <span class="number">2</span> * len + <span class="number">1</span> &gt; ans.size() ? s.substr(cmid - len, <span class="number">2</span> * len + <span class="number">1</span>) : ans;</span><br><span class="line">            cmid++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(gmid &lt; n - <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> len = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(gmid - len + <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; gmid + len &lt; n &amp;&amp; s[gmid - len + <span class="number">1</span>] == s[gmid + len])</span><br><span class="line">                len++;</span><br><span class="line">            len--;</span><br><span class="line">            ans = <span class="number">2</span> * len &gt; ans.size() ? s.substr(gmid - len + <span class="number">1</span>, <span class="number">2</span> * len) : ans;</span><br><span class="line">            gmid++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="5-Manacher’s-Algorithm"><a href="#5-Manacher’s-Algorithm" class="headerlink" title="5. Manacher’s Algorithm"></a>5. Manacher’s Algorithm</h2><p>马拉车算法，复杂度<code>O(n)</code>，太强了。<br>算法思想类似于中心扩展算法，但是充分利用了回文串的对称性，把扩展的复杂度降到了<code>O(1)</code>。<br>同时，它在字符串<code>s</code>的每个字符的间隔和开头与结尾都添加了<code>#</code>作为分隔符（<code>#</code>是不出现在字符串<code>s</code>中的符号），解决了中心扩展算法的奇偶判断问题。<br>如，<code>aba</code>变成了<code>#a#b#a#</code>，<code>abba</code>变成了<code>#a#b#b#a#</code>，全都变成了奇数位的判断。<br><img src="Manacher1.jpg" alt="Manacher1">  </p>
<p>此外，算法定义了数组<code>p[i]</code>，用来记录以<code>s&#39;[i]</code>（<code>s&#39;[]</code>为<code>s</code>添加间隔符之后的新字符串）为中心的回文串的回文半径（包括回文中心和一侧的所有字符的长度和）<br>可以分析得出，<code>p[i] - 1</code>即为旧字符串<code>s</code>中以<code>s[i]</code>为中心的回文串的总长度。<br>所以问题就变成了求回文半径<code>p[i]</code>的问题。  </p>
<p>如果还是采用中心扩展计算回文半径，那么复杂度和中心扩展算法是一样的，所以需要一种新的方法。<br>中心扩展的问题就是某些字符串会经过多次重复的扩展和计算，所以如果能够根据过去的<code>p</code>得到新的<code>p</code>，那么复杂度就降低了。<br>定义<code>maxRight</code>和<code>center</code>，分别用来记录新字符串<code>s&#39;</code>中，已经探索过的回文串能够到达的最右侧的位置<code>maxRight</code>，以及到达该位置的回文串的中心索引<code>center</code>.<br>根据<code>i</code>与上述变量的关系，可以分析<code>p[i]</code>的更新方式。  </p>
<ul>
<li><strong>当<code>i &gt;= maxRight</code>时</strong><br>说明是最开始或者可能是刚刚更新完某一个特别短的串时，此时没有参考，所以<code>p[i]</code>只能自己<strong>中心扩展</strong>。</li>
<li><strong>当<code>i &lt; maxRight</code>时</strong><br>此时需要根据与<code>i</code>关于<code>center</code>对称的索引<code>i_mirror</code>的<code>p[i_mirror]</code>来分析。<br>由于<code>i</code>与<code>i_mirror</code>关于<code>center</code>对称，因此有<code>(i + i_mirror) / 2 = center</code>，所以<code>i_mirror = 2 * center - i</code>。<br>根据<code>p[i_mirror]</code>的值，讨论以下情况：  <ol>
<li><code>p[i_mirror] - 1 &lt; maxRight - i</code><br><code>maxRight - i</code>是<code>i</code>到<code>maxRight</code>的距离，也是<code>maxRight</code>关于<code>center</code>的对称点到<code>i_mirror</code>的距离。<br><code>p[i_mirror]</code>是<code>s&#39;[i_mirror]</code>的回文半径，<code>p[i_mirror] - 1</code>就是单纯的除去中心点之后某一侧的长度，若其小于<code>maxRight - i</code>，说明以<code>s&#39;[i_mirror]</code>为中心的回文串是没有到达当前<code>s&#39;[center]</code>定义的回文串的左侧边界的，是<code>s&#39;[center]</code>的回文串的子串。<br>由于<code>s&#39;[i_mirror]</code>定义的回文串是<code>s&#39;[center]</code>的子串，又回文串是对称的，所以<code>s&#39;[i]</code>的回文串与<code>s&#39;[i_mirror]</code>的回文串是相同的。<br>因此<code>p[i]</code>直接等于<code>p[i_mirror]</code>。<br><img src="Manacher2.jpg" alt="Manacher2">  </li>
<li><code>p[i_mirror] - 1 == maxRight - i</code><br>说明以<code>s&#39;[i_mirror]</code>为中心的回文串的左边界恰巧与<code>s&#39;[maxRight_mirror]</code>重合。<br><code>s&#39;[i_mirror]</code>的回文串没有继续拓展，可能是因为左侧已到达字符串的边界，或者是左侧的字符与右侧对应的字符不相等。<br><code>s&#39;[i]</code>的回文串中间一部分肯定与<code>s&#39;[i_mirror]</code>的回文串是相同的，但是<code>s&#39;[i]</code>的回文串可能继续向外拓展。<br>所以首先设置<code>p[i] = p[i_mirror]</code>，然后让<code>s&#39;[i]</code>在此基础上继续中心扩展。  </li>
<li><code>p[i_mirror] - 1 &gt; maxRight - i</code><br>说明<code>s&#39;[i_mirror]</code>的回文串的左边界超过了<code>s&#39;[center]</code>的回文串的左边界。<br>首先是<code>s&#39;[i_mirror]</code>的回文串的左边界到达了<code>s&#39;[maxRight_mirror]</code>，因此设置<code>p[i] = maxRight - i + 1</code>。<br>其次，<code>s&#39;[i_mirror]</code>的回文串的左边界超过了<code>s&#39;[maxRight_mirror]</code>，说明其可以继续扩展。<br>但是<code>s&#39;[center]</code>的回文串没有继续扩展，说明<code>s&#39;[maxRight]</code>之后的字符与<code>s&#39;[maxRight_mirror]</code>之前的字符肯定不相等。<br>而<code>s&#39;[i_mirror]</code>的回文串额外扩展出去的部分字符由于回文串的对称性，<code>s&#39;[i]</code>也是有的。<br>但是<code>s&#39;[center]</code>都没继续向右扩展，说明<code>s&#39;[i]</code>肯定也不能继续向右扩展了。<br>因此<code>p[i] = maxRight - i + 1</code>。<br><img src="Manacher3.jpg" alt="Manacher3">  </li>
</ol>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">centerSpread</span><span class="params">(<span class="built_in">string</span>&amp; s, <span class="keyword">int</span> center, <span class="keyword">int</span> already)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = already;</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="keyword">while</span>(center - len &gt;= <span class="number">0</span> &amp;&amp; center + len &lt; n &amp;&amp; s[center - len] == s[center + len])</span><br><span class="line">            len++;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> center + len - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="string">&quot;&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">string</span> divs = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); i++)&#123;</span><br><span class="line">            divs.push_back(<span class="string">&#x27;#&#x27;</span>);</span><br><span class="line">            divs.push_back(s[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        divs.push_back(<span class="string">&#x27;#&#x27;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> n = divs.size();</span><br><span class="line">        <span class="keyword">int</span> maxRight = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> center = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> *p = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) </span><br><span class="line">            p[i] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ansLen = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">string</span> ans = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= maxRight) &#123;</span><br><span class="line">                maxRight = centerSpread(divs, i, <span class="number">0</span>);</span><br><span class="line">                center = i;</span><br><span class="line">                p[i] = maxRight - i + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">int</span> i_mirror = <span class="number">2</span> * center - i;</span><br><span class="line">                <span class="keyword">if</span> (p[i_mirror] - <span class="number">1</span> &lt; maxRight - i)</span><br><span class="line">                    p[i] = p[i_mirror];</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (p[i_mirror] - <span class="number">1</span> == maxRight - i) &#123;</span><br><span class="line">                    p[i] = p[i_mirror];</span><br><span class="line">                    maxRight = centerSpread(divs, i, p[i]);</span><br><span class="line">                    center = i;</span><br><span class="line">                    p[i] = maxRight - i + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span></span><br><span class="line">                    p[i] = maxRight - i + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (p[i] - <span class="number">1</span> &gt; ansLen) &#123;</span><br><span class="line">                ansLen = p[i] - <span class="number">1</span>;</span><br><span class="line">                ans = s.substr((i - ansLen + <span class="number">1</span>) / <span class="number">2</span>, ansLen);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">delete</span> []p;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>1103.Distribute Candies to People</title>
    <url>/distribute-candies-to-people/</url>
    <content><![CDATA[<p>We distribute some number of candies, to a row of n = num_people people in the following way:</p>
<p>We then give 1 candy to the first person, 2 candies to the second person, and so on until we give n candies to the last person.</p>
<p>Then, we go back to the start of the row, giving n + 1 candies to the first person, n + 2 candies to the second person, and so on until we give 2 * n candies to the last person.</p>
<p>This process repeats (with us giving one more candy each time, and moving to the start of the row after we reach the end) until we run out of candies.  The last person will receive all of our remaining candies (not necessarily one more than the previous gift).</p>
<p>Return an array (of length num_people and sum candies) that represents the final distribution of candies.</p>
<p> </p>
<p>Example 1:</p>
<p>Input: candies = 7, num_people = 4<br>Output: [1,2,3,1]<br>Explanation:<br>On the first turn, ans[0] += 1, and the array is [1,0,0,0].<br>On the second turn, ans[1] += 2, and the array is [1,2,0,0].<br>On the third turn, ans[2] += 3, and the array is [1,2,3,0].<br>On the fourth turn, ans[3] += 1 (because there is only one candy left), and the final array is [1,2,3,1].<br>Example 2:</p>
<p>Input: candies = 10, num_people = 3<br>Output: [5,2,3]<br>Explanation:<br>On the first turn, ans[0] += 1, and the array is [1,0,0].<br>On the second turn, ans[1] += 2, and the array is [1,2,0].<br>On the third turn, ans[2] += 3, and the array is [1,2,3].<br>On the fourth turn, ans[0] += 4, and the final array is [5,2,3].</p>
<p>Constraints:</p>
<p>1 &lt;= candies &lt;= 10^9<br>1 &lt;= num_people &lt;= 1000</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/distribute-candies-to-people">https://leetcode-cn.com/problems/distribute-candies-to-people</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<hr>
<h2 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">distributeCandies</span><span class="params">(<span class="keyword">int</span> candies, <span class="keyword">int</span> num_people)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1-直接推导"><a href="#1-直接推导" class="headerlink" title="1. 直接推导"></a>1. 直接推导</h2><p><img src="deduction.png" alt="deduction"><br>此处我的推导是以“轮”为单位，看能够发多少轮，不过确定多少轮还是用的减一下减一下的方法，复杂度是<code>O(sqrt(C)/N + N)</code>。<br><strong>而复杂度更低的方法是以“次”为单位，一人发一次算一“次”，看看能发多少次，这样可以直接解出到底是发了多少次来，复杂度是<code>O(N)</code>。</strong>  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">distributeCandies</span><span class="params">(<span class="keyword">int</span> candies, <span class="keyword">int</span> num_people)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> round = <span class="number">1</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">alloc</span><span class="params">(num_people)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (candies &gt;= num_people * ((<span class="number">2</span> * round - <span class="number">1</span>) * num_people + <span class="number">1</span>) / <span class="number">2</span>) &#123;</span><br><span class="line">            candies -= num_people * ((<span class="number">2</span> * round - <span class="number">1</span>) * num_people + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">            round++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num_people; i++) &#123;</span><br><span class="line">            alloc[i] = (round - <span class="number">2</span>) * (round - <span class="number">1</span>) * num_people / <span class="number">2</span> + (round - <span class="number">1</span>) * (i + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (candies &gt;= (round - <span class="number">1</span>) * num_people + i + <span class="number">1</span>) &#123;</span><br><span class="line">                alloc[i] += (round - <span class="number">1</span>) * num_people + i + <span class="number">1</span>;</span><br><span class="line">                candies -= (round - <span class="number">1</span>) * num_people + i + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                alloc[i] += candies;</span><br><span class="line">                candies = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> alloc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>994. Rotting Oranges</title>
    <url>/rotting-oranges/</url>
    <content><![CDATA[<p>In a given grid, each cell can have one of three values:</p>
<p>the value 0 representing an empty cell;<br>the value 1 representing a fresh orange;<br>the value 2 representing a rotten orange.<br>Every minute, any fresh orange that is adjacent (4-directionally) to a rotten orange becomes rotten.</p>
<p>Return the minimum number of minutes that must elapse until no cell has a fresh orange.  If this is impossible, return -1 instead.</p>
<p> </p>
<p>Example 1:</p>
<p>Input: [[2,1,1],[1,1,0],[0,1,1]]<br>Output: 4<br>Example 2:</p>
<p>Input: [[2,1,1],[0,1,1],[1,0,1]]<br>Output: -1<br>Explanation:  The orange in the bottom left corner (row 2, column 0) is never rotten, because rotting only happens 4-directionally.<br>Example 3:</p>
<p>Input: [[0,2]]<br>Output: 0<br>Explanation:  Since there are already no fresh oranges at minute 0, the answer is just 0.</p>
<p>Note:</p>
<p>1 &lt;= grid.length &lt;= 10<br>1 &lt;= grid[0].length &lt;= 10<br>grid[i][j] is only 0, 1, or 2.</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/rotting-oranges">https://leetcode-cn.com/problems/rotting-oranges</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<hr>
<h2 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">orangesRotting</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1-朴素"><a href="#1-朴素" class="headerlink" title="1. 朴素"></a>1. 朴素</h2><p>每次遍历grid，用queue储存2的位置，然后遍历queue，把2周围的1都变成2，而不能入队（新的烂橘子不具备传染能力）<br>当两次遍历grid得到的剩余1的个数相等时表示结束。<br><code>O(mnk)</code>，m, n, k分别为grid的行、列、时间。  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">orangesRotting</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = grid.size(), n = grid[<span class="number">0</span>].size(), time = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> last = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>)</span><br><span class="line">                    last++;</span><br><span class="line">        <span class="keyword">int</span> movi[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> movj[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; q;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">                    <span class="keyword">if</span> (grid[i][j] == <span class="number">2</span>)</span><br><span class="line">                        q.push(<span class="built_in">make_pair</span>(i, j));</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">int</span> cur = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">                <span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; temp = q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                <span class="keyword">int</span> loci = temp.first, locj = temp.second;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">                    <span class="keyword">if</span> (loci + movi[i] &gt;= <span class="number">0</span> &amp;&amp; loci + movi[i] &lt; m &amp;&amp; locj + movj[i] &gt;= <span class="number">0</span> &amp;&amp; locj + movj[i] &lt; n &amp;&amp; grid[loci + movi[i]][locj + movj[i]] == <span class="number">1</span>)</span><br><span class="line">                        grid[loci + movi[i]][locj + movj[i]] = <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">                    <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>)</span><br><span class="line">                        cur++;</span><br><span class="line">            <span class="keyword">if</span> (cur != last) &#123;</span><br><span class="line">                time++;</span><br><span class="line">                last = cur;</span><br><span class="line">            &#125; <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> last == <span class="number">0</span> ? time : <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2-BFS-超级原点"><a href="#2-BFS-超级原点" class="headerlink" title="2. BFS+超级原点"></a>2. BFS+超级原点</h2><p>一个烂橘子传染一次之后其实就失效了，其他部分的传染不会跟它有关。<br>所以每个橘子给一个时间属性，用BFS从最开始的烂橘子出发，找到所有相邻的橘子，时间每次++就代表腐烂时间。<br>由于最开始有多个烂橘子，因此可以想象有一个超级原点，然后把这些初始的烂橘子都放到queue中。<br>这样就相当于复杂度是<code>O(mn)</code>。  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">orangesRotting</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = grid.size(), n = grid[<span class="number">0</span>].size();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; <span class="title">timeRecord</span><span class="params">(grid)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> leftFresh = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; q;</span><br><span class="line">        <span class="keyword">int</span> maxTime = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> movi[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> movj[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>)</span><br><span class="line">                    leftFresh++;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (grid[i][j] == <span class="number">2</span>)</span><br><span class="line">                    q.push(<span class="built_in">make_pair</span>(i, j));</span><br><span class="line">                timeRecord[i][j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            <span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; cur = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="keyword">int</span> curi = cur.first, curj = cur.second;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> aroundi = curi + movi[i], aroundj = curj + movj[i];</span><br><span class="line">                <span class="keyword">if</span> (aroundi &gt;= <span class="number">0</span> &amp;&amp; aroundi &lt; m &amp;&amp; aroundj &gt;= <span class="number">0</span> &amp;&amp; aroundj &lt; n &amp;&amp; grid[aroundi][aroundj] == <span class="number">1</span>) &#123;</span><br><span class="line">                    grid[aroundi][aroundj] = <span class="number">2</span>;</span><br><span class="line">                    timeRecord[aroundi][aroundj] = timeRecord[curi][curj] + <span class="number">1</span>;</span><br><span class="line">                    q.push(<span class="built_in">make_pair</span>(aroundi, aroundj));</span><br><span class="line">                    leftFresh--;</span><br><span class="line">                    maxTime = timeRecord[aroundi][aroundj] &gt; maxTime ? timeRecord[aroundi][aroundj] : maxTime;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> leftFresh == <span class="number">0</span> ? maxTime : <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>bfs</tag>
      </tags>
  </entry>
  <entry>
    <title>1160.Find Words That Can Be Formed by Characters</title>
    <url>/find-words-that-can-be-formed-by-characters/</url>
    <content><![CDATA[<p>You are given an array of strings words and a string chars.</p>
<p>A string is good if it can be formed by characters from chars (each character can only be used once).</p>
<p>Return the sum of lengths of all good strings in words.</p>
<p> </p>
<p>Example 1:</p>
<p>Input: words = [“cat”,”bt”,”hat”,”tree”], chars = “atach”<br>Output: 6<br>Explanation:<br>The strings that can be formed are “cat” and “hat” so the answer is 3 + 3 = 6.<br>Example 2:</p>
<p>Input: words = [“hello”,”world”,”leetcode”], chars = “welldonehoneyr”<br>Output: 10<br>Explanation:<br>The strings that can be formed are “hello” and “world” so the answer is 5 + 5 = 10.</p>
<p>Note:</p>
<p>1 &lt;= words.length &lt;= 1000<br>1 &lt;= words[i].length, chars.length &lt;= 100<br>All strings contain lowercase English letters only.</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/find-words-that-can-be-formed-by-characters">https://leetcode-cn.com/problems/find-words-that-can-be-formed-by-characters</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<hr>
<h2 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countCharacters</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words, <span class="built_in">string</span> chars)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1-统计次数"><a href="#1-统计次数" class="headerlink" title="1. 统计次数"></a>1. 统计次数</h2><p>既然字母的次序是不好匹配的，那只需要统计次数就可以了。<br>一共就26个字母，用hash表<code>unordered_map</code>可以，不过用数组<code>int a[26]</code>会更省空间。<br>遍历每个字符串，统计字母次数就可以了，复杂度是<code>O(n)</code>，n是所有字符串的长度之和。</p>
<p>P.S.<br>我之前的想法是，朴素的话就是挨个对比，对word的每个字符都得扫描一遍chars。<br>然后优化一下就是先排好序，再比较就不用每个字符都去扫描chars了。<br>不过实际上这类问题统计次数就可以解决的问题，再去排个序就更麻烦了，而且复杂度也要高。  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countCharacters</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words, <span class="built_in">string</span> chars)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">int</span> charsCount[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++)</span><br><span class="line">            charsCount[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">string</span>::iterator iter = chars.begin(); iter != chars.end(); ++iter)</span><br><span class="line">            charsCount[(*iter) - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;::iterator iterw = words.begin(); iterw != words.end(); ++iterw) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++)</span><br><span class="line">                count[i] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">string</span>::iterator iters = iterw-&gt;begin(); iters != iterw-&gt;end(); ++iters)</span><br><span class="line">                count[*iters - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++)</span><br><span class="line">                <span class="keyword">if</span> (count[i] &gt; charsCount[i]) &#123;</span><br><span class="line">                    flag = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">if</span> (flag)</span><br><span class="line">                res += iterw-&gt;length();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>面试题 10.01. Sorted Merge LCCI</title>
    <url>/sorted-merge-lcci/</url>
    <content><![CDATA[<p>You are given two sorted arrays, A and B, where A has a large enough buffer at the end to hold B. Write a method to merge B into A in sorted order.</p>
<p>Initially the number of elements in A and B are m and n respectively.</p>
<p>Example:</p>
<p>Input:<br>A = [1,2,3,0,0,0], m = 3<br>B = [2,5,6],       n = 3</p>
<p>Output: [1,2,2,3,5,6]</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/sorted-merge-lcci">https://leetcode-cn.com/problems/sorted-merge-lcci</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<hr>
<h2 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="keyword">int</span> m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; B, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1-双指针"><a href="#1-双指针" class="headerlink" title="1. 双指针"></a>1. 双指针</h2><p>想法就是双指针遍历，然后把B的数据插入到A中。<br>不过应该不能用<code>insert()</code>，因为A后面已经有0来占位了，插入的时候可能会保留0而继续开拓空间导致超出内存限制。<br>所以可以对于B的一个元素，挨个往后移A的数据，直到B可以插入的位置，这样是<code>O(mn)</code>的。<br>不过既然A后面已经预留位置了，那么A和B可以直接从A的最后开始放最大值，这样就变成<code>O(m+n)</code>了。  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="keyword">int</span> m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; B, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> iterA = m - <span class="number">1</span>, iterB = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> loc = m + n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (loc &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (iterA == <span class="number">-1</span>)</span><br><span class="line">                A[loc--] = B[iterB--];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (iterB == <span class="number">-1</span>)</span><br><span class="line">                A[loc--] = A[iterA--];</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (A[iterA] &gt;= B[iterB])</span><br><span class="line">                    A[loc--] = A[iterA--];</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    A[loc--] = B[iterB--];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>面试题 01.06. Compress String LCCI</title>
    <url>/compress-string-lcci/</url>
    <content><![CDATA[<p>Implement a method to perform basic string compression using the counts of repeated characters. For example, the string aabcccccaaa would become a2blc5a3. If the “compressed” string would not become smaller than the original string, your method should return the original string. You can assume the string has only uppercase and lowercase letters (a - z).</p>
<p>Example 1:</p>
<p>Input: “aabcccccaaa”<br>Output: “a2b1c5a3”<br>Example 2:</p>
<p>Input: “abbccd”<br>Output: “abbccd”<br>Explanation:<br>The compressed string is “a1b2c2d1”, which is longer than the original string.</p>
<p>Note:</p>
<p>0 &lt;= S.length &lt;= 50000</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/compress-string-lcci">https://leetcode-cn.com/problems/compress-string-lcci</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<hr>
<h2 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">compressString</span><span class="params">(<span class="built_in">string</span> S)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1-直接模拟"><a href="#1-直接模拟" class="headerlink" title="1. 直接模拟"></a>1. 直接模拟</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">compressString</span><span class="params">(<span class="built_in">string</span> S)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (S.size() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> S;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span> cur = S[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> sLen = S.size();</span><br><span class="line">        <span class="built_in">string</span> res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; sLen; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (S[i] == cur)</span><br><span class="line">                len++;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//res = res + cur + to_string(len);     //报错，超出内存限制</span></span><br><span class="line">                <span class="comment">//上边这条语句相当于建立了一个新的string对象，其由res+cur+to_string(len)组成，然后赋值给res</span></span><br><span class="line">                <span class="comment">//而下边这条语句是相当于建立了cur+to_string(len)，然后再直接添加到res后面。</span></span><br><span class="line">                res += cur + to_string(len);</span><br><span class="line">                cur = S[i];</span><br><span class="line">                len = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res = res + cur + to_string(len);</span><br><span class="line">        res = res.size() &lt; S.size() ? res : S;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>206.Reverse Linked List</title>
    <url>/reverse-linked-list/</url>
    <content><![CDATA[<p>Reverse a singly linked list.</p>
<p>Example:</p>
<p>Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL<br>Output: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL<br>Follow up:</p>
<p>A linked list can be reversed either iteratively or recursively. Could you implement both?</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/reverse-linked-list">https://leetcode-cn.com/problems/reverse-linked-list</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<hr>
<h2 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1-Iteratively"><a href="#1-Iteratively" class="headerlink" title="1. Iteratively"></a>1. Iteratively</h2><p>(1). 建立新的反向链表。记得所有的结点都得是<code>new</code>的，不然一返回就被清空了。  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* rev = <span class="literal">NULL</span>;</span><br><span class="line">        ListNode* iter = head;</span><br><span class="line">        <span class="keyword">while</span> (iter != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            ListNode* newNode = <span class="keyword">new</span> ListNode(iter-&gt;val);</span><br><span class="line">            newNode-&gt;next = rev;</span><br><span class="line">            rev = newNode;</span><br><span class="line">            iter = iter-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> rev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>(2). 在原有链表基础上直接反向。  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* cur = <span class="literal">NULL</span>;</span><br><span class="line">        ListNode* pre = head;</span><br><span class="line">        <span class="keyword">while</span> (pre != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            ListNode* temp = pre-&gt;next;</span><br><span class="line">            pre-&gt;next = cur;</span><br><span class="line">            cur = pre;</span><br><span class="line">            pre = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2-Recursively"><a href="#2-Recursively" class="headerlink" title="2. Recursively"></a>2. Recursively</h2><p>ABCDEF的逆序<code>(ABCDEF)逆</code>就相当于<code>A &lt;- (BCDEF)逆</code>.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        </span><br><span class="line">        ListNode* revHead = reverseList(head-&gt;next);</span><br><span class="line">        head-&gt;next-&gt;next = head;</span><br><span class="line">        head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> revHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>225. 用队列实现栈</title>
    <url>/implement-stack-using-queues/</url>
    <content><![CDATA[<h2 id="1-一个队列实现"><a href="#1-一个队列实现" class="headerlink" title="1. 一个队列实现"></a>1. 一个队列实现</h2><p><code>push</code>: 在队列后添加元素<br><code>pop</code>: 弹出的实际上是队尾的元素，因此可以用另一个队列暂存前半部分，也可以直接将队列前半部分的元素弹出并添加到队尾，保持了顺序不变。<br><code>top</code>: 同pop<br><code>pop</code>和<code>top</code>操作需要移动整个队列，复杂度为<code>O(n)</code>。  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyStack</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    MyStack() &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Push element x onto stack. */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        q.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Removes the element on top of the stack and returns that element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = q.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            q.push(q.front());</span><br><span class="line">            q.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> val = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get the top element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val = pop();</span><br><span class="line">        q.push(val);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns whether the stack is empty. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> q.empty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyStack* obj = new MyStack();</span></span><br><span class="line"><span class="comment"> * obj-&gt;push(x);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj-&gt;pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj-&gt;top();</span></span><br><span class="line"><span class="comment"> * bool param_4 = obj-&gt;empty();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h2 id="2-复杂度互换"><a href="#2-复杂度互换" class="headerlink" title="2. 复杂度互换"></a>2. 复杂度互换</h2><p>方法1中插入的复杂度是<code>O(1)</code>，弹出复杂度是<code>O(n)</code>。<br>如果pop和top操作较多，则复杂度较高。<br>可以在插入时就将队列的顺序转为栈的顺序，即插入元素后，将其前部分弹出并插入到队尾。<br>从而将插入的复杂度提高到<code>O(n)</code>，pop和top复杂度降低到<code>O(1)</code>。  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyStack</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    MyStack() &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Push element x onto stack. */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        q.push(x);</span><br><span class="line">        <span class="keyword">int</span> n = q.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            q.push(q.front());</span><br><span class="line">            q.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Removes the element on top of the stack and returns that element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get the top element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> q.front();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns whether the stack is empty. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> q.empty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="3-232-用栈实现队列"><a href="#3-232-用栈实现队列" class="headerlink" title="3. 232.用栈实现队列"></a>3. 232.用栈实现队列</h2><p>“用队列实现栈”和“用栈实现队列”是不同的。<br>因为两个栈可以通过先入后出倒倒队列的顺序，而两个队列都是先入先出，不管怎么倒都是同样的顺序。  </p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>695.Max Area of Island</title>
    <url>/max-area-of-island/</url>
    <content><![CDATA[<p>Given a non-empty 2D array grid of 0’s and 1’s, an island is a group of 1’s (representing land) connected 4-directionally (horizontal or vertical.) You may assume all four edges of the grid are surrounded by water.</p>
<p>Find the maximum area of an island in the given 2D array. (If there is no island, the maximum area is 0.)</p>
<p>Example 1:</p>
<p>[[0,0,1,0,0,0,0,1,0,0,0,0,0],<br> [0,0,0,0,0,0,0,1,1,1,0,0,0],<br> [0,1,1,0,1,0,0,0,0,0,0,0,0],<br> [0,1,0,0,1,1,0,0,1,0,1,0,0],<br> [0,1,0,0,1,1,0,0,1,1,1,0,0],<br> [0,0,0,0,0,0,0,0,0,0,1,0,0],<br> [0,0,0,0,0,0,0,1,1,1,0,0,0],<br> [0,0,0,0,0,0,0,1,1,0,0,0,0]]<br>Given the above grid, return 6. Note the answer is not 11, because the island must be connected 4-directionally.<br>Example 2:</p>
<p>[[0,0,0,0,0,0,0,0]]<br>Given the above grid, return 0.<br>Note: The length of each dimension in the given grid does not exceed 50.</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/max-area-of-island">https://leetcode-cn.com/problems/max-area-of-island</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<hr>
<h2 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxAreaOfIsland</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1-bfs"><a href="#1-bfs" class="headerlink" title="1. bfs"></a>1. bfs</h2><p>遍历每个格子，对1的格子做bfs。最终遍历mn个格子，<code>O(mn)</code>。  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxAreaOfIsland</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = grid.size(), n = grid[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; q;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">int</span> xmov[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line">                    <span class="keyword">int</span> ymov[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">                    <span class="keyword">int</span> tempMax = <span class="number">1</span>;</span><br><span class="line">                    q.push(<span class="built_in">make_pair</span>(i, j));</span><br><span class="line">                    <span class="comment">//push而非push_back，因为stack/queue/priority_queue都是容器适配器</span></span><br><span class="line">                    <span class="comment">//分别默认是由底层容器deque/deque/vector实现的。</span></span><br><span class="line">                    grid[i][j] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">                        <span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; qtop = q.front();    <span class="comment">//front &amp; back, 没有迭代器</span></span><br><span class="line">                        q.pop();</span><br><span class="line">                        <span class="keyword">int</span> xtop = qtop.first, ytop = qtop.second;</span><br><span class="line">                        </span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> imov = <span class="number">0</span>; imov &lt; <span class="number">4</span>; imov++) &#123;</span><br><span class="line">                            <span class="keyword">int</span> x = xtop + xmov[imov];</span><br><span class="line">                            <span class="keyword">int</span> y = ytop + ymov[imov];</span><br><span class="line">                            <span class="keyword">if</span> (x &gt;= <span class="number">0</span> &amp;&amp; x &lt; m &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; n &amp;&amp; grid[x][y] == <span class="number">1</span>) &#123;</span><br><span class="line">                                tempMax++;</span><br><span class="line">                                q.push(<span class="built_in">make_pair</span>(x, y));</span><br><span class="line">                                grid[x][y] = <span class="number">0</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    res = res &gt;= tempMax ? res : tempMax;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>bfs</tag>
      </tags>
  </entry>
  <entry>
    <title>300.Longest Increasing Subsequence</title>
    <url>/longest-increasing-subsequence/</url>
    <content><![CDATA[<p>Given an unsorted array of integers, find the length of longest increasing subsequence.</p>
<p>Example:</p>
<p>Input: [10,9,2,5,3,7,101,18]<br>Output: 4<br>Explanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4.<br>Note:</p>
<p>There may be more than one LIS combination, it is only necessary for you to return the length.<br>Your algorithm should run in O(n2) complexity.<br>Follow up: Could you improve it to O(n log n) time complexity?</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/longest-increasing-subsequence">https://leetcode-cn.com/problems/longest-increasing-subsequence</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<hr>
<h2 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1-朴素dpO-n-2"><a href="#1-朴素dpO-n-2" class="headerlink" title="1. 朴素dpO(n^2)"></a>1. 朴素dp<code>O(n^2)</code></h2><p>设<code>dp[i]</code>为以<code>a[i]</code>为结尾的最长上升子序列的长度。<br><code>dp[i]=max(dp[j]) + 1, j&lt;i且a[j]到a[i]满足递增条件</code>，需要遍历之前所有的<code>dp[j]</code>。  </p>
<h2 id="2-dp-二分查找O-nlogn"><a href="#2-dp-二分查找O-nlogn" class="headerlink" title="2. dp+二分查找O(nlogn)"></a>2. dp+二分查找<code>O(nlogn)</code></h2><p>设<code>dp[i]</code>为长度为<code>i</code>的上升子序列的<strong>最小的</strong>末尾元素（即最小的最大值），如1,2,4和1,2,3，<code>dp[3]=3</code>。<br>遍历序列<code>a</code>，对于每个元素<code>a[i]</code>，有：  </p>
<ul>
<li><code>a[i]&gt;dp[last]</code><br><code>dp[++last]=a[i]</code>  </li>
<li><code>a[i]&lt;dp[last]</code><br><code>dp[1]~dp[last]</code>之间总能找到一个位置<code>loc</code>，使得<code>dp[loc-1]&lt;a[i]&lt;dp[loc]</code>，那么可以用<code>a[i]</code>替换<code>dp[loc]</code>，代表可以用更小的结尾元素获得同样的长度。<br>在方法1中，查找是<code>O(n)</code>的，所以结果是<code>O(n^2)</code>。<br>此处，由于<code>dp</code>序列必是非递减的，可以利用二分查找，从而达到<code>O(nlogn)</code>的时间复杂度。  </li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">int</span> *dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++)</span><br><span class="line">            dp[i] = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> resLen = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (resLen == <span class="number">0</span> || nums[i] &gt; dp[resLen])</span><br><span class="line">                dp[++resLen] = nums[i];</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> left = <span class="number">1</span>, right = resLen, mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (dp[mid] &gt;= nums[i])</span><br><span class="line">                        right = mid;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        left = mid + <span class="number">1</span>;</span><br><span class="line">                    mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                dp[mid] = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">delete</span> []dp;</span><br><span class="line">        <span class="keyword">return</span> resLen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title>15. 3sum</title>
    <url>/3sum/</url>
    <content><![CDATA[<p>Given an array nums of n integers, are there elements a, b, c in nums such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero.</p>
<p>Note:</p>
<p>The solution set must not contain duplicate triplets.</p>
<p>Example:</p>
<p>Given array nums = [-1, 0, 1, 2, -1, -4],</p>
<p>A solution set is:<br>[<br>  [-1, 0, 1],<br>  [-1, -1, 2]<br>]</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/3sum">https://leetcode-cn.com/problems/3sum</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<hr>
<h2 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">threeSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1-朴素"><a href="#1-朴素" class="headerlink" title="1. 朴素"></a>1. 朴素</h2><p>遍历每个三元组，判断是否和为0即可，<code>O(n^3)</code>。<br>但是还得想办法避免重复。<br>使用<code>set</code>作为初始的存储容器，每个符合条件的三元组在<code>vector</code>中由小到大存放，最后把<code>set</code>转储到<code>vector</code>即可。<br>不过<code>set</code>的<code>insert()</code>是<code>O(logm)</code>的，因此总的复杂度是<code>O(n^3logm)</code>，<code>m</code>是<code>set.size()</code><br><strong>提交失败，超时了。</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">threeSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">3</span>)</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; st;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">2</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n - <span class="number">1</span>; j++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = j + <span class="number">1</span>; k &lt; n; k++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(nums[i] + nums[j] + nums[k] == <span class="number">0</span>)&#123;</span><br><span class="line">                        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp = &#123;nums[i], nums[j], nums[k]&#125;;</span><br><span class="line">                        sort(temp.begin(), temp.end());</span><br><span class="line">                        st.insert(temp);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> iter = st.begin(); iter != st.end(); ++iter)</span><br><span class="line">            ans.push_back(*iter);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2-先处理两个，然后查找需要的一个"><a href="#2-先处理两个，然后查找需要的一个" class="headerlink" title="2. 先处理两个，然后查找需要的一个"></a>2. 先处理两个，然后查找需要的一个</h2><p>参考题目：<em>1. Two Sum</em>。<br><del>使用<code>map&lt;pair&lt;int, int&gt;&gt;</code>，<code>key</code>为<code>pair(ai, bi)</code>，<code>value</code>为<code>0 - nums[ai] - nums[bi]</code>。</del><br><del><code>key</code>记录索引而不是直接记录值是为了方便判断避免多次使用同一个数。</del><br><del>首先遍历<code>a, b</code>，储存到<code>map</code>中，<code>value</code>储存还需要的值。</del><em>问题是<code>map[]</code>是<code>O(m)</code>，所以应该是<code>O(mn^2)</code>。</em><br><del>然后遍历<code>map</code>，判断当前的<code>value</code>在<code>nums</code>中是否存在，<code>O(mn)</code>，<code>m = map.size()</code>。</del><br>提交失败，超时。原因是没有考虑到<code>map[]</code>并不是<code>O(1)</code>而是<code>O(m)</code>的。<br><em>实际上，上述内容中，并不需要使用<code>map</code>。</em><br>对于<code>1. Two Sum</code>，使用<code>map/ unordered_map</code>是为了将查找的时间由<code>O(n)</code>降低到<code>O(1)/ O(logn)</code>。<br>而在此处，我们首先把两个的处理好了，然后再遍历它，搜索剩余的一个，所以此处<code>map</code>是没必要的，反而会增加时间。<br>虽说<code>map/ unordered_map</code>可以记录<code>pair&lt;int, int&gt;</code>和相对应的需要的值，不过就算不记录<code>value</code>，后面再算也是可以的。<br>因此这里需要的只是一个对于插入是<code>O(1)</code>的数据结构，可以选择<code>vector/ list/ set/ unordered_map</code>等。<br>这里选择<code>list</code>，仍然是先记录索引。<br><em>不过提交仍然超时，原因是错估了<code>list.size()</code>的大小，它实际上能到达<code>O(n^2)</code></em>  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">threeSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">3</span>)       <span class="comment">//判断特殊情况</span></span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">list</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; ls;    <span class="comment">//预处理，O(n^2)</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++)</span><br><span class="line">                ls.push_back(<span class="built_in">pair</span>(i, j));</span><br><span class="line">        <span class="comment">//这里产生的ls中元素个数大约是O(n^2)的，而不是预想的m &lt; n个，因此导致超时。</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; st;</span><br><span class="line">        <span class="comment">//应该是这里的问题，ls中有(n-1)+(n-2)+...+1 = O(n^2)个，我以为是O(m)个，m&lt;n，但是实际上m是约等于n^2的。</span></span><br><span class="line">        <span class="comment">//因此对于每一个ls中的元素，又得去nums中找n个元素，所以总计仍然是O(n^3)的。</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> iter = ls.begin(); iter != ls.end(); ++iter)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i != iter-&gt;first &amp;&amp; i != iter-&gt;second &amp;&amp; nums[iter-&gt;first] + nums[iter-&gt;second] + nums[i] == <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec = &#123;nums[iter-&gt;first], nums[iter-&gt;second], nums[i]&#125;;</span><br><span class="line">                    sort(vec.begin(), vec.end());   <span class="comment">//vector中3个数由小到大，通过set去重</span></span><br><span class="line">                    st.insert(vec);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> iter = st.begin(); iter != st.end(); ++iter)</span><br><span class="line">            ans.push_back(*iter);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="3-完全类似Two-Sum，先确定一个元素，然后按照Two-Sum来做，相当于n次Two-Sum"><a href="#3-完全类似Two-Sum，先确定一个元素，然后按照Two-Sum来做，相当于n次Two-Sum" class="headerlink" title="3. 完全类似Two Sum，先确定一个元素，然后按照Two Sum来做，相当于n次Two Sum."></a>3. 完全类似Two Sum，先确定一个元素，然后按照Two Sum来做，相当于n次Two Sum.</h2><p>fix 1个元素是<code>O(n)</code>，然后Two Sum如果使用hash表（<code>unordered_map</code>)则为<code>O(n)</code>，总计<code>O(n^2)</code>。<br>仍然是需要<code>set</code>去重。<br>不过提交还是失败了，<del>不知道为什么会超时，明明是<code>O(n^2)</code>的。</del><br><em>知道了，它不是<code>O(n^2)</code>的，而是<code>O(n^2logm)</code>的，而且最坏是<code>O(n^2logn)</code>的，比如题目卡的极端情况<code>0,0,0,...,0</code>。</em><br><em>利用<code>set</code>去重是有时间损失的，因为<code>set</code>内部靠红黑树建立有序关系，<code>set.insert()</code>是<code>O(logn)</code>的。</em>  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">threeSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">3</span>)</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; st;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mp;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i == j)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(mp.count(nums[j]))&#123;</span><br><span class="line">                    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec = &#123;nums[i], nums[j], nums[mp[nums[j]]]&#125;;</span><br><span class="line">                    sort(vec.begin(), vec.end());</span><br><span class="line">                    st.insert(vec);</span><br><span class="line">                &#125;<span class="keyword">else</span></span><br><span class="line">                    mp[<span class="number">0</span> - nums[i] - nums[j]] = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> iter = st.begin(); iter != st.end(); ++iter)</span><br><span class="line">            ans.push_back(*iter);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="4-排序-双指针-剪枝"><a href="#4-排序-双指针-剪枝" class="headerlink" title="4. 排序+双指针+剪枝"></a>4. 排序+双指针+剪枝</h2><p><strong>排序</strong>：为了便于之后查找和为0的元素，并且便于去重。且<code>O(nlogn)</code>的时间复杂度对于大概<code>O(n^2)</code>的这道题来说不算什么。<br><strong>双指针</strong>：首先确定一个元素，然后利用双指针在其右侧查找满足和为0的元素。<br><strong>剪枝</strong>：由于是有序的，所以为了实现<code>a+b+c=0</code>，则最小的<code>a</code>必须满足<code>a&lt;0</code>，如果到了<code>a&gt;0</code>，可以直接剪枝结束了。  </p>
<p>思路是：  </p>
<ol>
<li>首先由小到大排序，<code>O(nlogn)</code>。  </li>
<li>遍历fix每个元素作为<code>a</code>，然后从该元素右侧的区间中寻找满足<code>a + b + c = 0</code>的元素<code>b</code>和<code>c</code>。  </li>
<li>查找方法是设置双指针<code>left = i + 1</code>, <code>right = n - 1</code>，然后二者向中心靠拢直至碰撞。当等式左侧结果大于0时，<code>right--</code>；当等式左侧结果小于0时，<code>left++</code>；等于0时，记录，并<code>left++, right--</code>。  </li>
<li>由于寻找<code>b, c</code>是从<code>a</code>的右侧寻找，且已经将数组由小到大排列，因此当<code>a&gt;0</code>时就可剪枝结束遍历。  </li>
<li>上述方法还需要进行去重。并不是选择和上述方法相同的利用<code>set</code>去重（因为<code>set</code>去重有时间损失，<code>O(logn)</code>），而是在寻找<code>a, b, c</code>时直接去重。方法是当出现相等的元素时，先处理第一个元素然后再跳过后面的相等的，而不能跳过前面相等的只处理最后一个，比如<code>-1, -1, 0, 1, 2</code>。  </li>
</ol>
<p><a href="https://github.com/grandyang/leetcode/issues/15">参考链接</a>  </p>
<p><strong>这个解法的聪明之处：</strong>  </p>
<ol>
<li>用仅仅<code>O(nlogn)</code>的时间进行了排序，方便了之后的去重和双指针的查找操作。</li>
<li>并不是fix一个元素然后完全仿照<code>2. Two Sum</code>，因为后者不需要去重。</li>
<li>不使用<code>set</code>去重，因为<code>set.insert()</code>有<code>O(logn)</code>的时间损失，而是在有序的基础上先匹配，后跳过。</li>
<li>使用双指针。因为已经是有序的了，所以利用双指针从两侧夹逼(<code>11. Container With Most Water</code>)就可以固定到<code>left</code>和<code>right</code>。</li>
<li>双指针的移动为什么偏小就<code>left++</code>，偏大就<code>right--</code>，参考下图：<img src="2pointers.png" alt="2pointers"></li>
</ol>
<p><strong><code>1. Two Sum</code> 与 <code>15. 3Sum</code> 的区别</strong></p>
<ol>
<li><code>two sum</code>使用的是<code>hash表</code>，遍历一次数组<code>O(n)</code>就可以解决问题。</li>
<li><code>3sum</code>很类似于先fix一个元素，然后对右侧元素进行<code>two sum</code>。</li>
<li>不过问题在于，<code>two sum</code>是没有重复值的，<code>3sum</code>有重复值并且需要去重。</li>
<li>如果后期用<code>set</code>去重，则会额外有<code>O(logn)</code>的时间损失。</li>
<li>如果还是使用<code>two sum</code>并且在前期去重，则需要记录已经得到的数据组，需要额外的<code>unordered_map&lt;pair&lt;int, int&gt;, bool&gt;</code>，非常浪费空间。</li>
<li>所以<code>3sum</code>采用的方法是双指针，并且从两侧夹逼，毕竟已经是有序数组了。</li>
<li><code>two sum</code>也可以使用双指针，但是毕竟它不需要去重，并且利用<code>hash表</code>已经到达<code>O(n)</code>的复杂度了，再排序<code>O(nlogn)</code>利用双指针就有些多余了。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">threeSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">3</span>)</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        </span><br><span class="line">        sort(nums.begin(), nums.end());     <span class="comment">//sort</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span>)    <span class="comment">//pruning</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span> (i &lt; n - <span class="number">2</span> &amp;&amp; i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) <span class="comment">//skip repeated values</span></span><br><span class="line">                i++;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">int</span> left = i + <span class="number">1</span>, right = n - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] + nums[left] + nums[right] == <span class="number">0</span>) &#123;</span><br><span class="line">                    ans.push_back(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&#123;nums[i], nums[left], nums[right]&#125;);</span><br><span class="line">                    left++;</span><br><span class="line">                    right--;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] + nums[left] + nums[right] &lt; <span class="number">0</span>)</span><br><span class="line">                    left++;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    right--;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//skip repeated values</span></span><br><span class="line">                <span class="keyword">while</span> (left &lt; right &amp;&amp; left &gt; i + <span class="number">1</span> &amp;&amp; nums[left] == nums[left - <span class="number">1</span>])</span><br><span class="line">                    left++;</span><br><span class="line">                <span class="keyword">while</span> (left &lt; right &amp;&amp; right &lt; n - <span class="number">1</span> &amp;&amp; nums[right] == nums[right + <span class="number">1</span>])</span><br><span class="line">                    right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>10.正则表达式匹配</title>
    <url>/regular-expression-matching/</url>
    <content><![CDATA[<p>Given an input string (s) and a pattern (p), implement regular expression matching with support for ‘.’ and ‘*’.</p>
<p>‘.’ Matches any single character.<br>‘*’ Matches zero or more of the preceding element.<br>The matching should cover the entire input string (not partial).</p>
<p>Note:</p>
<p>s could be empty and contains only lowercase letters a-z.<br>p could be empty and contains only lowercase letters a-z, and characters like . or *.<br>Example 1:</p>
<p>Input:<br>s = “aa”<br>p = “a”<br>Output: false<br>Explanation: “a” does not match the entire string “aa”.<br>Example 2:</p>
<p>Input:<br>s = “aa”<br>p = “a*”<br>Output: true<br>Explanation: ‘*’ means zero or more of the preceding element, ‘a’. Therefore, by repeating ‘a’ once, it becomes “aa”.<br>Example 3:</p>
<p>Input:<br>s = “ab”<br>p = “.<em>“<br>Output: true<br>Explanation: “.</em>“ means “zero or more (*) of any character (.)”.<br>Example 4:</p>
<p>Input:<br>s = “aab”<br>p = “c<em>a</em>b”<br>Output: true<br>Explanation: c can be repeated 0 times, a can be repeated 1 time. Therefore, it matches “aab”.<br>Example 5:</p>
<p>Input:<br>s = “mississippi”<br>p = “mis<em>is</em>p*.”<br>Output: false</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/regular-expression-matching">https://leetcode-cn.com/problems/regular-expression-matching</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<hr>
<h2 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isMatch</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1-直接遍历"><a href="#1-直接遍历" class="headerlink" title="1. 直接遍历"></a>1. 直接遍历</h2><p><code>O(n)</code><br>失败了……<br>本来觉得还算简单来着，但是这个<code>*</code>着实气人，它想匹配多少就匹配多少，连<code>a*a</code>都有。。<br>下面的代码是错的，没有考虑这种智障输入。  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isMatch</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ni = s.size();</span><br><span class="line">        <span class="keyword">int</span> nj = p.size();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">char</span> pred = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(i &lt; ni &amp;&amp; j &lt; nj)&#123;</span><br><span class="line">            <span class="keyword">if</span> (p[j] == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(p[j + <span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span>)&#123; <span class="comment">// &quot;.*&quot; matches everything</span></span><br><span class="line">                    i = ni;</span><br><span class="line">                    j++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    i++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (p[j] == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">while</span>(i &lt; ni &amp;&amp; s[i] == pred)</span><br><span class="line">                    i++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (p[j + <span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span>)&#123;</span><br><span class="line">                    <span class="keyword">while</span>(i &lt; ni &amp;&amp; s[i] == p[j])</span><br><span class="line">                        i++;</span><br><span class="line">                    j++;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span> (s[i] == p[j])</span><br><span class="line">                        i++;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            j++;</span><br><span class="line">            pred = s[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(i == ni &amp;&amp; j &lt; nj)&#123;</span><br><span class="line">            <span class="keyword">if</span> (p[j] == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(p[j + <span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">                    j += <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (p[j] == <span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">                j++;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i &lt; ni)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2-动态规划"><a href="#2-动态规划" class="headerlink" title="2. 动态规划"></a>2. 动态规划</h2><p>因为不能确定<code>*</code>到底匹配多少个前一个字符，所以可以都测试一下。<br>设<code>bool dp[i][j]</code>用来代表<code>s</code>的前<code>i</code>个字符和<code>p</code>的前<code>j</code>个字符的匹配关系，也就是<code>s[0 ~ i-1]</code>和<code>p[0 ~ j-1]</code><br>那么<code>dp[i][j]</code>就可以依靠前面<code>dp[][]</code>的<code>True/False</code>决定，表示后半部分匹配，结果由前半部分的匹配情况确定。  </p>
<p><strong>以下讨论<code>dp[i][j]</code>，即<code>s[0 ~ i-1]</code>与<code>p[0 ~ j-1]</code>的匹配情况。</strong>  </p>
<ul>
<li><strong><code>s[i-1] == p[j-1]</code></strong><br><code>dp[i][j] = dp[i-1][j-1]</code><br>说明<code>p</code>中肯定是字母，并且二者在该位上匹配，所以<code>s[0 ~ i-1], p[0 ~ j-1]</code>这部分是否匹配取决于<code>dp[i-1][j-1]</code>。  </li>
<li><strong><code>p[j-1] == &#39;.&#39;</code></strong><br><code>dp[i][j] = dp[i-1][j-1]</code><br><code>.</code>可以匹配任何字母，因此二者在该位上也是匹配的，所以如上。  </li>
<li><strong><code>p[j-1] == &#39;*&#39;</code></strong><br><code>*</code>可以匹配0次或多(&gt;0)次在<code>*</code>左侧的那个字符。  <ul>
<li><strong><code>s[i-1] != p[j-1-1] &amp;&amp; p[j-1-1] != &#39;.&#39;</code></strong><br><code>dp[i][j] = dp[i][j-2]</code><br>无法匹配，只能匹配0次。  </li>
<li><strong><code>else / s[i-1] == p[j-1-1] || p[j-1-1] == &#39;.&#39;</code></strong><br>可以匹配，可能匹配0次或多(&gt;0)次。  <ul>
<li><strong>匹配0次</strong><br><code>dp[i][j] = dp[i][j-2]</code><br>即便<code>s[i-1] == p[j-1-1]</code>也是有可能匹配0次的，比如<code>s = abc, p = &#39;abcc*&#39;</code>。<br>匹配0次相当于这个字符和<code>*</code>都不存在了，因此跳过这两个字符，如<code>s = ab, p = abc*</code>  </li>
<li><strong>匹配多(&gt;0)次</strong><br><code>dp[i][j] = dp[i-1][j]</code><br>匹配<code>k</code>次依赖于匹配<code>k-1</code>次，后者又依赖于<code>k-2</code>次，因此最终就变成了匹配0次，所以步骤就是依赖于<code>dp[i-1][j]</code>  </li>
</ul>
</li>
</ul>
</li>
<li><strong><code>else / s[i-1] != p[j-1] &amp;&amp; p[j-1] != &#39;.&#39; &amp;&amp; p[j-1] != &#39;*&#39;</code></strong><br>  <code>dp[i][j] = false</code><br>  不匹配。  </li>
</ul>
<p>初始化：<br><img src="init.png" alt="init">  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isMatch</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ns = s.size();</span><br><span class="line">        <span class="keyword">int</span> np = p.size();</span><br><span class="line">        <span class="keyword">if</span>(ns == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(np % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; np; i += <span class="number">2</span>)</span><br><span class="line">                    <span class="keyword">if</span>(p[i] != <span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(np == <span class="number">0</span> &amp;&amp; ns != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">bool</span> **dp = <span class="keyword">new</span> <span class="keyword">bool</span>*[ns + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= ns; i++)</span><br><span class="line">            dp[i] = <span class="keyword">new</span> <span class="keyword">bool</span>[np + <span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//initialization</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= np; i++)</span><br><span class="line">            dp[<span class="number">0</span>][i] = dp[<span class="number">0</span>][i<span class="number">-2</span>] &amp;&amp; p[i<span class="number">-1</span>] == <span class="string">&#x27;*&#x27;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= ns; i++)</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//dp</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= ns; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= np; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s[i<span class="number">-1</span>] == p[j<span class="number">-1</span>] || p[j<span class="number">-1</span>] == <span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">                    dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(p[j<span class="number">-1</span>] == <span class="string">&#x27;*&#x27;</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(s[i<span class="number">-1</span>] != p[j<span class="number">-2</span>] &amp;&amp; p[j<span class="number">-2</span>] != <span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">                        dp[i][j] = dp[i][j<span class="number">-2</span>];</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        dp[i][j] = dp[i][j<span class="number">-2</span>] || dp[i<span class="number">-1</span>][j];</span><br><span class="line">                &#125;<span class="keyword">else</span></span><br><span class="line">                    dp[i][j] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">bool</span> ans = dp[ns][np];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ns + <span class="number">1</span>; i++)</span><br><span class="line">            <span class="keyword">delete</span> []dp[i];</span><br><span class="line">        <span class="keyword">delete</span> []dp;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>4. 寻找两个正序数组的中位数</title>
    <url>/median-of-two-sorted-arrays/</url>
    <content><![CDATA[<p>There are two sorted arrays nums1 and nums2 of size m and n respectively.</p>
<p>Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).</p>
<p>You may assume nums1 and nums2 cannot be both empty.</p>
<p>Example 1:</p>
<p>nums1 = [1, 3]<br>nums2 = [2]</p>
<p>The median is 2.0<br>Example 2:</p>
<p>nums1 = [1, 2]<br>nums2 = [3, 4]</p>
<p>The median is (2 + 3)/2 = 2.5</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays">https://leetcode-cn.com/problems/median-of-two-sorted-arrays</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<hr>
<h2 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1-二分"><a href="#1-二分" class="headerlink" title="1. 二分"></a>1. 二分</h2><p>题目没有明说，但是两个有序数组都是非降序的。<br>题目要求复杂度<code>O(log(m+n))</code>，所以连接后排序<code>O(nlogn)</code>，遍历<code>O(n)</code>都不行了。对数复杂度一般是二分法。<br>但是需要确定二分的内容是什么。<br>遍历肯定是不可以的了，所以需要在一个非全体有序的条件下找到中间的部分。<br>因此可以想象把大数组分成两部分，选取中间的数据，左右两边的数据只需要分别取最大值和最小值就可以了，不需要非得是有序。<br>所以慢慢可以想到，应该是二分两个数组左右部分的长度，也就是把每个数组都分为左右两部分。<br>通过推导公式，得知可以把所有的长度都利用<code>l1</code>表示。<br>然后发现最终结果的表示需要根据新的大数组的长度的奇偶性确定，所以分类讨论最终结果的表示方法。  </p>
<p><img src="draft.png" alt="draft">  </p>
<p>需要注意的是<code>l1, l2</code>表示的是长度，用作索引的时候需要注意-1+1。<br>测试的时候得到一个bug，问题是不能把<code>return</code>写到<code>if-else</code>条件中，即便最后必然执行<code>else</code>中的<code>return</code>，但是只要有一个<code>if</code>条件中没有<code>return</code>，编译就会报错。（依赖于编译器）<br>第一次提交失败，错误样例是<code>nums1 = [], nums2 = [1]</code>。题目只说cannot be <em>both</em> empty，没说cannot be empty…</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = nums1.size();</span><br><span class="line">        <span class="keyword">int</span> n = nums2.size();</span><br><span class="line">        <span class="keyword">if</span> (m &gt; n) &#123;         <span class="comment">// set nums1 shorter</span></span><br><span class="line">            <span class="keyword">auto</span> temp = nums1;</span><br><span class="line">            nums1 = nums2;</span><br><span class="line">            nums2 = temp;</span><br><span class="line">            <span class="keyword">auto</span> tempi = m;</span><br><span class="line">            m = n;</span><br><span class="line">            n = tempi;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = m;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// l1 &amp; l2 are the lengths, not indices</span></span><br><span class="line">        <span class="keyword">int</span> l1 = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> l2 = (m + n + <span class="number">1</span>) / <span class="number">2</span> - l1;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="comment">// l1 l2 的边界条件是为了后面nums的-1不越界，而不会造成其他影响</span></span><br><span class="line">            <span class="keyword">if</span> (l1 &gt; <span class="number">0</span> &amp;&amp; l2 &lt; n &amp;&amp; nums1[l1 - <span class="number">1</span>] &gt; nums2[l2])</span><br><span class="line">                right = l1 - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (l1 &lt; m &amp;&amp; l2 &gt; <span class="number">0</span> &amp;&amp; nums2[l2 - <span class="number">1</span>] &gt; nums1[l1])</span><br><span class="line">                left = l1 + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">            l1 = (left + right) / <span class="number">2</span>;</span><br><span class="line">            l2 = (m + n + <span class="number">1</span>) / <span class="number">2</span> - l1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> maxL;</span><br><span class="line">        <span class="keyword">if</span> (l1 == <span class="number">0</span>)</span><br><span class="line">            maxL = nums2[l2 - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (l2 == <span class="number">0</span>)</span><br><span class="line">            maxL = nums1[l1 - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            maxL = max(nums1[l1 - <span class="number">1</span>], nums2[l2 - <span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">if</span> ((m + n) % <span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> maxL;    <span class="comment">//fix empty bug</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> minR;</span><br><span class="line">        <span class="keyword">if</span> (l1 == m)</span><br><span class="line">            minR = nums2[l2];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (l2 == n)</span><br><span class="line">            minR = nums1[l1];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            minR = min(nums1[l1], nums2[l2]);</span><br><span class="line">        <span class="keyword">return</span> (maxL + minR) / <span class="number">2.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title>2. Add Two Numbers</title>
    <url>/add-two-numbers/</url>
    <content><![CDATA[<p>You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.</p>
<p>You may assume the two numbers do not contain any leading zero, except the number 0 itself.</p>
<p>Example:</p>
<p>Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)<br>Output: 7 -&gt; 0 -&gt; 8<br>Explanation: 342 + 465 = 807.</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/add-two-numbers">https://leetcode-cn.com/problems/add-two-numbers</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<hr>
<h2 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1-遍历得到数据，相加后直接修改成符合条件的链表格式，O-n"><a href="#1-遍历得到数据，相加后直接修改成符合条件的链表格式，O-n" class="headerlink" title="1. 遍历得到数据，相加后直接修改成符合条件的链表格式，O(n)"></a>1. 遍历得到数据，相加后直接修改成符合条件的链表格式，O(n)</h2><p><strong>………………溢出了，只能模拟了</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n1 = <span class="number">0</span>, n2 = <span class="number">0</span>, sum = <span class="number">0</span>;</span><br><span class="line">        ListNode *iter1 = l1;</span><br><span class="line">        ListNode *iter2 = l2;</span><br><span class="line">        <span class="keyword">int</span> pw1 = <span class="number">0</span>, pw2 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(iter1 != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            n1 += (iter1-&gt;val * <span class="built_in">pow</span>(<span class="number">10</span>, pw1++));</span><br><span class="line">            iter1 = iter1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(iter2 != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            n2 += (iter2-&gt;val * <span class="built_in">pow</span>(<span class="number">10</span>, pw2++));</span><br><span class="line">            iter2 = iter2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sum = n1 + n2;</span><br><span class="line">        ListNode *ans = <span class="keyword">new</span> ListNode(sum % <span class="number">10</span>);</span><br><span class="line">        sum /= <span class="number">10</span>;</span><br><span class="line">        ListNode *iter = ans;</span><br><span class="line">        <span class="keyword">while</span>(sum != <span class="number">0</span>)&#123;</span><br><span class="line">            iter-&gt;next = <span class="keyword">new</span> ListNode(sum % <span class="number">10</span>);</span><br><span class="line">            sum /= <span class="number">10</span>;</span><br><span class="line">            iter = iter-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2-模拟"><a href="#2-模拟" class="headerlink" title="2. 模拟"></a>2. 模拟</h2><p>链表头是低位，链表尾是高位，可以两条链对应从低位向高位做加法，用temp记录进位。<code>O(n)</code><br><em>提交错了好几次，主要是因为没有处理好长度之间的关系。</em><br><em>比如一条链结束了，直接把另一条链接到ans链上了，但是这个时候还可能temp是有值的，需要继续加</em></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        ListNode *iter1 = l1;</span><br><span class="line">        ListNode *iter2 = l2;</span><br><span class="line">        <span class="keyword">int</span> temp = iter1-&gt;val + iter2-&gt;val;</span><br><span class="line">        iter1 = iter1-&gt;next;</span><br><span class="line">        iter2 = iter2-&gt;next;</span><br><span class="line">        ListNode *ans = <span class="keyword">new</span> ListNode(temp % <span class="number">10</span>);</span><br><span class="line">        temp /= <span class="number">10</span>;</span><br><span class="line">        ListNode *iter = ans;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(iter1 != <span class="literal">NULL</span> || iter2 != <span class="literal">NULL</span> || temp != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> v1 = <span class="number">0</span>, v2 = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(iter1 != <span class="literal">NULL</span>)&#123;</span><br><span class="line">                v1 = iter1-&gt;val;</span><br><span class="line">                iter1 = iter1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(iter2 != <span class="literal">NULL</span>)&#123;</span><br><span class="line">                v2 = iter2-&gt;val;</span><br><span class="line">                iter2 = iter2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//对啊，上边这个其实不用这么麻烦，直接判断，如果是NULL不加就可以了，没必要再定义变量</span></span><br><span class="line"></span><br><span class="line">            temp += (v1 + v2);</span><br><span class="line"></span><br><span class="line">            iter-&gt;next = <span class="keyword">new</span> ListNode(temp % <span class="number">10</span>);</span><br><span class="line">            temp /= <span class="number">10</span>;</span><br><span class="line">            iter = iter-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
</search>
